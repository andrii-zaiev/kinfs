<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="LERSUS 3.3.0.0" /><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Корпоративные информационные системы — Теория — Распределение и тиражирование данных</title><script language="javascript" type="text/javascript" src="../../00/styles/files/apiwrapper.js"> </script><script language="javascript" type="text/javascript" src="../../00/styles/files/sco.js"> </script><link href="../../00/styles/files/style.css" rel="stylesheet" type="text/css" /></head><body><table id="mainOuter"><tr><td id="topOuter"><table id="topInner"><tr class="row1"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4" id="shortcuts"><div><ul class="level0"><li><a href="../../00/content/authors1.html">Авторы</a></li><li>|</li><li><a href="../../00/content/contacts1.html">Контакты</a></li><li>|</li><li><a href="../../00/content/instructions1.html">Методические указания</a></li><li>|</li><li><a href="../../00/content/annotation1.html">Аннотация</a></li><li>|</li><li><a href="#" onclick="history.back(); return false;">Назад</a></li></ul></div></td></tr><tr class="row2"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4"><div id="courseTitle">Корпоративные информационные системы</div><div id="courseSubTitle">Распределенные базы данных : Распределение и тиражирование данных</div></td></tr></table></td></tr><tr><td id="contentOuter"><table id="contentInner"><tr><td class="menuOuter"><table class="menuInner"><tr><td><ul class="level0"><li><a href="../../00/styles/courses.html">Содержание курса</a></li><li><span>Теория</span></li><ul class="level1"><li><a href="../../04/content/content1.html">Распределенное хранение данных</a></li><li><a href="../../04/content/content2.html">Транзакции</a></li><li><a href="../../04/content/content3.html">Восстановление данных. Управление параллелизмом</a></li><li><a href="../../04/content/content4.html">Обработка распределенных запросов и распределенная модель транзакций</a></li><li><a href="../../04/content/content5.html">Распределение и тиражирование данных</a></li></ul><li><span>Текущий контроль знаний</span></li><ul class="level1"><li><a href="../../04/content/multiply-choice-test1.html">Транзакции и блокировки</a></li><li><a href="../../04/content/multiply-choice-test5.html">Распределенные базы данных</a></li></ul><li><a href="../../04/styles/glossary.html">Словарь терминов</a></li><li><a href="../../04/04.pdf" target="_blank">Версия для печати</a></li></ul></td></tr></table></td><td class="content"><div id="content"><div id="topBlankStripe"> </div><span id="lnk2705fad279ee401ab11071f38e3cb480"> </span><h1 align="left" class="headline-source">     Распределение и тиражирование данных</h1><span id="lnkea1fb93c26a946d0955e3c891ccec467"> </span><div class="section"><p align="justify" class="paragraph-source">     Одним из основных требований к распределенной базе данных остается требование наличия развитой методологии распределения и размещения данных, включая разбиение.</p></div><span id="lnk2ccceff41d224139ae916dd969464002"> </span><h2 align="left" class="paragraph-headline-source">     Технология COM</h2><span id="lnk75099963fa8e419eb004e62ee3d90200"> </span><div class="section"><p align="justify" class="paragraph-source">     <i>COM </i>(Component Object Model) - это объектная модель компонентов. Данная технология является базовой для технологий ActiveX и OLE. Технологии OLE и ActiveX - всего лишь надстройки над данной технологией. В качестве примера можно привести объект TObject, как базовый объект VCL Delphi. Точно так же технология СОМ является базовой по отношению к OLE и ActiveX.</p><p align="justify" class="paragraph-source">     <b>Технология СОМ применяется</b> при описании API и двоичного стандарта для связи объектов различных языков и сред программирования. СОМ предоставляет модель взаимодействия между компонентами и приложениями. </p><p align="justify" class="paragraph-source">     Технология СОМ работает с так называемыми СОМ-объектами. СОМ-объекты похожи на обычные объекты визуальной библиотеки компонентов Delphi. В отличие от объектов VCL Delphi, СОМ-объекты содержат свойства, методы и интерфейсы. </p><p align="justify" class="paragraph-source">     Обычный СОМ-объект включает в себя один или несколько интерфейсов. Каждый из этих интерфейсов имеет собственный указатель. </p><p align="justify" class="paragraph-source">     <b>Технология СОМ имеет два явных преимущества: </b></p><p align="justify" class="paragraph-source">     - создание СОМ-объектов не зависит от языка программирования. Таким образом, СОМ-объекты могут быть написаны на различных языках; </p><p align="justify" class="paragraph-source">     - СОМ-объекты могут быть использованы в любой среде программирования под Windows. В число этих сред входят Delphi, Visual C++, C++Builder, Visual Basic, и многие другие.</p><p align="justify" class="paragraph-source">     Хотя технология СОМ обладает явными плюсами, она имеет также и минусы, среди которых зависимость от платформы. То есть, данная технология применима только в операционной системе Windows и на платформе Intel.</p><p align="justify" class="paragraph-source">     Все СОМ-объекты обычно содержатся в файлах с расширением DLL или OCX. Один такой файл может содержать как одиночный СОМ-объект, так и несколько СОМ-объектов. </p><p align="justify" class="paragraph-source">     Ключевым аспектом технологии СОМ является возможность предоставления связи и взаимодействия между компонентами и приложениями, а также реализация клиент-серверных взаимодействий при помощи интерфейсов. </p><p align="justify" class="paragraph-source">     Технология СОМ реализуется с помощью <i>СОМ-библиотек </i>(в число которых входят такие файлы операционной системы, как OLE32.DLL и OLE-Aut32.DLL). СОМ-библиотеки содержат набор стандартных интерфейсов, которые обеспечивают функциональность СОМ-объекта, а также небольшой набор функций API, отвечающих за создание и управление СОМ-объектов.</p><p align="justify" class="paragraph-source">     В Delphi реализация и поддержка технологии СОМ называется <i>каркасом Delphi ActiveX </i>(Delphi ActiveX framework, DAX). Реализация DAX описана в модуле Axctris.</p></div><span id="lnka39fd605a94641a8867a5b3cea8a5c52"> </span><div class="section"><p align="justify" class="paragraph-source">     <b>СОМ-объект</b> </p><p align="justify" class="paragraph-source">     <i>СОМ-объект </i>представляет собой двоичный код, который выполняет какую-либо функцию и имеет один или более интерфейс. </p><p align="justify" class="paragraph-source">     СОМ-объект содержит методы, которые позволяют приложению пользоваться СОМ-объектом. Эти методы доступны благодаря СОМ-интерфейсам. Клиенту достаточно знать несколько базовых интерфейсов СОМ-объекта, чтобы получить полную информацию о составе свойств и методов объекта. СОМ-объект может содержать один или несколько интерфейсов. Для программиста СОМ-объект работает так же, как и класс в Object Pascal. </p><p align="justify" class="paragraph-source">     <b>СОМ-интерфейсы</b> </p><p align="justify" class="paragraph-source">     <i>СОМ-интерфейс </i>применяется для объединения методов СОМ-объекта. Интерфейс позволяет клиенту правильно обратиться к СОМ-объекту, а объекту - правильно ответить клиенту. Названия СОМ-интерфейсов начинаются с буквы I. Клиент может не знать, какие интерфейсы имеются у СОМ-объекта. Для того чтобы получить их список, клиент использует базовый интерфейс lunknown, который есть у каждого СОМ-объекта. </p><p align="justify" class="paragraph-source">     <b>Пользователь СОМ-объекта</b> </p><p align="justify" class="paragraph-source">     <i>Пользователем СОМ-объекта </i>называется приложение или часть приложения, которое использует СОМ-объект и его интерфейсы в своих собственных целях. Как правило, СОМ-объект находится в другом приложении. </p><p align="justify" class="paragraph-source">     <b>СОМ-классы</b> </p><p align="justify" class="paragraph-source">     <i>СОМ со-классы </i>(coclass) - это классы, которые содержат один или более СОМ-интерфейс. Вы можете не обращаться к СОМ-интерфейсу непосредственно, а получать доступ к СОМ-интерфейсу через со-класс. Со-классы идентифицируются при помощи идентификаторов класса (CLSID). </p><p align="justify" class="paragraph-source">     <b>Библиотеки типов</b> </p><p align="justify" class="paragraph-source">     СОМ-объекты часто используют библиотеки типов. <i>Библиотека типов - </i>это специальный файл, который содержит информацию о СОМ-объекте. Данная информация содержит список свойств, методов, интерфейсов, структур и других элементов, которые содержатся в СОМ-объекте. Библиотека типов содержит также информацию о типах данных каждого свойства и Типах данных, возвращаемых методами СОМ-объекта. </p><p align="justify" class="paragraph-source">     Файлы библиотеки типов имеют расширение TLB. </p><p align="justify" class="paragraph-source">     <b>Технология DCOM</b> </p><p align="justify" class="paragraph-source">     <i>Технология DCOM </i>(Distributed COM) - это распределенная СОМ-технология. Она применяется для предоставления средств доступа к СОМ-объектам, расположенным на других компьютерах в сети (в том числе и сети Internet). </p><p align="justify" class="paragraph-source">     Операционные системы Windows NT 4 и Windows 98 имеют встроенную поддержку DCOM. </p><p align="justify" class="paragraph-source">     <b>Счетчики ссылок</b> </p><p align="justify" class="paragraph-source">     Каждый СОМ-объект имеет счетчик ссылок. Данный счетчик содержит число процессов, которые в текущий момент времени используют СОМ-объект. Под процессом здесь подразумевается любое приложение или DLL, которые используют СОМ-объект, т. е. пользователи СОМ-объекта. Счетчик ссылок на СОМ-объект нужен для того, чтобы высвобождать процессорное время и оперативную <i>память, занимаемую СОМ-объектом, в том </i>случае, когда он не используется. </p><p align="justify" class="paragraph-source">     После создания и обращения к СОМ-объекту счетчик ссылок увеличивается на единицу. Всякий раз, когда новое приложение подключается к СОМ-объекту - счетчик увеличивается. Когда процесс отключается от СОМ-объекта - счетчик уменьшается. При достижении счетчиком нуля память, занимаемая СОМ-объектом, высвобождается. </p><p align="justify" class="paragraph-source">     <b>OLE-</b><b>объекты</b> </p><p align="justify" class="paragraph-source">     Часть данных, использующаяся совместно несколькими приложениями, называется <i>OLE-</i><i>объектом. </i>Те приложения, которые могут содержать в себе OLE-объекты, называются <i>OLE-</i><i>контейнерами </i>(OLE container). Приложения, имеющие возможность содержать свои данные в OLE-контейнерах, называются <i>OLE-</i><i>серверами </i>(OLE server). </p><p align="justify" class="paragraph-source">     <b>Составные документы</b> </p><p align="justify" class="paragraph-source">     Документ, включающий в себя один или несколько OLE-объектов, называется <i>составным документом. </i>Приложение, которое может содержаться внутри документа, называется <i>ActiveX-</i><i>документом </i>(ActiveX document). </p><p align="justify" class="paragraph-source">     Остальные термины, присущие технологии СОМ, мы рассмотрим в следующих разделах данной книги. </p><p align="justify" class="paragraph-source">     <b>Состав СОМ-приложения</b> </p><p align="justify" class="paragraph-source">     При создании СОМ-приложения необходимо обеспечить следующее: </p><p align="justify" class="paragraph-source">     - СОМ-интерфейс; </p><p align="justify" class="paragraph-source">     - СОМ-сервер; </p><p align="justify" class="paragraph-source">     - СОМ-клиент. </p><p align="justify" class="paragraph-source">     Рассмотрим эти три составляющие СОМ-приложения более подробно. </p><p align="justify" class="paragraph-source">     <b>СОМ-интерфейс</b> </p><p align="justify" class="paragraph-source">     Клиенты СОМ связываются с объектами при помощи СОМ-интерфейсов. <i>Интерфейсы </i>-- это группы логически или семантически связанных процедур, которые обеспечивают связь между поставщиком услуги (сервером) и его клиентом. На рис. 3.1 схематично изображен стандартный СОМ-интерфейс. </p></div><span id="lnkc947f334564744cd97de77a76783c326"> </span><div class="section"><p align="justify" class="paragraph-source">     <b>Ключевыми аспектами СОМ-интерфейсов являются следующие</b>: </p><p align="justify" class="paragraph-source">     - Однажды определенные, интерфейсы не могут быть изменены. Таким образом, вы можете возложить на один интерфейс определенный набор функций. Дополнительную функциональность можно реализовать с помощью дополнительных интерфейсов. </p><p align="justify" class="paragraph-source">     -По взаимному соглашению, все имена интерфейсов начинаются с буквы <i>I, </i>например IPersist, IMalloc. </p><p align="justify" class="paragraph-source">     -Каждый интерфейс гарантированно имеет свой уникальный идентификатор, который называется <i>глобальный уникальный идентификатор </i>(Globally Unique Identifier, GUID). Уникальные идентификаторы интерфейсов называют <i>идентификаторами интерфейсов </i>(Interface Identifiers, IIDs). Данные идентификаторы обеспечивают устранение конфликтов имен различных версий приложения или разных приложений. </p><p align="justify" class="paragraph-source">     - Интерфейсы не зависят от языка программирования. Вы можете воспользоваться любым языком программирования для реализации СОМ-интерфейса. Язык программирования должен поддерживать структуру указателей, а также иметь возможность вызова функции при помощи указателя явно или неявно. </p><p align="justify" class="paragraph-source">     - Интерфейсы не являются самостоятельными объектами, они лишь обеспечивают доступ к объектам. Таким образом, клиенты не могут напрямую обращаться к данным, доступ осуществляется при помощи указателей интерфейсов. </p><p align="justify" class="paragraph-source">     - Все интерфейсы всегда являются потомками базового интерфейса Iunknown. </p></div><span id="lnk242929b364cd4d92a0960e4d54de8eed"> </span><h2 align="left" class="paragraph-headline-source">     Архитектура CORBA</h2><span id="lnk6c0bafa85d4041e4bfcefa37c425976a"> </span><div class="section"><p align="justify" class="paragraph-source">     <b>CORBA (Common Object Request Broker Architecture) -</b> обобщенная архитектура брокера объектных запросов, разработана Группой управления объектами (Object Management Group, OMG).</p><p align="justify" class="paragraph-source">     Строго говоря, если судить по ее названию, CORBA представляет собой не столько распределенную систему, сколько ее спецификацию</p><p align="justify" class="paragraph-source">     <b>CORBA </b><b>определяет механизм, обеспечивающий взаимодействие приложений в распределенной системе</b>.</p><p align="justify" class="paragraph-source">     Главными компонентами стандарта CORBA являются: </p><p align="justify" class="paragraph-source">     - <b>объектный брокер запросов (Object Request Broker); </b></p><p align="justify" class="paragraph-source">     - <b>язык определения интерфейсов (Interface Definition Language).</b> </p><p align="justify" class="paragraph-source">     В спецификацию CORBA включено также несколько дополнительных, но очень важных сервисов: </p><p align="justify" class="paragraph-source">     - <b>сервис динамического формирования запросов (DII); </b></p><p align="justify" class="paragraph-source">     - <b>сервис репозитория интерфейсов (IR); </b></p><p align="justify" class="paragraph-source">     - <b>сервис динамической обработки запросов (DSI); </b></p><p align="justify" class="paragraph-source">     - <b>сервис, обеспечивающий взаимодействие различных брокеров запросов (GIOP). </b></p><p align="justify" class="paragraph-source">     Концептуально спецификация CORBA относится к двум верхним уровням семиуровневой модели взаимодействия открытых систем. Характерные особенности проведения разработок в технологии CORBA заключаются в следующем:</p><p align="justify" class="paragraph-source">      - Язык описания интерфейсов OMG IDL позволяет определить интерфейс, независимый от языка реализации. </p><p align="justify" class="paragraph-source">     - Высокий уровень абстракции CORBA в семиуровневой модели OSI избавляет программиста от работы с низкоуровневыми сетевыми протоколами. </p><p align="justify" class="paragraph-source">     - Программисту не требуется информация о месте сервера в сетевой ИС и способе его активации. </p><p align="justify" class="paragraph-source">     - Разработка клиентской программы не зависит от серверной операционной системы и аппаратной платформы. </p><p align="justify" class="paragraph-source">     <i><b>Объектная модель CORBA </b></i></p><p align="justify" class="paragraph-source">     Объектная модель CORBA определяет взаимодействие между клиентами и серверами.</p><p align="justify" class="paragraph-source">     Клиенты - это приложения, которые запрашивают сервисы, предоставляемые серверами.</p><p align="justify" class="paragraph-source">     Объекты-серверы содержат набор сервисов, разделяемых между многими клиентами.</p><p align="justify" class="paragraph-source">     Операция указывает запрашиваемый сервис.</p><p align="justify" class="paragraph-source">     Интерфейсы объектов описывают множество операций, которые могут быть вызваны клиентами определенного объекта.</p><p align="justify" class="paragraph-source">     Реализации объектов - это приложения, исполняющие сервисы, запрашиваемые клиентами. </p><p align="justify" class="paragraph-source">     Глобальная архитектура CORBA приведена на рис. 4.</p><p align="justify" class="paragraph-source">     </p><p align="center" class="paragraph-source"><img src="../res/files/jpge79_0_.jpg" height="179px" width="594px" alt="" /><i><b> </b></i></p><p align="center" class="paragraph-source">Рисунок 4 - Архитектура CORBA</p><p align="center" class="paragraph-source">     </p></div><span id="lnk8b9fbc3f2c2b4af0973eb00e891a2c80"> </span><div class="section"><p align="justify" class="paragraph-source">     <i><b>Объектный брокер запросов (ORB) </b></i></p><p align="justify" class="paragraph-source">     Спецификация CORBA разработана для обеспечения возможности интеграции разных объектных систем. На рисунке показано место главного компонента спецификации - брокера объектных запросов.</p><p align="justify" class="paragraph-source">     <i><b>Задачей брокера</b></i> является предоставление механизма выполнения запроса объекта-клиента: поиск объекта, к которому относится данный запрос, передача необходимых данных, подготовка объекта к обработке. Брокер объектных запросов обеспечивает прозрачное взаимодействие клиентского и серверного приложений.</p><p align="justify" class="paragraph-source">     Для разработчика вызов методов удаленных объектов не отличается от обычных локальных вызовов. </p><p align="justify" class="paragraph-source">     Естественно, обработка вызовов разных видов происходит различными способами. Вызов удаленного объекта обрабатывается особыми методами, определенными в CORBA-спецификации. Они формируют по сделанному запросу низкоуровневое представление, зависящее от используемых аппаратно-программных средств.</p><p align="justify" class="paragraph-source">     Клиент может запрашивать выполнение операций с помощью ORB несколькими способами. </p><p align="justify" class="paragraph-source">     Вызов операций разделяемого объекта-сервера может быть статическим, через IDL-суррогат, или динамическим (Dynamic Invocation Interface). В случае статического вызова описания интерфейсов на IDL отображаются в программный код на языках С, С++, Smalltalk и др. При использовании динамического интерфейса запросы формируются специальным образом, без отображения интерфейса объекта в исходный код разрабатываемого приложения. </p><p align="justify" class="paragraph-source">     Информация об интерфейсах объектов может быть получена клиентом во время компиляции или во время выполнения. Интерфейсы могут быть также указаны с помощью службы репозитория интерфейсов (Interface Repository). Этот сервис представляет интерфейсы как объекты, обеспечивая доступ к ним во время работы приложения.</p><p align="justify" class="paragraph-source">     Брокер объектных запросов является промежуточным слоем, обеспечивающим объединение информационных ресурсов распределенной неоднородной системы. В этом смысле бр<b>окер запросов есть основа интеграционной архитектуры</b>, необходимой для разработки распределенной системы масштаба корпорации. </p></div><span id="lnk91210a73e7974c44afc01cb126bca437"> </span><div class="section"><p align="justify" class="paragraph-source">     <b>Достоинства CORBA</b></p></div><span id="lnk198a16302ea74bbaaf9c72e8f6f482eb"> </span><div class="section"><p align="justify" class="paragraph-source">     - Язык IDL поддерживает разнообразные программные языки, операционные системы, сети и объектные системы. IDL позволяет отделить описание интерфейса от его реализации. Таким образом, можно менять объекты, не затрагивая интерфейсы. Приложение, даже если оно написано не на объектно-ориентированным языке, с помощью IDL можно инкапсулировать в объектную структуру. </p><p align="justify" class="paragraph-source">     - CORBA - сетевая архитектура по определению, эта идея лежит в основе его развития. Объектно-ориентированные интерфейсы CORBA легко определять, создавать и использовать. </p><p align="justify" class="paragraph-source">     - Каждый сервер может содержать много объектов. Связь между отправителем и адресатом осуществляется напрямую. Объекты могут быть разных размеров. </p><p align="justify" class="paragraph-source">     - CORBA хорошо сочетается с разнообразным промежуточным ПО, включая OLE языки (например, для реализации интерфейса можно использовать VisualBatch). </p><p align="justify" class="paragraph-source">     - В рамках CORBA можно обеспечить необходимый уровень безопасности системы. </p><p align="justify" class="paragraph-source">     - Интеграция с другими распространенными технологиями: базами данных, системами обработки сообщений, системами обработки пользовательского интерфейса и другими. Специализация по отраслям промышленности открывает дополнительные возможности для приближения объектов к реальным структурам. </p><p align="justify" class="paragraph-source">     - Существует протокол IIOP, который позволяет взаимодействовать различным ORB по TCP/IP. CORBA сервисы обеспечивают ряд дополнительных возможностей: транзакции, события, query и т. д. Одновременная поддержка статических и динамических интерфейсов. Возможность включения в распределенную среду Web-клиентов и серверов, в частности, через Java-реализации CORBA. </p><p align="justify" class="paragraph-source">     - CORBA - широко используемый стандарт, со множеством реализаций, но создается и поддерживается он централизованно, OMG. </p><p align="justify" class="paragraph-source">     - Так как CORBA - только стандарт, между его реализациями естественное возникает соревнование. Тем самым повышается качество продуктов, а их совместимость заложена в стандарте. </p><p align="justify" class="paragraph-source">     - По мере развития CORBA процесс создания программных приложений все больше напоминает конструирование из готовых деталей. </p></div><span id="lnk1a1f96a7a7ac4324bf6328172e15f262"> </span><h2 align="left" class="paragraph-headline-source">     Секционирование таблиц</h2><span id="lnk7988c6d9230e45c28a33ba3e2da9875f"> </span><div class="section"><p align="justify" class="paragraph-source">     Секционирование делает большие таблицы и индексы более управляемыми, так как позволяет быстро и эффективно получать доступ к поднаборам данных и управлять ими, при этом сохраняя целостность всей коллекции. При использовании секционирования такие операции, как загрузка данных из системы OLTP в систему OLAP, занимают всего несколько секунд вместо минут и часов, затрачивавшихся на это в предыдущих версиях SQL Server. Операции обслуживания, выполняемые на поднаборах данных, также выполняются значительно эффективнее, так как нацелены только на те данные, которые действительно необходимы, а не на всю таблицу.</p><p align="justify" class="paragraph-source">     Данные секционированных таблиц и индексов подразделяются на блоки, которые могут быть распределены по нескольким файловым группам в базе данных. Данные секционируются горизонтально, поэтому группы строк сопоставляются с отдельными секциями. Таблица или индекс рассматриваются как единая логическая сущность при выполнении над данными запросов или обновлений. Все секции одного индекса или таблицы должны находиться в одной и той же базе данных.</p><p align="justify" class="paragraph-source">     Секционированные таблицы и индексы поддерживают все свойства и возможности, связываемые с разработкой и опрашиванием стандартных таблиц и индексов, включая ограничения, значения по умолчанию, значения идентификации и отметок времени, а также триггеры. Таким образом, если необходимо реализовать секционированное представление, локальное для данного сервера, вместо этого можно реализовать секционированную таблицу.</p><p align="justify" class="paragraph-source">     Решение, стоит ли применять секционирование, в основном зависит от того, насколько велика таблица или насколько она может увеличиться, как она используется и насколько эффективно отвечает на пользовательские запросы и операции обслуживания.</p><p align="justify" class="paragraph-source">     В целом, большую таблицу стоит секционировать, если выполняются следующие два условия.</p><p align="justify" class="paragraph-source">     - Таблица содержит (или может в будущем накопить) множество данных, используемых различными способами.</p><p align="justify" class="paragraph-source">     - Запросы или обновления таблицы выполняются не так, как ожидалось, либо затраты на обслуживание превышают прогнозируемые периоды технического обслуживания.</p><p align="justify" class="paragraph-source">     Например, если текущий месяц используется, в основном, для операций INSERT, UPDATE, DELETE и MERGE, в то время как предыдущие месяцы используются, в основном, для запросов SELECT, работа с этой таблицей может быть упрощена, если таблица секционирована на месяцы. Это особенно удобно, если операции регулярного обслуживания таблицы нацелены только на некоторый поднабор данных. Если таблица не секционирована, выполнение таких операций требует большого количества ресурсов и задействует весь набор данных. Когда применяется секционирование, такие операции обслуживания, как перестроение индекса и дефрагментация, можно выполнять, например только для одного месяца и данных, доступных только для записи, сохраняя доступ в сети к данным, доступным только для чтения.</p><p align="justify" class="paragraph-source">     Чтобы расширить этот пример, предположим, что нужно переместить данные, доступные только для чтения и относящиеся к одному месяцу, из этой таблицы в таблицу-хранилище данных для анализа. Благодаря секционированию поднаборы данных можно быстро разделить на отдельные участки обслуживания вне сети и добавлять их в виде секций к существующим секционированным таблицам, предполагая, что эти таблицы находятся в том же экземпляре базы данных. Такие операции обычно занимают всего несколько секунд вместо минут и часов, как это было в предыдущих выпусках.</p><p align="justify" class="paragraph-source">     Наконец, секционирование таблицы или индекса может улучшить производительность запросов, конечно, если оно правильно спроектировано с учетом типов часто выполняемых запросов и аппаратной конфигурации. </p></div><span id="lnk39b37808373842799b047a638fe8be26"> </span><h2 align="left" class="paragraph-headline-source">     Фрагментация данных</h2><span id="lnk048c516a5adf4766b07f85cf0695eab4"> </span><div class="section"><p align="justify" class="paragraph-source">     База данных физически распределяется по узлам компьютерной информационной системы при помощи фрагментации и репликации (тиражирования) данных.</p><p align="justify" class="paragraph-source">     Отношения, принадлежащие реляционной базе данных, могут быть фрагментированы на горизонтальные или вертикальные разделы.</p><p align="justify" class="paragraph-source">     Горизонтальная фрагментация реализуется при помощи операции селекции, которая направляет каждый кортеж отношения в один из разделов, руководствуясь предикатом фрагментации. Например, для отношения Employee (Сотрудник) возможна фрагментация в соответствии с территориальным распределением рабочих мест сотрудников.</p><p align="justify" class="paragraph-source">     Тогда запрос "получить информацию о сотрудниках компании" может быть сформулирован так:</p><p align="justify" class="paragraph-source">SELECT * FROM employee@donetsk,</p><p align="justify" class="paragraph-source">employee@kiev</p><p align="justify" class="paragraph-source">     На рисунке 5 изображен принцип разделения данных при горизонтальной фрагментации.</p><p align="justify" class="paragraph-source">     </p></div><span id="lnk8b7d893d44784418a6e6c900d136ca8b"> </span><div class="section"><p align="center" class="paragraph-source">     <img src="../res/files/jpg6b_0_.jpg" height="238px" width="420px" alt="" /> </p><p align="center" class="paragraph-source">Рисунок 5 - Горизонтальная фрагментация</p><p align="center" class="paragraph-source">     </p></div><span id="lnk3425749788a64ae5b425119bcf09c66a"> </span><div class="section"><p align="justify" class="paragraph-source">     На рисунке 6 приведен пример горизонтальной фрагментации.</p><p align="justify" class="paragraph-source">     </p></div><span id="lnk574ce27540b74cf1a96d70a8b8db6283"> </span><div class="section"><p align="center" class="paragraph-source"><img src="../res/files/jpge9f_0_.jpg" height="251px" width="502px" alt="" /> </p><p align="center" class="paragraph-source">Рисунок 6 - Пример горизонтальной фрагментации</p><p align="center" class="paragraph-source">     </p></div><span id="lnk5f59e90e08894a73b698e2b7c276d5ef"> </span><div class="section"><p align="justify" class="paragraph-source">     При вертикальной фрагментации отношение делится на разделы при помощи операции проекции. Например, один раздел отношения Employee может содержать поля Номер_сотрудника (emp_id), ФИО_сотрудника (emp_name), Адрес_сотрудника (emp_adress), а другой - поля Номер_сотрудника (emp_id), Оклад (salary), Руководитель (emp_chief).</p><p align="justify" class="paragraph-source">     Тогда запрос "получить информацию о заработной плате сотрудников компании" будет выглядеть следующим образом:</p><p align="justify" class="paragraph-source">SELECT employee.emp_id,</p><p align="justify" class="paragraph-source">emp_name,</p><p align="justify" class="paragraph-source">salary</p><p align="justify" class="paragraph-source">FROM employee@Kharkov,</p><p align="justify" class="paragraph-source">employee@Kiev</p><p align="justify" class="paragraph-source">ORDER BY emp_id</p><p align="justify" class="paragraph-source">     На рисунках 7 и 8 изображены сущность и пример вертикальной фрагментации. </p><p align="justify" class="paragraph-source">     </p></div><span id="lnk742bcf70b10b4350aeb16a185cd82f33"> </span><div class="section"><p align="center" class="paragraph-source"><img src="../res/files/jpgea2_0_.jpg" height="240px" width="418px" alt="" /> </p><p align="center" class="paragraph-source">Рисунок 7 - Вертикальная фрагментация</p><p align="center" class="paragraph-source">     </p></div><span id="lnkd733738c853a4d62aa068276ce534271"> </span><div class="section"><p align="center" class="paragraph-source"><img src="../res/files/jpgea7_0_.jpg" height="425px" width="617px" alt="" /> </p><p align="center" class="paragraph-source">Рисунок 8 - Пример вертикальной<b> </b>фрагментации</p><p align="center" class="paragraph-source">     </p></div><span id="lnkd1bf15592aeb4dfb969761a6d83db01d"> </span><div class="section"><p align="justify" class="paragraph-source">     За счет фрагментации данные приближаются к месту их наиболее интенсивного использования, что потенциально снижает затраты на пересылки; уменьшаются также размеры отношений, участвующих в пользовательских запросах. Однако практически добиться ускорения выполнения запросов, затрагивающих фрагментированные отношения, очень трудно. Основная проблема состоит в резком расширении пространства поиска вариантов выполнения запросов, с которым должен работать оптимизатор запросов.</p></div><span id="lnk98f5b409bc7b4475b09669c4f6edb5b0"> </span><h2 align="left" class="paragraph-headline-source">     Репликация данных</h2><span id="lnkde1b0ab94cce4dd6a5c297e44361f698"> </span><div class="section"><p align="justify" class="paragraph-source">     Второй способ распределения данных - репликация (см. рис.9). </p><p align="justify" class="paragraph-source">     <i><b>Репликация</b></i> - механизм синхронизации содержимого нескольких копий объекта. </p><p align="justify" class="paragraph-source">     Репликация - это процесс, под которым понимается копирование данных из одного источника на множество других и наоборот. </p><p align="justify" class="paragraph-source">     </p></div><span id="lnk24bf2bbcdac543f4996c511716b486be"> </span><div class="section"><p align="center" class="paragraph-source"><img src="../res/files/jpgeac_0_.jpg" height="299px" width="404px" alt="" /> </p><p align="center" class="paragraph-source">Рисунок 9 - Репликация</p><p align="center" class="paragraph-source">     </p></div><span id="lnka019e87505b644529682efcac7385a8c"> </span><div class="section"><p align="justify" class="paragraph-source">     Репликаты - это множество различных физических копий некоторого объекта базы данных (обычно таблицы), для которых поддерживается синхронизация (идентичность) с некоторой "главной" копией. </p><p align="justify" class="paragraph-source">     При репликации изменения, сделанные в одной копии объекта, могут быть распространены в другие копии. </p><p align="justify" class="paragraph-source">     Репликация может быть синхронной или асинхронной. </p></div><span id="lnk8baf1cc4344d414295d5d4d2387a77d7"> </span><div class="section"><p align="justify" class="paragraph-source">     <i><b>Синхронная репликация </b></i></p><p align="justify" class="paragraph-source">     В случае синхронной репликации, если данная реплика обновляется, все другие реплики того же фрагмента данных также должны быть обновлены в одной и той же транзакции. Логически это означает, что существует лишь одна версия данных. </p><p align="justify" class="paragraph-source">     В большинстве продуктов синхронная репликация реализуется с помощью триггерных процедур (возможно, скрытых и управляемых системой). Но синхронная репликация имеет тот недостаток, что она создаёт дополнительную нагрузку при выполнении всех транзакций, в которых обновляются какие-либо реплики (кроме того, могут возникать проблемы, связанные с доступностью данных). </p></div><span id="lnk15613c5016dc42aaaff37bc9510dcf5b"> </span><div class="section"><p align="justify" class="paragraph-source">     <i><b>Асинхронная репликация </b></i></p><p align="justify" class="paragraph-source">     В случае асинхронной репликации обновление одной реплики распространяется на другие спустя некоторое время, а не в той же транзакции. Таким образом, при асинхронной репликации вводится задержка, или время ожидания, в течение которого отдельные реплики могут быть фактически неидентичными (то есть определение реплика оказывается не совсем подходящим, поскольку мы не имеем дело с точными и своевременно созданными копиями). </p><p align="justify" class="paragraph-source">     В большинстве продуктов асинхронная репликация реализуется посредством чтения журнала транзакций или постоянной очереди тех обновлений, которые подлежат распространению. Преимущество асинхронной репликации состоит в том, что дополнительные издержки репликации не связаны с транзакциями обновлений, которые могут иметь важное значение для функционирования всего предприятия и предъявлять высокие требования к производительности. </p><p align="justify" class="paragraph-source">     К недостаткам этой схемы относится то, что данные могут оказаться несовместимыми (то есть несовместимыми с точки зрения пользователя). Иными словами, избыточность может проявляться на логическом уровне, а это, строго говоря, означает, что термин контролируемая избыточность в таком случае не применим. </p></div><span id="lnk579feecfb23f465daaa9ebd48c8e0858"> </span><div class="section"><p align="justify" class="paragraph-source">     <i><b>Модели тиражирования</b></i></p><p align="justify" class="paragraph-source">     Теоретически значения всех данных в тиражированных объектах должны автоматически и незамедлительно синхронизироваться друг с другом. (На практике это правило обычно несколько ослабляется.) В некоторых системах копии используются исключительно в режиме чтения и обновляются в соответствии с заданным расписанием. В других средах допускается модификация отдельных значений в копиях, и эти изменения распространяются в соответствии с процедурами планирования и координации. На рисунках 10, 11 показаны различные модели тиражирования.</p><p align="justify" class="paragraph-source">     При репликации фрагменты данных тиражируются с учетом спроса на доступ к ним. Это полезно, если доступ к одним и тем же данным нужен из приложений, выполняющихся на разных узлах. В таком случае, с точки зрения экономии затрат, более эффективно будет поддерживать копии данных на всех узлах, чем непрерывно пересылать данные между узлами.</p><p align="justify" class="paragraph-source">     </p></div><span id="lnka84aa7c487f0475393f871f23a422323"> </span><div class="section"><p align="center" class="paragraph-source"><img src="../res/files/jpgeb0_0_.jpg" height="203px" width="472px" alt="" /> </p><p align="center" class="paragraph-source">Рисунок 10 - Одновременное обновление (с управлением параллелизмом)</p><p align="center" class="paragraph-source">     </p></div><span id="lnkcbacbb819c60467dbcc63d9e889133ff"> </span><div class="section"><p align="center" class="paragraph-source"><img src="../res/files/jpgeb3_0_.jpg" height="276px" width="477px" alt="" /> </p><p align="center" class="paragraph-source">Рисунок 11 - Распространенные обновления</p><p align="center" class="paragraph-source">     </p></div><span id="lnka7bc4752b5b54f449863441d6e327fe6"> </span><div class="section"><p align="justify" class="paragraph-source">     Основной проблемой репликации данных является то, что обновление любого логического объекта должно распространяться на все хранимые копии этого объекта. Трудности возникают из-за того, что некоторый узел, содержащий данный объект, может быть недоступен (например, из-за краха системы или данного узла) именно в момент обновления. В таком случае очевидная стратегия немедленного распространения обновлений на все копии может оказаться неприемлемой, поскольку предполагается, что обновление (а значит и исполнение транзакции) будет провалено, если одна из копий будет недоступна в текущий момент.</p><p align="justify" class="paragraph-source">     В современных СУБД функции репликации выполняет, как правило, специальный модуль - сервер тиражирования данных, называемый репликатором (так устроены СУБД - OpenIngress и Sybase). В Informix-OnLine Dynamic Server репликатор встроен в сервер, вOracle для использования репликации необходимо приобрести дополнительную опцию Replication Option.</p><p align="justify" class="paragraph-source">     Спецификация механизмов репликации зависит от используемой СУБД. Простейший вариант - использование "моментальных снимков" (snapshot).</p></div><span id="lnk3e9e3e87b717498dabab42c5ed43187a"> </span><h2 align="justify" class="paragraph-headline-source">     Каталог распределенной системы</h2><span id="lnk33a4fcc95ba04990b76b175aff328e10"> </span><div class="section"><p align="justify" class="paragraph-source">     Важным компонентом структуры логического уровня РБД является сетевой каталог, который обеспечивает эффективное выполнение основных функций управления РБД и содержит всю информацию, необходимую для обеспечения независимости размещения, фрагментации и репликации. Существует несколько вариантов хранения системного каталога. Ниже перечислены некоторые из этих вариантов.</p><p align="justify" class="paragraph-source">     - Централизированный каталог. Весь каталог храниться в одном м месте, т.е. на центральном узле.</p><p align="justify" class="paragraph-source">     - Полностью реплицированный каталог. Весь каталог полностью хранится на каждом узле.</p><p align="justify" class="paragraph-source">     - Секционированный каталог. На каждом узле содержится его с собственный каталог для объектов, хранимых на этом узле. Общий каталог я является объединением всех разъединенных локальных каталогов.</p><p align="justify" class="paragraph-source">     - Комбинация первого и третьего вариантов. На каждом узле с содержится его собственный каталог (как в п.3), кроме того, на одном центральном узле хранится унифицированная копия всех этих локальных каталогов (как в п.1).</p><p align="justify" class="paragraph-source">     Для каждого подхода характерны определенные недостатки и проблемы. В первом подходе, очевидно, не достигается "независимость от центрального узла". Во втором утрачивается автономность функционирования, поскольку при обновлении каждого каталога это обновление придется распространять на каждый узел. В третьем выполнение не локальных операций становится весьма дорогостоящим (для поиска удаленного объекта потребуется в среднем осуществить доступ к половине имеющихся узлов). Четвертый подход более эффективен, чем третий (для поиска удаленного объекта потребуется осуществить доступ только к одному удаленному каталогу), но в нем снова не достигается "независимость от центрального узла".</p></div><span id="lnk34b4125687cc433299afbaaf17fb941c"> </span><h2 align="left" class="paragraph-headline-source">     Моментальные снимки в Oracle</h2><span id="lnkd3d82838008c41e9bb89ef49c8293aaa"> </span><div class="section"><p align="justify" class="paragraph-source">     Oracle поддерживает два типа тиражирования:</p><p align="justify" class="paragraph-source">     - базовое - копия обеспечивает доступ "только для чтения".</p><p align="justify" class="paragraph-source">     - усовершенствованное - приложения могут считывать и обновлять тиражируемые копии таблиц по всей системе (поддерживается специальными средствами СУБД - <b>Replication  Option</b>).</p><p align="justify" class="paragraph-source">     <b>Базовое тиражирование</b> осуществляется (после установления связи с удаленной БД) с помощью создания моментальных снимков (snapshot), например:</p><p align="justify" class="paragraph-source">CREATE SNAPSHOT sales.parts AS</p><p align="justify" class="paragraph-source">SELECT * FROM sales.parts@central.compworld;</p><p align="justify" class="paragraph-source">     Моментальные снимки бывают:</p><p align="justify" class="paragraph-source">     - простые - создаются по однотабличному запросу SELECT, содержащему простые условия отбора.</p><p align="justify" class="paragraph-source">     - сложные - создаются по запросам, содержащим сложные условия отбора, фразы group by, having, обращающимся к двум и более таблицам и проч.</p><p align="justify" class="paragraph-source">     С помощью моментального снимка в локальной базе данных будет создано несколько объектов, поэтому пользователь, создающий моментальный снимок, должен иметь привилегии CREATE TABLE, CREATE VIEW и CREATE INDEX.</p><p align="justify" class="paragraph-source">     <b>Синтаксис создания моментального снимка:</b></p><p align="justify" class="paragraph-source">create snapshot [<i>имя_схемы</i>.]<i>имя_снимка</i></p><p align="justify" class="paragraph-source">     [ { pctfree <i>целое</i> | pctused <i>целое</i> | initrans <i>целое</i> |</p><p align="justify" class="paragraph-source">          maxtrans <i>целое</i> | tablespace <i>имя_табличной_области</i> |</p><p align="justify" class="paragraph-source">          storage <i>размер_памяти</i> }]</p><p align="justify" class="paragraph-source">     [ cluster <i>имя_кластера</i> (<i>имя_столбца</i>[,…]) ]</p><p align="justify" class="paragraph-source">     [ using index ]</p><p align="justify" class="paragraph-source">     [ { pctfree <i>целое</i> | pctused <i>целое</i> | initrans <i>целое</i> |</p><p align="justify" class="paragraph-source">          maxtrans <i>целое</i> | tablespace <i>имя_табличной_области</i> |</p><p align="justify" class="paragraph-source">          storage <i>размер_памяти</i> }]</p><p align="justify" class="paragraph-source">     [refresh [{ fast | complete | <u>force</u> }]</p><p align="justify" class="paragraph-source">     [ start with <i>дата_1</i> ] [ next <i>дата_2</i> ]]</p><p align="justify" class="paragraph-source">     [for update]</p><p align="justify" class="paragraph-source">     as <i>запрос</i>;</p><p align="justify" class="paragraph-source">     При создании моментального снимка в локальной базе данных создается:</p><p align="justify" class="paragraph-source">     - <b>таблица</b> для хранения записей, получаемых в результате выполнения запроса моментального снимка (с именем SNAP$_имя_моментального_снимка);</p><p align="justify" class="paragraph-source">     - <b>представление </b>этой таблицы "только для чтения", называемое в соответствии с именем моментального снимка;</p><p align="justify" class="paragraph-source">     - <b>представление</b>, называемое MVIEW$_имя_моментального_снимка - для обращения к удаленной основной таблице (или таблицам). Это представление будет использоваться во время регенерации.</p><p align="justify" class="paragraph-source">     Для модификации снимка, например, с целью установки частоты автоматического изменения в 1 час можно воспользоваться командой ALTER SNAPSHOT:</p><p align="justify" class="paragraph-source">alter snapshot emp_dept_count refresh complete</p><p align="justify" class="paragraph-source">start with sysdate next sysdate + 1/24;</p><p align="justify" class="paragraph-source">     Для удаления моментальных снимков применяется команда drop snapshot:</p><p align="justify" class="paragraph-source">drop snapshot emp_dept_count;</p></div></div></td></tr></table></td></tr><tr><td id="bottomOuter"><table id="bottomInner"><tr><td class="cell1"><div> </div></td><td class="cell2"><div>© 2012 ХНУРЭ, ПИ, Широкопетлева М.С., <a href="mailto:mshirokopetleva@gmail.com">mshirokopetleva@gmail.com</a>;   ХНУРЭ, ПИ, Черепанова Ю.Ю.<br /><a href="http://lersus.de/" title="Данный курс создан с помощью авторской системы LERSUS" target="_blank">Разработано с помощью LERSUS</a></div></td></tr></table></td></tr></table></body></html>