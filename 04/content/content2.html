<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="LERSUS 3.3.0.0" /><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Корпоративные информационные системы — Теория — Транзакции</title><script language="javascript" type="text/javascript" src="../../00/styles/files/apiwrapper.js"> </script><script language="javascript" type="text/javascript" src="../../00/styles/files/sco.js"> </script><link href="../../00/styles/files/style.css" rel="stylesheet" type="text/css" /></head><body><table id="mainOuter"><tr><td id="topOuter"><table id="topInner"><tr class="row1"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4" id="shortcuts"><div><ul class="level0"><li><a href="../../00/content/authors1.html">Авторы</a></li><li>|</li><li><a href="../../00/content/contacts1.html">Контакты</a></li><li>|</li><li><a href="../../00/content/instructions1.html">Методические указания</a></li><li>|</li><li><a href="../../00/content/annotation1.html">Аннотация</a></li><li>|</li><li><a href="#" onclick="history.back(); return false;">Назад</a></li></ul></div></td></tr><tr class="row2"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4"><div id="courseTitle">Корпоративные информационные системы</div><div id="courseSubTitle">Распределенные базы данных : Транзакции</div></td></tr></table></td></tr><tr><td id="contentOuter"><table id="contentInner"><tr><td class="menuOuter"><table class="menuInner"><tr><td><ul class="level0"><li><a href="../../00/styles/courses.html">Содержание курса</a></li><li><span>Теория</span></li><ul class="level1"><li><a href="../../04/content/content1.html">Распределенное хранение данных</a></li><li><a href="../../04/content/content2.html">Транзакции</a></li><li><a href="../../04/content/content3.html">Восстановление данных. Управление параллелизмом</a></li><li><a href="../../04/content/content4.html">Обработка распределенных запросов и распределенная модель транзакций</a></li><li><a href="../../04/content/content5.html">Распределение и тиражирование данных</a></li></ul><li><span>Текущий контроль знаний</span></li><ul class="level1"><li><a href="../../04/content/multiply-choice-test1.html">Транзакции и блокировки</a></li><li><a href="../../04/content/multiply-choice-test5.html">Распределенные базы данных</a></li></ul><li><a href="../../04/styles/glossary.html">Словарь терминов</a></li><li><a href="../../04/04.pdf" target="_blank">Версия для печати</a></li></ul></td></tr></table></td><td class="content"><div id="content"><div id="topBlankStripe"> </div><span id="lnk35b499b63f4246f489bd75d9660cc4cb"> </span><h1 align="left" class="headline-source">     Транзакции</h1><span id="lnkd9a8ac7976474704bd8eb7376b252604"> </span><div class="section"><p align="justify" class="paragraph-source">     <i><b>Транзакция </b></i>- это последовательность операций над БД, рассматриваемых СУБД как единое целое. Либо транзакция успешно выполняется, и СУБД фиксирует (COMMIT) изменения БД, произведенные этой транзакцией, во внешней памяти, либо ни одно из этих изменений никак не отражается на состоянии БД. Понятие транзакции необходимо для поддержания логической целостности БД. Если вспомнить наш пример информационной системы с файлами СОТРУДНИКИ и ОТДЕЛЫ, то единственным способом не нарушить целостность БД при выполнении операции приема на работу нового сотрудника является объединение элементарных операций над файлами СОТРУДНИКИ и ОТДЕЛЫ в одну транзакцию. Таким образом, поддержание механизма транзакций является обязательным условием даже однопользовательских СУБД (если, конечно, такая система заслуживает названия СУБД). Но понятие транзакции гораздо более важно в многопользовательских СУБД. </p><p align="justify" class="paragraph-source">     Например, рассмотрим операции, производимые при переводе денег с одного банковского счета на другой. Проведение такой операции требует выполнения следующих действий:</p><p align="justify" class="paragraph-source">     а) Снять деньги с одного счета:</p><p align="justify" class="paragraph-source">UPDATE Bank SET Money=Money -1000 WHERE Chet=100;</p><p align="justify" class="paragraph-source">     б) Добавить эту сумму на другой счет:</p><p align="justify" class="paragraph-source">UPDATE Bank SET Money=Money +1000 WHERE Chet=200;</p><p align="justify" class="paragraph-source">     в) Зафиксировать операцию перевода денег в банковском журнале:</p><p align="justify" class="paragraph-source">INSERT Operation VALUES (SYSDATE, 100, 200, 1000, … );</p><p align="justify" class="paragraph-source">     Эти действия с базой данных банковских счетов должны быть выполнены либо все полностью, либо ни одно из них не должно быть выполнено. Таким образом, вышеперечисленные 3 операции необходимо рассматривать, как транзакцию.</p></div><span id="lnk11e05f59a624438aa87dce149a51665c"> </span><div class="section"><p align="justify" class="paragraph-source">     То свойство, что каждая транзакция начинается при целостном состоянии БД и оставляет это состояние целостным после своего завершения, делает очень удобным использование понятия транзакции как единицы активности пользователя по отношению к БД. При соответствующем управлении параллельно выполняющимися транзакциями со стороны СУБД каждый из пользователей может в принципе ощущать себя единственным пользователем СУБД (на самом деле, это несколько идеализированное представление, поскольку в некоторых случаях пользователи многопользовательских СУБД могут ощутить присутствие своих коллег). </p><p align="justify" class="paragraph-source">     С управлением транзакциями в многопользовательской СУБД связаны важные понятия сериализации транзакций и сериального плана выполнения смеси транзакций. Под сериализаций параллельно выполняющихся транзакций понимается такой порядок планирования их работы, при котором суммарный эффект смеси транзакций эквивалентен эффекту их некоторого последовательного выполнения. Сериальный план выполнения смеси транзакций - это такой план, который приводит к сериализации транзакций. Понятно, что если удается добиться действительно сериального выполнения смеси транзакций, то для каждого пользователя, по инициативе которого образована транзакция, присутствие других транзакций будет незаметно (если не считать некоторого замедления работы по сравнению с однопользовательским режимом). </p><p align="justify" class="paragraph-source">     Существует несколько базовых алгоритмов сериализации транзакций. В централизованных СУБД наиболее распространены алгоритмы, основанные на синхронизационных захватах объектов БД. При использовании любого алгоритма сериализации возможны ситуации конфликтов между двумя или более транзакциями по доступу к объектам БД. В этом случае для поддержания сериализации необходимо выполнить откат (ликвидировать все изменения, произведенные в БД) одной или более транзакций. Это один из случаев, когда пользователь многопользовательской СУБД может реально (и достаточно неприятно) ощутить присутствие в системе транзакций других пользователей. </p></div><span id="lnk76cd383b16c849a38ff8a9139d51668c"> </span><h2 align="left" class="paragraph-headline-source">     Свойства транзакций</h2><span id="lnkc9499626eeba4004a69b501d601a430c"> </span><div class="section"><p align="justify" class="paragraph-source">     <b>Атомарность</b> - транзакция является неделимой, она выполняется полностью или не выполняется вообще; если транзакция прерывается на середине, то происходит откат (ROLLBACK) и база данных должна остаться в том состоянии, которое она имела до начала транзакции; </p><p align="justify" class="paragraph-source">     <b>Параллельность </b>- эффект от параллельного выполнения нескольких транзакций должен быть таким же, как от их последовательного выполнения;</p><p align="justify" class="paragraph-source">     <b>Целостность </b>- транзакция переводит базу данных из одного непротиворечивого (целостного) состояния в другое;</p><p align="justify" class="paragraph-source">     <b>Долговременность </b>- после того, как транзакция завершена и зафиксирована (COMMIT), результат ее выполнения гарантированно сохраняется в базе данных.</p></div><span id="lnke7edf96fdc84404ebab2f28dbae7113f"> </span><h2 align="left" class="paragraph-headline-source">     Аномалии доступа к базе данных </h2><span id="lnk5399a4ae6e884c75a4556c63d68d6389"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Потерянные изменения - lost update</b></p></div><span id="lnk866f83ff3b1349a1a35b4b8857691c9c"> </span><div class="section"><p align="justify" class="paragraph-source">     Имеется сходная таблица Example1(см. таблица2).</p></div><span id="lnkac8aa1dc1c3843099ce5d120146ed065"> </span><div align="center"><div class="inline-table-container"><p align="left" class="unit-title">Таблица2 - Example1</p><table class="inline-table"><col width="129" /><col width="142" /><tbody><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">ID Integer</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Dat Integer</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">1</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">100</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">2</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">110</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">3</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">120</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">4</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">130</p></td></tr></tbody></table></div></div><span id="lnk6b9d77a3ab7448e491dab22b7923819e"> </span><div class="section"><p align="justify" class="paragraph-source">     Выполняются две транзакции, которые меодифицируют одну и ту же запись. В таблице Тable2  (таблица 3 )приведен порядок выполнения команд этими транзакциями.</p></div><span id="lnk393e5a76a86e48fa940a765fba88513c"> </span><div align="center"><div class="inline-table-container"><p align="left" class="unit-title">Таблица 3 - Тable2</p><table class="inline-table"><col width="188" /><col width="70" /><col width="188" /><tbody><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">Транзакция Т1</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Шаг</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Транзакция Т1</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">Update Example Set dat=dat+1 Where Id=1;</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">1</p></td><td style="background-color:#ffffff"> </td></tr><tr><td style="background-color:#ffffff"> </td><td style="background-color:#ffffff"><p align="left" class="inline-table">2</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Update Example Set dat=dat+1 Where Id=1;</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">Commit;</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">3</p></td><td style="background-color:#ffffff"> </td></tr><tr><td style="background-color:#ffffff"> </td><td style="background-color:#ffffff"><p align="left" class="inline-table">4</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Commit;</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">Select * from Example</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">5</p></td><td style="background-color:#ffffff"> </td></tr></tbody></table></div></div><span id="lnkd7b96f4b86c44ae2b232239b29f93cea"> </span><div class="section"><p align="justify" class="paragraph-source">     В таблице Example2  (таблица 4 )продемонстрированы результаты работы транзакций (пошагово). Как видно, значение, записанное транзакцией Т2, «затрет» значение, записанное транзакцией Т1 (дважды последовательно происходило увеличение значение первой строки, а в результате зафиксировалось только увеличение на 1).</p></div><span id="lnk4705ff9322654d7a81ddbe6d680e550e"> </span><div align="center"><div class="inline-table-container"><p align="left" class="unit-title">Таблица 4 - Example2</p><table class="inline-table"><col width="101" /><col width="100" /><tbody><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">ID Integer</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Dat Integer</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">1</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">101</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">2</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">110</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">3</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">120</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">4</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">130</p></td></tr></tbody></table></div></div><span id="lnk070aef7d786745eba64f3ec8300ce7e7"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Аномалии доступа к базе данных (грязное чтение - dirty read)</b></p></div><span id="lnkcbb3b73df3f74a59951b043152da0a27"> </span><div class="section"><p align="justify" class="paragraph-source">     Имеется сходная таблица Example1 (таблица 5).</p></div><span id="lnkba764e5ebdca4ba8bb5ee7edc5eb52fe"> </span><div align="center"><div class="inline-table-container"><p align="left" class="unit-title">Таблица 5 - Example1</p><table class="inline-table"><col width="129" /><col width="142" /><tbody><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">ID Integer</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Dat Integer</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">1</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">100</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">2</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">110</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">3</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">120</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">4</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">130</p></td></tr></tbody></table></div></div><span id="lnkec5f7457b43740ed95b738b1860b6d4b"> </span><div class="section"><p align="justify" class="paragraph-source">     Выполняются две транзакции, которые модифицируют одну и ту же запись. В таблице Тable2  (таблица 6 )приведен порядок выполнения команд этими транзакциями.</p></div><span id="lnk57b53bacab3849dfabed7f2cebc2d7c8"> </span><div align="center"><div class="inline-table-container"><p align="left" class="unit-title">Таблица 6 - Тable2</p><table class="inline-table"><col width="188" /><col width="70" /><col width="188" /><tbody><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">Транзакция Т1</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Шаг</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Транзакция Т1</p></td></tr><tr><td style="background-color:#ffffff"> </td><td style="background-color:#ffffff"><p align="left" class="inline-table">1</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Update Example Set dat=101 Where Id=1;</p></td></tr><tr><td style="background-color:#ffffff"><p align="justify" class="inline-table">Update Example Set =(Select dat From example Where Id=1)</p><p align="left" class="inline-table">Where Id=2;</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">2</p></td><td style="background-color:#ffffff"> </td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">Select * from Example;</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">3</p></td><td style="background-color:#ffffff"> </td></tr><tr><td style="background-color:#ffffff"> </td><td style="background-color:#ffffff"><p align="left" class="inline-table">4</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Rollback;</p></td></tr><tr><td style="background-color:#ffffff"> </td><td style="background-color:#ffffff"><p align="left" class="inline-table">5</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Select * from Example;</p></td></tr></tbody></table></div></div><span id="lnkcb95d4f47a814d969ae6e4b900805f08"> </span><div class="section"><p align="justify" class="paragraph-source">     В таблице Example2 (таблица 7) продемонстрированы результаты работы на 3 шаге (когда произошло изменение в соответствии с неверной модификацией данных на шаге 1).</p></div><span id="lnk778da11f6c7c46e487c8abe3c9ae5ddb"> </span><div align="center"><div class="inline-table-container"><p align="left" class="unit-title">Таблица 7 - Example2</p><table class="inline-table"><col width="101" /><col width="100" /><tbody><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">ID Integer</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Dat Integer</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">1</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">101</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">2</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">101</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">3</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">120</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">4</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">130</p></td></tr></tbody></table></div></div><span id="lnk61bc391a476d4a17935368a099070fc3"> </span><div class="section"><p align="justify" class="paragraph-source">     В результате, после выполнения всех шагов будет получена следующая таблица 8. При этом, считывание информации на разных шагах дало различные результаты (что недопустимо).</p></div><span id="lnk2666ba58ba0147218e1033a6de6f68d2"> </span><div align="center"><div class="inline-table-container"><p align="left" class="unit-title">Таблица 8 - Example2</p><table class="inline-table"><col width="101" /><col width="100" /><tbody><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">ID Integer</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Dat Integer</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">1</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">100</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">2</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">101</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">3</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">120</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">4</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">130</p></td></tr></tbody></table></div></div><span id="lnk5a9e3cb3fddf4113b4c6d64291278aef"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Аномалии доступа к базе данных (неповторяющееся чтение - non-repeatable read)</b></p></div><span id="lnk353a26d07603462e86e62f5741773276"> </span><div class="section"><p align="justify" class="paragraph-source">     Имеется сходная таблица Example1 (таблица 9).</p></div><span id="lnk3e16378f3f614fafb5f673f373cf693c"> </span><div align="center"><div class="inline-table-container"><p align="left" class="unit-title">Таблица 9 - Example1</p><table class="inline-table"><col width="129" /><col width="142" /><tbody><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">ID Integer</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Dat Integer</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">1</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">100</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">2</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">110</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">3</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">120</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">4</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">130</p></td></tr></tbody></table></div></div><span id="lnk6f94d60f2cbf4ce1862aaccf9c2800c0"> </span><div class="section"><p align="justify" class="paragraph-source">     Независимо выполняются две транзакции, одна из которых считывает данные, а другая модифицирует. В таблице Тable2 (таблица 10 приведен порядок выполнения команд этими транзакциями.</p></div><span id="lnk7e3c92d33f324d55bc5c9f75fa824259"> </span><div align="center"><div class="inline-table-container"><p align="left" class="unit-title">Таблица 10 - Тable2</p><table class="inline-table"><col width="188" /><col width="74" /><col width="184" /><tbody><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">Транзакция Т1</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Шаг</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Транзакция Т1</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">Select * from Example Where Id=1;</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">1</p></td><td style="background-color:#ffffff"> </td></tr><tr><td style="background-color:#ffffff"> </td><td style="background-color:#ffffff"><p align="left" class="inline-table">2</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Update Example Set dat=101 Where Id=1;</p></td></tr><tr><td style="background-color:#ffffff"> </td><td style="background-color:#ffffff"><p align="left" class="inline-table">3</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Commit;</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">Select * from Example Where Id=1;</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">4</p></td><td style="background-color:#ffffff"> </td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">Commit;</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">5</p></td><td style="background-color:#ffffff"> </td></tr></tbody></table></div></div><span id="lnk2937bad4e2ec4df380b7153248fc7e3f"> </span><div class="section"><p align="justify" class="paragraph-source">     В таблице Example2  (таблица 11) продемонстрированы результаты работы на шаге 1 (считывание информации 1 транзакцией).</p></div><span id="lnk78cf3e46596f4228a79dc8ac3958befa"> </span><div align="center"><div class="inline-table-container"><p align="left" class="unit-title">Таблица 11 - Еxample2</p><table class="inline-table"><col width="101" /><col width="100" /><tbody><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">ID Integer</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Dat Integer</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">1</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">100</p></td></tr></tbody></table></div></div><span id="lnk863e867a034f49cbbcded9e5aea7141d"> </span><div class="section"><p align="justify" class="paragraph-source">     В результате выполнения запроса на 4 шаге получим таблицу 12. Как видно, чтение одних и тех же данных в транзакции Т1 дают разные результаты.</p></div><span id="lnk69d54a9abd674e238cbb1f3cc130a54a"> </span><div align="center"><div class="inline-table-container"><p align="left" class="unit-title">Таблица 12 -  Example2</p><table class="inline-table"><col width="101" /><col width="100" /><tbody><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">ID Integer</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Dat Integer</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">1</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">101</p></td></tr></tbody></table><p align="left" class="unit-comment">     </p></div></div><span id="lnkde05a3516e57410088c80baeb3adb8cc"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Аномалии доступа к базе данных     (фантом - phantom insert)</b></p></div><span id="lnk38eb12aab40949058127426abc518bd5"> </span><div class="section"><p align="justify" class="paragraph-source">     Имеется сходная таблица Example1(таблица 13).</p></div><span id="lnkc34b0ed7f41645d5b6a2df6314c72544"> </span><div align="center"><div class="inline-table-container"><p align="left" class="unit-title">Таблица 13 - Example1</p><table class="inline-table"><col width="129" /><col width="142" /><tbody><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">ID Integer</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Dat Integer</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">1</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">100</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">2</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">110</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">3</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">120</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">4</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">130</p></td></tr></tbody></table></div></div><span id="lnk56f1d7b1f962439c9b52a483582a4327"> </span><div class="section"><p align="justify" class="paragraph-source">     Независимо выполняются две транзакции, одна из которых считывает данные, а другая добавляет. В таблице Тable2 (таблица 14) приведен порядок выполнения команд этими транзакциями.</p></div><span id="lnk5b98cdbac6104dcbb26be39930aac48e"> </span><div align="center"><div class="inline-table-container"><p align="left" class="unit-title">Таблица 14 - Тable2</p><table class="inline-table"><col width="188" /><col width="74" /><col width="184" /><tbody><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">Транзакция Т1</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Шаг</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Транзакция Т1</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">Select * from Example Where Dat&gt;110;</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">1</p></td><td style="background-color:#ffffff"> </td></tr><tr><td style="background-color:#ffffff"> </td><td style="background-color:#ffffff"><p align="left" class="inline-table">2</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Insert Into example Values    (5, 140);</p></td></tr><tr><td style="background-color:#ffffff"> </td><td style="background-color:#ffffff"><p align="left" class="inline-table">3</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Commit;</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">Select * from Example Where Dat&gt;110;</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">4</p></td><td style="background-color:#ffffff"> </td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">Commit;</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">5</p></td><td style="background-color:#ffffff"> </td></tr></tbody></table><p align="left" class="unit-comment">     </p></div></div><span id="lnkf9bec6c7e486458a95b056aa36cd9c80"> </span><div class="section"><p align="justify" class="paragraph-source">     В таблице Example2 (таблица 15) продемонстрированы результаты работы на шаге 1 (считывание инфорамции 1 транзакцией).</p></div><span id="lnk9e0a66a1a14d4557acb2cea99049b7e8"> </span><div align="center"><div class="inline-table-container"><p align="left" class="unit-title">Таблица 15 - Example2</p><table class="inline-table"><col width="101" /><col width="100" /><tbody><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">ID Integer</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Dat Integer</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">3</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">120</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">4</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">130</p></td></tr></tbody></table></div></div><span id="lnk9bad5539be444a26985baed73c96ae36"> </span><div class="section"><p align="justify" class="paragraph-source">     В результате выполнения запроса на 4 шаге получим таблицу 16. Как видно, одинаковые запросы в транзакции Т1 выбирают разные множества строк.</p></div><span id="lnke1aef9c63799414ebfd3b8155e880353"> </span><div align="center"><div class="inline-table-container"><p align="left" class="unit-title">Таблица 16 - Example2</p><table class="inline-table"><col width="101" /><col width="100" /><tbody><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">ID Integer</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Dat Integer</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">3</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">120</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">4</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">130</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">5</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">140</p></td></tr></tbody></table></div></div><span id="lnkd3ef1e2828e84790b87ac79e7a43a006"> </span><h2 align="left" class="paragraph-headline-source">     Управление транзакциями</h2><span id="lnk021da81d90394455a67fc91607f3d7a6"> </span><div class="section"><p align="justify" class="paragraph-source">     Первое предложение SQL в вашей программе начинает транзакцию. Когда одна транзакция заканчивается, очередное предложение SQL автоматически начинает следующую транзакцию. Таким образом, каждое предложение SQL является частью некоторой транзакции. Предложения COMMIT и ROLLBACK гарантируют, что все изменения в базе данных, осуществленные операциями SQL, либо становятся постоянными, либо отменяются единовременно. Все предложения SQL, выполненные после последней операции COMMIT или ROLLBACK, составляют текущую транзакцию. Предложение SAVEPOINT отмечает и именует текущую точку в обработке транзакции. </p><p align="justify" class="paragraph-source">     Распределенные транзакции включают, по меньшей мере, одно предложение SQL, изменяющее данные в нескольких узлах распределенной базы данных. Если обновление затрагивает лишь один узел, транзакция удаленная, но не распределенная. Если часть распределенной транзакции сбивается, вы должны выполнить откат всей транзакции или откат к точке сохранения. ORACLE в такой ситуации выдает сообщение об ошибке. Поэтому вы должны включать проверки на ошибки в каждое приложение, выполняющее распределенные транзакции. </p></div><span id="lnka24d0f4b5fb84d13a1ee1844b4821a39"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Использование COMMIT </b></p></div><span id="lnk0bac35ad0103425297394c89dacd1dac"> </span><div class="section"><p align="justify" class="paragraph-source">     Предложение <i><b>COMMIT </b></i>завершает текущую транзакцию и делает постоянными все изменения, осуществленные в течение этой транзакции. До этого момента другие пользователи не могут видеть измененных данных; они видят данные в том состоянии, каким оно было к моменту начала транзакции. Рассмотрим простую транзакцию, которая осуществляет перевод денег с одного банковского счета на другой. Эта транзакция требует двух операций обновления (UPDATE), потому что она должна дебитовать один счет и кредитовать другой. После кредитования второго счета вы выдаете команду COMMIT, делая изменения постоянными. Лишь после этого новое состояние счетов становится видимым другим пользователям. </p></div><span id="lnk131afbaaf63b4336b28ac06e99410576"> </span><table class="note"><tr><td><p align="left" class="note-source">     Пример:</p><p align="left" class="note-source">BEGIN <br />... <br />UPDATE accts SET bal = my_bal - debit WHERE acctno = 7715; <br />... <br />UPDATE accts SET bal = my_bal + credit WHERE acctno = 7720; <br />COMMIT WORK; <br />END; </p></td><th><img src="../../00/styles/files/note_comment.png" title="" alt="" /></th></tr></table><span id="lnk1d47f25f3a884443b10a644aeba2562e"> </span><div class="section"><p align="justify" class="paragraph-source">     Необязательное ключевое слово WORK не имеет никакого эффекта, помимо улучшения читабельности. Предложение COMMIT освобождает все блокировки таблиц и строк. Оно также стирает все точки сохранения (обсуждаемые ниже), отмеченные после последней операции COMMIT или ROLLBACK. Когда вы выдаете COMMIT, постоянными становятся изменения во всех базах данных, затронутых распределенной транзакцией. Однако, если во время выполнения COMMIT произойдет сбой сети или машины, состояние распределенной транзакции может оказаться неизвестным или СОМНИТЕЛЬНЫМ (in doubt). </p></div><span id="lnk5759b7a8d30f4c10bbbd5ae6dc94a7db"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Использование ROLLBACK </b></p></div><span id="lnk31d8827894a94d58bafa16cb6a29abfd"> </span><div class="section"><p align="justify" class="paragraph-source">     Предложение <i><b>ROLLBACK </b></i>противоположно COMMIT. Оно заканчивает текущую транзакцию и отменяет все изменения, осуществленные за время этой транзакции. </p><p align="justify" class="paragraph-source">     Предложение ROLLBACK полезно по двум причинам. Во-первых, если вы сделали ошибку, например, удалили не ту строку из базы данных, вы можете использовать ROLLBACK для восстановления первоначальных данных. Вариант <i><b>ROLLBACK TO </b></i>позволяет вам отменить изменения до промежуточной точки в текущей транзакции, так что вы не обязаны стирать все ваши изменения. Во-вторых, предложение ROLLBACK полезно, когда вы начали транзакцию, которую не в состоянии завершить, например, при возникновении исключения или ошибки в предложении SQL. В таких случаях ROLLBACK позволяет вам вернуться к стартовой точке, так что вы можете предпринять корректирующие действия и попытаться снова повторить транзакцию. </p><p align="justify" class="paragraph-source">     Рассмотрим следующий пример, в котором вы вставляете информацию о сотруднике в три различных таблицы базы данных. Все три таблицы имеют столбец, содержащий номер сотрудника и ограничиваемый уникальным индексом. Если предложение INSERT пытается вставить повторяющийся номер сотрудника, возбуждается предопределенное исключение DUP_VAL_ON_INDEX. В этом случае вам необходимо отменить все изменения. Поэтому вы выдаете ROLLBACK в обработчике исключений (исключения будут рассмотрены в теме "Обработка исключительных ситуаций"). </p></div><span id="lnk29c11a705dd340e6a8272970a0f6bd9d"> </span><table class="note"><tr><td><p align="justify" class="note-source">     Пример:</p><p align="left" class="note-source">DECLARE <br />emp_id INTEGER; <br />... <br />BEGIN <br />SELECT empno, ... INTO emp_id, ... FROM new_emp WHERE ... <br />... <br />INSERT INTO tab1 VALUES (emp_id, ...); <br />INSERT INTO tab1 VALUES (emp_id, ...); <br />INSERT INTO tab1 VALUES (emp_id, ...); <br />... EXCEPTION <br />WHEN DUP_VAL_ON_INDEX THEN <br />ROLLBACK ; <br />... <br />END ; </p></td><th><img src="../../00/styles/files/note_comment.png" title="" alt="" /></th></tr></table><span id="lnk04ba827280ee41f8b016ec25c02eb29a"> </span><div class="section"><p align="justify" class="paragraph-source">     Когда вы выдаете ROLLBACK, отменяются изменения во всех базах данных, затронутых распределенной транзакцией. </p></div><span id="lnk9853b2f3b7b747a39ddfe7b2da89b545"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Откаты на уровне предложений </b></p></div><span id="lnk91327146c9354eb4bc3b53d713ac5048"> </span><div class="section"><p align="justify" class="paragraph-source">     Прежде чем исполнять предложение SQL, ORACLE выдает неявную точку сохранения. Затем, если это предложение сбивается, ORACLE автоматически выполняет его откат. Например, если предложение INSERT пытается вставить повторяющееся значение в уникальный индекс, оно откатывается. При этом теряется лишь работа, начатая сбившимся предложением SQL; вся работа, проделанная в текущей транзакции до этого момента, не затрагивается. ORACLE может также предпринимать откат одиночных предложений SQL с целью предотвратить мертвые захваты (взаимоблокировки). В таких случаях ORACLE сигнализирует об ошибке одной из транзакций и выполняет откат текущего предложения SQL в этой транзакции. Прежде чем исполнять предложение SQL, ORACLE должен выполнить его РАЗБОР (parse), т.е. исследовать его, чтобы убедиться, что оно синтаксически корректно и ссылается на действительные объекты базы данных. Ошибки, обнаруженные во время разбора предложения (в отличие ошибок во время выполнения) не приводят к откату. </p></div><span id="lnk0ec349f23c8d47c7b77a5138a8ac74c7"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Использование SAVEPOINT </b></p></div><span id="lnk17435071bc484fcea358791d964c2c49"> </span><div class="section"><p align="justify" class="paragraph-source">     <i><b>SAVEPOINT </b></i>отмечает и именует текущую точку (точку сохранения) в процессе транзакции. Такая точка, используемая в предложении ROLLBACK TO, позволяет отменить часть транзакции. В следующем примере вы отмечаете точку сохранения перед тем, как выполнять вставку строки. Если предложение INSERT попытается вставить повторяющееся значение в столбец ware _ id , возникнет предопределенное исключение DUP_VAL_ON_INDEX. В этом случае вы откатитесь к точке сохранения, отменив лишь вставку. </p></div><span id="lnkcad8d21ceaa943a2a755f8662c642ee0"> </span><table class="note"><tr><td><p align="justify" class="note-source">     Пример:</p><p align="left" class="note-source">DECLARE <br />ware_id1 warehouses.ware_id%TYPE; </p><p align="left" class="note-source">BEGIN <br />... <br />UPDATE warehouses SET ... WHERE ware_id = ware_id1; <br />DELETE FROM warehouses WHERE ... <br />... <br />SAVEPOINT do_ins; <br />INSERT INTO warehouses VALUES (ware_id1, ...); EXCEPTION <br />WHEN DUP_VAL_ON_INDEX THEN <br />ROLLBACK TO do_ins; <br />END ; </p></td><th><img src="../../00/styles/files/note_comment.png" title="" alt="" /></th></tr></table><span id="lnkf520cf655647412abf4ba710b5390be7"> </span><div class="section"><p align="justify" class="paragraph-source">     При выполнении ROLLBACK TO все точки сохранения, отмеченные после указанной, стираются, а все изменения, сделанные после этой точки, отменяются. Однако сама точка сохранения, к которой вы возвращаетесь, не удаляется. Например, если вы последовательно отметите точки сохранения A, B C и D, а затем выполните ROLLBACK TO к точке B, то будут стерты лишь C и D. ROLLBACK без аргументов, как и COMMIT, стирает все точки сохранения. Если вы отмечаете точку сохранения в рекурсивной подпрограмме, то на каждом уровне рекурсивного спуска предложение SAVEPOINT будет создавать новые экземпляры точек сохранения. Однако ROLLBACK TO вернет вас лишь к самой последней из точек сохранения с данным именем. Имена точек сохранения - это необъявляемые идентификаторы. Их можно повторно использовать внутри транзакции. По умолчанию число активных точек сохранения на сессию не может быть больше 5. АКТИВНАЯ ТОЧКА СОХРАНЕНИЯ - это точка, отмеченная после последней операции COMMIT или ROLLBACK. Вы или ваш АБД можете поднять этот лимит (вплоть до 255), увеличив значение параметра инициализации ORACLE с именем SAVEPOINTS. </p></div><span id="lnk077d3f5590954e599fafe9b4620a8e3a"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Неявные точки сохранения </b></p></div><span id="lnk0c21e794109f4ba18ec8b91bc3cfdc70"> </span><div class="section"><p align="justify" class="paragraph-source">     Перед выполнением каждого предложения INSERT, UPDATE и DELETE ORACLE создает неявную точку сохранения (недоступную вам). Если предложение сбивается, то выполняется откат к этой неявной точке. Обычно отменяется лишь сбившееся предложение SQL, а не вся транзакция. Однако, если это предложение возбудило необрабатываемое исключение, то хост-окружение определяет, что следует отменить. Если хранимая подпрограмма сбилась в результате необрабатываемого исключения, то ORACLE выполняет неявный откат всех изменений, сделанных этой подпрограммой. Однако, если подпрограмма выдала COMMIT до возникновения необрабатываемого исключения, то отменяется лишь неподтвержденная часть работы. </p></div><span id="lnk4bce9a5a156e46529d7c31d2dc86a806"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Завершение транзакций </b></p></div><span id="lnkef4396571a3e49bfb92fd30162e65d73"> </span><div class="section"><p align="justify" class="paragraph-source">     Хорошей практикой программирования является явное подтверждение или явный откат каждой транзакции. Выдаете ли вы COMMIT и ROLLBACK в вашей программе PL/SQL или в хост-окружении - зависит от логического потока вашего приложения. Если вы пренебрегаете явными операциями COMMIT или ROLLBACK, то окончательное состояние транзакции определяет хост-окружение. Например, в среде SQL*Plus, если ваш блок PL/SQL не содержит предложения COMMIT или ROLLBACK, окончательное состояние вашей транзакции зависит от того, что вы делаете после выполнения этого блока. Если вы выполняете предложение определения данных, предложение управления данными или предложение COMMIT, либо если вы выдаете команду EXIT, DISCONNECT, то ORACLE неявно подтверждает вашу транзакцию. Если вы выдаете предложение ROLLBACK или аварийно снимаете сессию SQL*Plus, то ORACLE выполняет откат транзакции.</p></div><span id="lnk0e28ae20717048fd9d1454c509e8712a"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Использование SET TRANSACTION </b></p></div><span id="lnk82edfdbb8c054bfda43e64829550141d"> </span><div class="section"><p align="justify" class="paragraph-source">     Умалчиваемым режимом для всех транзакций является согласованность данных по чтению НА УРОВНЕ ПРЕДЛОЖЕНИЯ. Это гарантирует, что запрос видит лишь то состояние данных, которое было подтверждено перед началом его выполнения, плюс все изменения, которые внесены предыдущими предложениями в текущей транзакции. Если во время запроса другие пользователи вносят изменения в эти же таблицы базы данных, то эти изменения будут видны лишь последующим, но не текущему, запросу. Однако вы можете, выдав предложение SET TRANSACTION, установить режим согласованности данных по чтению НА УРОВНЕ ТРАНЗАКЦИИ. Это гарантирует, что запрос видит лишь то состояние данных, которое было подтверждено перед началом всей транзакции; однако при этом транзакция не должна вносить изменений в базу данных. Предложение SET TRANSACTION READ ONLY не принимает дополнительных параметров и имеет вид: SET TRANSACTION READ ONLY; Предложение SET TRANSACTION должно быть первым предложением SQL в транзакции и может появиться лишь один раз на транзакцию. Как уже сказано, в таком режиме транзакции все запросы, выдаваемые в ней, видят то состояние данных, которое было подтверждено перед началом всей транзакции. Режим READ ONLY не влияет на других пользователей или другие транзакции. В транзакции READ ONLY допускаются лишь предложения SELECT, COMMIT и ROLLBACK. Другие предложения, например, INSERT или DELETE, приводят к возбуждению исключения. В течение транзакции READ ONLY все ее запросы обращаются к одному и тому же снимку базы данных, что обеспечивает многотабличное, многозапросное, согласованное по чтению представление данных для транзакции. Другие пользователи могут продолжать опрашивать или обновлять данные в обычном режиме. Транзакция READ ONLY завершается выдачей COMMIT или ROLLBACK. В следующем примере вы, как управляющий складом, используете транзакцию READ ONLY, чтобы собрать цифры по продажам за день, прошедшую неделю и прошедший месяц. На эти цифры не могут повлиять другие пользователи, обновляющие базу данных во время транзакции. </p></div><span id="lnkc967e6e6af9d455da43b5a3b7f8df1b7"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Синтаксис операторов SQL, определяющих уровни изоляции</b></p></div><span id="lnk47fc0cf47d844612a97c8fc3c5b11607"> </span><div class="section"><p align="justify" class="paragraph-source">     Уровень изоляции транзакции задается следующим оператором:</p><p align="justify" class="paragraph-source">SET TRANSACTION {ISOLATION LEVEL<br />{READ UNCOMMITTED<br />| READ COMMITTED<br />| REPEATABLE READ<br />| SERIALIZABLE}<br />| {READ ONLY | READ WRITE}}.,..</p><p align="justify" class="paragraph-source">     Этот оператор определяет режим выполнения следующей транзакции, т.е. этот оператор не влияет на изменение режима той транзакции, в которой он подается. Обычно, выполнение оператора SET TRANSACTION выделяется как отдельная транзакция:</p><p align="left" class="paragraph-source">… (предыдущая транзакция выполняется со своим уровнем изоляции)</p><p align="left" class="paragraph-source">COMMIT;<br />SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;<br />COMMIT;<br /></p><p align="justify" class="paragraph-source">… (следующая транзакция выполняется с уровнем изоляции REPEATABLE READ)</p><p align="justify" class="paragraph-source">     Если задано предложение ISOLATION LEVEL, то за ним должно следовать один из параметров, определяющих уровень изоляции. </p><p align="justify" class="paragraph-source">     Кроме того, можно задать признаки READ ONLY или READ WRITE. Если указан признак READ ONLY, то предполагается, что транзакция будет только читать данные. При попытке записи для такой транзакции будет сгенерирована ошибка. Признак READ ONLY введен для того, чтобы дать производителям СУБД возможность уменьшать количество блокировок путем использования других методов сериализации (например, метод выделения версий). </p></div><span id="lnkb4aa66b8110f47e880f65ce99368fd83"> </span><div class="section"><p align="justify" class="paragraph-source">     Оператор SET TRANSACTION должен удовлетворять следующим условиям:</p><p align="justify" class="paragraph-source">     - Если предложение ISOLATION LEVEL отсутствует, то по умолчанию принимается уровень SERIALIZABLE. </p><p align="justify" class="paragraph-source">     - Если задан признак READ WRITE, то параметр ISOLATION LEVEL не может принимать значение READ UNCOMMITTED. </p><p align="justify" class="paragraph-source">     - Если параметр ISOLATION LEVEL определен как READ UNCOMMITTED, то транзакция становится по умолчанию READ ONLY. В противном случае по умолчанию транзакция считается как READ WRITE. </p></div><span id="lnk77e36fb9371e413baf5d4c7a6f8d0305"> </span><div class="section"><p align="justify" class="paragraph-source">     <b>Переопределение умалчиваемой блокировки </b></p></div><span id="lnkfb18100be29240e5b07f55630a7f8e78"> </span><div class="section"><p align="justify" class="paragraph-source">     По умолчанию ORACLE автоматически блокирует для вас структуры данных. Однако вы можете запросить специфические блокировки по строкам или таблицам, если вам почему-либо выгодно изменить умалчиваемый режим блокировки. Явная блокировка позволяет вам разрешать или запрещать совместный доступ к таблице на время транзакции. </p></div><span id="lnk1a3028dfdaa3407daa55f03d4451f701"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Использование FOR UPDATE </b></p></div><span id="lnk54a3332c981847699ba114969a8ff038"> </span><div class="section"><p align="justify" class="paragraph-source">     При объявлении курсора (работу с курсорами см. ниже), к которому будет обращаться фраза <i><b>WHERE CURRENT OF</b></i> предложения UPDATE или DELETE, вы должны использовать фразу FOR UPDATE, чтобы затребовать для этого курсора монопольные блокировки строк. Фраза FOR UPDATE, когда она присутствует, должна появляться в конце объявления курсора, как показывает следующий пример: </p><p align="justify" class="paragraph-source"></p><p align="justify" class="paragraph-source">DECLARE </p><p align="justify" class="paragraph-source">CURSOR c1 IS SELECT volume FROM goods WHERE goods_id = 5 FOR UPDATE; </p><p align="justify" class="paragraph-source"></p><p align="justify" class="paragraph-source">     Фраза <i><b>FOR UPDATE</b></i> указывает, что строки, выбираемые запросом, будут обновляться или удаляться, и блокирует все строки в активном множестве курсора. Это полезно, когда вы хотите, чтобы обновление базировалось на существующих значениях строк. В этом случае вам нужна гарантия, что строка не будет изменена другим пользователем, прежде чем вы обновите ее. Все строки в активном множестве блокируются в момент открытия курсора, и разблокируются при выполнении COMMIT. Поэтому после COMMIT вы не можете извлекать строк из курсора, объявленного FOR UPDATE. При запросах по нескольким таблицам вы можете использовать фразу FOR UPDATE OF, чтобы ограничить блокировку строк конкретными таблицами. Строки будут блокироваться лишь в тех таблицах, которые содержат столбец, указанный в фразе FOR UPDATE OF. </p><p align="justify" class="paragraph-source">     Например, следующий запрос блокирует строки в таблице storages , но не в таблице warehouses : </p><p align="left" class="paragraph-source">DECLARE <br />CURSOR stor_goods IS <br />SELECT storages.quantity FROM storages WHERE <br />Storages.ware_id= warehouses.ware_id AND Address='KHARKOV' <br />FOR UPDATE OF quantity; </p><p align="justify" class="paragraph-source">     Чтобы обратиться к последней строке, извлеченной курсором, вы используете фразу WHERE CURRENT OF предложения UPDATE или DELETE , как показывает следующий пример: </p><p align="justify" class="paragraph-source">UPDATE storages SET quantity = 0 WHERE CURRENT OF stor_goods; </p></div><span id="lnkbe307d4077c7471489231adb073dd62e"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Использование LOCK TABLE </b></p></div><span id="lnkc9ce5789d56b4b18816635245daa1370"> </span><div class="section"><p align="justify" class="paragraph-source">     Предложение <i><b>LOCK TABLE</b></i> позволяет вам заблокировать одну или несколько таблиц в указанном режиме, так что вы можете регулировать одновременный доступ к таблицам, поддерживая их целостность. </p><p align="justify" class="paragraph-source">     Например, предложение, приведенное ниже, блокирует таблицу goods в режиме row share. Такой режим разрешает одновременный доступ к таблице, но запрещает другим пользователям блокировать всю таблицу для монопольного использования. Блокировка таблицы освобождается, когда ваша транзакция выдает COMMIT или ROLLBACK. </p><p align="justify" class="paragraph-source">     Пример:</p><p align="justify" class="paragraph-source">LOCK TABLE goods IN ROW SHARE MODE NOWAIT; </p><p align="justify" class="paragraph-source"></p><p align="justify" class="paragraph-source">     Режим блокировки определяет, какие другие блокировки могут быть применены к таблице. Например, несколько пользователей могут одновременно затребовать блокировки row share для одной и той же таблицы, но лишь один пользователь за раз может затребовать МОНОПОЛЬНУЮ (exclusive) блокировку. Пока один пользователь имеет монопольную блокировку таблицы, другие пользователи не могут изменять (INSERT, UPDATE или DELETE) строк в этой таблице. </p><p align="justify" class="paragraph-source">     Необязательное ключевое слово <i><b>NOWAIT </b></i>указывает, что, если запрос LOCK TABLE не может быть удовлетворен (возможно, потому, что таблица уже заблокирована другим пользователем), то LOCK TABLE вернет управление пользователю, вместо того, чтобы ждать удовлетворения запроса. Если вы опустите ключевое слово NOWAIT, то ORACLE будет ждать освобождения таблицы; это ожидание не имеет устанавливаемого предела. Блокировка таблицы никогда не препятствует другим пользователям выдавать запросы по этой таблице; с другой стороны, запрос никогда не требует блокировки таблицы. Одной транзакции придется ждать завершения другой лишь в том случае, если эти транзакции пытаются модифицировать одну и ту же строку. </p></div></div></td></tr></table></td></tr><tr><td id="bottomOuter"><table id="bottomInner"><tr><td class="cell1"><div> </div></td><td class="cell2"><div>© 2012 ХНУРЭ, ПИ, Широкопетлева М.С., <a href="mailto:mshirokopetleva@gmail.com">mshirokopetleva@gmail.com</a>;   ХНУРЭ, ПИ, Черепанова Ю.Ю.<br /><a href="http://lersus.de/" title="Данный курс создан с помощью авторской системы LERSUS" target="_blank">Разработано с помощью LERSUS</a></div></td></tr></table></td></tr></table></body></html>