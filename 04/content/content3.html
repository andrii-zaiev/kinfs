<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="LERSUS 3.3.0.0" /><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Корпоративные информационные системы — Теория — Восстановление данных. Управление параллелизмом</title><script language="javascript" type="text/javascript" src="../../00/styles/files/apiwrapper.js"> </script><script language="javascript" type="text/javascript" src="../../00/styles/files/sco.js"> </script><link href="../../00/styles/files/style.css" rel="stylesheet" type="text/css" /></head><body><table id="mainOuter"><tr><td id="topOuter"><table id="topInner"><tr class="row1"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4" id="shortcuts"><div><ul class="level0"><li><a href="../../00/content/authors1.html">Авторы</a></li><li>|</li><li><a href="../../00/content/contacts1.html">Контакты</a></li><li>|</li><li><a href="../../00/content/instructions1.html">Методические указания</a></li><li>|</li><li><a href="../../00/content/annotation1.html">Аннотация</a></li><li>|</li><li><a href="#" onclick="history.back(); return false;">Назад</a></li></ul></div></td></tr><tr class="row2"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4"><div id="courseTitle">Корпоративные информационные системы</div><div id="courseSubTitle">Распределенные базы данных : Восстановление данных. Управление параллелизмом</div></td></tr></table></td></tr><tr><td id="contentOuter"><table id="contentInner"><tr><td class="menuOuter"><table class="menuInner"><tr><td><ul class="level0"><li><a href="../../00/styles/courses.html">Содержание курса</a></li><li><span>Теория</span></li><ul class="level1"><li><a href="../../04/content/content1.html">Распределенное хранение данных</a></li><li><a href="../../04/content/content2.html">Транзакции</a></li><li><a href="../../04/content/content3.html">Восстановление данных. Управление параллелизмом</a></li><li><a href="../../04/content/content4.html">Обработка распределенных запросов и распределенная модель транзакций</a></li><li><a href="../../04/content/content5.html">Распределение и тиражирование данных</a></li></ul><li><span>Текущий контроль знаний</span></li><ul class="level1"><li><a href="../../04/content/multiply-choice-test1.html">Транзакции и блокировки</a></li><li><a href="../../04/content/multiply-choice-test5.html">Распределенные базы данных</a></li></ul><li><a href="../../04/styles/glossary.html">Словарь терминов</a></li><li><a href="../../04/04.pdf" target="_blank">Версия для печати</a></li></ul></td></tr></table></td><td class="content"><div id="content"><div id="topBlankStripe"> </div><span id="lnke24c6f2ce6994d36aa172672ca572e8a"> </span><h1 align="left" class="headline-source">     Восстановление данных. Управление параллелизмом</h1><span id="lnkd68922d424c84be6bb835678788bccc0"> </span><h2 align="left" class="paragraph-headline-source">     Виды восстановления данных</h2><span id="lnk7ac982d9e38d4efd892ae666805acfc9"> </span><div class="section"><p align="justify" class="paragraph-source">     Восстановление базы данных может производиться в следующих случаях: </p><p align="justify" class="paragraph-source">     - <i><b>Индивидуальный откат транзакции</b></i>. Откат индивидуальной транзакции может быть инициирован либо самой транзакцией путем подачи команды ROLLBACK, либо системой. СУБД может инициировать откат транзакции в случае возникновения какой-либо ошибки в работе транзакции (например, деление на нуль) или если эта транзакция выбрана в качестве жертвы при разрешении тупика. </p><p align="justify" class="paragraph-source">     - <i><b>Мягкий сбой системы</b></i> (<i><b>аварийный отказ программного обеспечения</b></i>). Мягкий сбой характеризуется утратой оперативной памяти системы. При этом поражаются все выполняющиеся в момент сбоя транзакции, теряется содержимое всех буферов базы данных. Данные, хранящиеся на диске, остаются неповрежденными. Мягкий сбой может произойти, например, в результате аварийного отключения электрического питания или в результате неустранимого сбоя процессора. </p><p align="justify" class="paragraph-source">     - <i><b>Жесткий сбой системы</b></i> (<i><b>аварийный отказ аппаратуры</b></i>). Жесткий сбой характеризуется повреждением внешних носителей памяти. Жесткий сбой может произойти, например, в результате поломки головок дисковых накопителей. </p><p align="justify" class="paragraph-source">     Во всех трех случаях основой восстановления является избыточность данных, обеспечиваемая журналом транзакций. </p><p align="justify" class="paragraph-source">     Как и страницы базы данных, данные из журнала транзакций не записываются сразу на диск, а предварительно буферизируются в оперативной памяти. Таким образом, система поддерживает два вида буферов - буферы страниц базы данных и буферы журнала транзакций. </p><p align="justify" class="paragraph-source">     Страницы базы данных, содержимое которых в буфере (в оперативной памяти) отличается от содержимого на диске, называются <i><b>"</b></i><i><b>грязными" (dirty) страницами</b></i>. Система постоянно поддерживает список "грязных" страниц - <i><b>dirty-</b></i><i><b>список</b></i>. Запись "грязных" страниц из буфера на диск называется <i><b>выталкиванием страниц во внешнюю память</b></i>. Очевидно, необходимо предусмотреть такие правила выталкивания буферов базы данных и буферов журнала транзакций, которые обеспечивали бы два требования: </p><p align="justify" class="paragraph-source">     - <i>Максимальную скорость выполнения транзакций</i>. Для этого необходимо выталкивать страницы как можно реже. В идеале, если оперативная память была бы бесконечной, и сбои никогда бы не происходили, наилучшим выходом была бы загрузка <i>всей</i> базы данных в оперативную память, работа с данными <i>только в оперативной памяти</i>, и запись измененных страниц на диск <i>только</i> в момент завершения работы всей системы. </p><p align="justify" class="paragraph-source">     - Гарантию, что при возникновении сбоя (любого типа), данные завершенных транзакций можно было бы восстановить, а данные незавершенных транзакций бесследно удалить, т.е. обеспечение восстановления последнего согласованного состояния базы данных. Для этого что-то выталкивать на диск все-таки необходимо, даже если мы обладали бы бесконечной оперативной памятью. </p><p align="justify" class="paragraph-source">     Таким образом, имеется две причины для периодического выталкивания страниц во внешнюю память - недостаток оперативной памяти и возможность сбоев. </p></div><span id="lnkb4d339ef9aeb40bfbf1268f737b8125c"> </span><div class="section"><p align="justify" class="paragraph-source">     Основным принципом согласованной политики выталкивания буфера журнала и буферов страниц базы данных является то, что запись об изменении объекта базы данных должна попадать во внешнюю память журнала раньше, чем измененный объект оказывается во внешней памяти базы данных. Соответствующий протокол журнализации (и управления буферизацией) называется <i><b>Write Ahead Log</b></i> (<i><b>WAL</b></i>) - "<i><b>пиши сначала в журнал</b></i>", и состоит в том, что если требуется вытолкнуть во внешнюю память измененный объект базы данных, то перед этим нужно гарантировать выталкивание во внешнюю память журнала записи о его изменении. Это означает, что если во внешней памяти базы данных содержится объект, к которому применена некоторая команда модификации, то во внешней памяти журнала транзакций содержится запись об этой операции. Обратное неверно - если во внешней памяти журнала содержится запись о некотором изменении объекта, то во внешней памяти базы данных может и не быть самого измененного объекта. </p><p align="justify" class="paragraph-source">     Дополнительное условие на выталкивание буферов накладывается тем требованием, что каждая успешно завершившаяся транзакция должна быть реально зафиксирована во внешней памяти. Какой бы сбой не произошел, система должна быть в состоянии восстановить состояние базы данных, содержащее результаты всех <i>зафиксированных</i> к моменту сбоя транзакций. </p><p align="justify" class="paragraph-source">     Третьим условием выталкивания буферов является ограниченность объемов буферов базы данных и журнала транзакций. Периодически или при наступлении определенного события (например, количество страниц в dirty-списке превысило определенный порог, или количество свободных страниц в буфере уменьшилось и достигло критического значения) система принимает так называемую <i><b>контрольную точку</b></i>. Принятие контрольной точки включает выталкивание во внешнюю память содержимого буферов базы данных и специальную физическую <i><b>запись контрольной точки</b></i>, которая представляет собой список всех осуществляемых в данный момент транзакций. </p><p align="justify" class="paragraph-source">     Оказывается, что <i>минимальным требованием</i>, гарантирующим возможность восстановления последнего согласованного состояния базы данных, является <i>выталкивание при фиксации транзакции во внешнюю память журнала всех записей об изменении базы данных этой транзакцией</i>. При этом последней записью в журнал, производимой от имени данной транзакции, является специальная запись о конце этой транзакции. </p></div><span id="lnk9a43cd0c84864fba95961056cdad7c07"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Индивидуальный откат транзакции</b></p></div><span id="lnk4631de5f74494b78abae6c9c968f7df0"> </span><div class="section"><p align="justify" class="paragraph-source">     Для того чтобы можно было выполнить по журналу транзакций индивидуальный откат транзакции, все записи в журнале от данной транзакции связываются в обратный список. Началом списка для не закончившихся транзакций является запись о последнем изменении базы данных, произведенном данной транзакцией. Для закончившихся транзакций (индивидуальные откаты которых уже невозможны) началом списка является запись о конце транзакции, которая обязательно вытолкнута во внешнюю память журнала. Концом списка всегда служит первая запись об изменении базы данных, произведенном данной транзакцией. В каждой записи имеется уникальный системный номер транзакции, чтобы можно было восстановить прямой список записей об изменениях базы данных данной транзакцией. </p><p align="justify" class="paragraph-source">     Индивидуальный откат транзакции выполняется следующим образом:      </p><p align="justify" class="paragraph-source">     а) Просматривается список записей, сделанных данной транзакцией в журнале транзакций (от последнего изменения к первому изменению). </p><p align="justify" class="paragraph-source">     б) Выбирается очередная запись из списка данной транзакции. </p><p align="justify" class="paragraph-source">     в) Выполняется противоположная по смыслу операция: вместо операции INSERT выполняется соответствующая операция DELETE, вместо операции DELETE выполняется INSERT, и вместо прямой операции UPDATE обратная операция UPDATE, восстанавливающая предыдущее состояние объекта базы данных. </p><p align="justify" class="paragraph-source">     г) Любая из этих обратных операций также журнализируются. Это необходимо делать, потому что во время выполнения индивидуального отката может произойти мягкий сбой, при восстановлении после которого потребуется откатить такую транзакцию, для которой не полностью выполнен индивидуальный откат. </p><p align="justify" class="paragraph-source">     д)При успешном завершении отката в журнал заносится запись о конце транзакции. </p></div><span id="lnkbd605dba9e304194b49868cceb4558a6"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Восстановление после мягкого сбоя</b></p></div><span id="lnk6d277815eb6d4d8ea7cc3e51e106837d"> </span><div class="section"><p align="justify" class="paragraph-source">     Несмотря на протокол WAL, после мягкого сбоя не все физические страницы базы данных содержат измененные данные, т.к. не все "грязные" страницы базы данных были вытолкнуты во внешнюю память. </p><p align="justify" class="paragraph-source">     Последний момент, когда гарантированно были вытолкнуты "грязные" страницы - это момент принятия последней контрольной точки. Имеется 5 вариантов состояния транзакций по отношению к моменту последней контрольной точки и к моменту сбоя (рис.1) .</p><p align="justify" class="paragraph-source">     </p><p align="center" class="paragraph-source"><img src="../res/files/jpgcee_0_.jpg" height="243px" width="503px" alt="" />            </p><p align="center" class="paragraph-source"></p><p align="center" class="paragraph-source">Рисунок 1- Пять вариантов транзакций (tc  - контрольная точка, tf -  отказ системы) </p><p align="center" class="paragraph-source">     </p></div><span id="lnk13b176f1f6384672a2975e394a71e7aa"> </span><div class="section"><p align="left" class="paragraph-source">     Последняя контрольная точка принималась в момент tc. Мягкий сбой системы произошел в момент tf. Транзакции T1-T5 характеризуются следующими свойствами.</p></div><span id="lnk4b0f6117e1f14ee8940df92379786940"> </span><div id="see-more4b0f6117e1f14ee8940df92379786940" class="additional"><table border="0"><tr><td><img src="../../00/styles/files/seecollapsed.gif" alt="Смотрите также:" title="Смотрите также:" class="collapse-img" style="width:16px; height:16px;" /></td><td><a href="javascript:seeMore('4b0f6117e1f14ee8940df92379786940');" class="paragraph-source">Смотрите также:</a></td></tr></table><div style="display:none;"><p align="justify" class="note-source"> </p><p align="justify" class="note-source">     <b>T1 </b>- транзакция успешно завершена до принятия контрольной точки. Все данные этой транзакции сохранены в долговременной памяти - как записи журнала, так и страницы данных, измененные этой транзакцией. Для транзакции T1 никаких операций по восстановлению не требуется. </p><p align="justify" class="note-source">     <b>T2 </b>- транзакция начата до принятия контрольной точки и успешно завершена после контрольной точки, но до наступления сбоя. Записи журнала транзакций, относящиеся к этой транзакции вытолкнуты во внешнюю память. Страницы данных, измененные этой транзакцией, только частично вытолкнуты во внешнюю память. Для данной транзакции необходимо повторить заново те операции, которые были выполнены после принятия контрольной точки. </p><p align="justify" class="note-source">     <b>T3 </b>- транзакция начата до принятия контрольной точки и не завершена в результате сбоя. Такую транзакцию необходимо откатить. Проблема, однако, в том, что часть страниц данных, измененных этой транзакцией, уже содержится во внешней памяти - это те страницы, которые были обновлены до принятия контрольной точки. Следов изменений, внесенных после контрольной точки в базе данных нет. Записи журнала транзакций, сделанные до принятия контрольной точки, вытолкнуты во внешнюю память, те записи журнала, которые были сделаны после контрольной точки, отсутствуют во внешней памяти журнала. </p><p align="justify" class="note-source">     <b>T4 </b>- транзакция начата после принятия контрольной точки и успешно завершена до сбоя системы. Записи журнала транзакций, относящиеся к этой транзакции вытолкнуты во внешнюю память журнала. Изменения в базе данных, внесенные этой транзакцией, полностью отсутствуют во внешней памяти базы данных. Такую транзакцию необходимо повторить целиком. </p><p align="justify" class="note-source">     <b>T5 </b>- транзакция начата после принятия контрольной точки и не завершена в результате сбоя. Никаких следов этой транзакции нет ни во внешней памяти журнала транзакций, ни во внешней памяти базы данных. Для такой транзакции никаких действий предпринимать не нужно, ее как бы и не было вовсе. </p><p align="justify" class="note-source">     Восстановление системы после мягкого сбоя осуществляется как часть процедуры перезагрузки системы. При перезагрузке системы транзакции T2 и T4 необходимо частично или полностью повторить, транзакцию T3 - частично откатить, для транзакций T1 и T5 никаких действий предпринимать не нужно. При перезагрузке система выполняет следующие действия: </p><p align="justify" class="note-source">     - Создается два списка транзакций UNDO (отменить) и REDO (повторить). В список UNDO заносятся все транзакции из последней записи контрольной точки (т.е. все транзакции, выполнявшиеся в момент принятия контрольной точки). Список REDO остается пустым. В нашем случае будет: UNDO = {T2, T3}, REDO = { }. </p><p align="justify" class="note-source">     - Начиная с записи контрольной точки просматривается вперед журнал транзакций. </p><p align="justify" class="note-source">     - Если в журнале транзакций обнаруживается запись о начале транзакции, то эта транзакция добавляется в список UNDO. В нашем случае будет: UNDO = {T2, T3, T4}, REDO = { }. Заметим, что следов транзакции T5 в журнале транзакций нет. </p><p align="justify" class="note-source">     - Если в файле регистрации обнаруживается запись COMMIT об окончании транзакции, то эта транзакция добавляется в список REDO. В нашем случае будет: UNDO = {T2, T3, T4}, REDO = {T2, T4}. Заметим, что записи о конце этих транзакций имеются во внешней памяти журнала транзакций в соответствии с минимальным требованием выталкивания записей журнала при фиксации транзакции. </p><p align="justify" class="note-source">     - Когда достигается конец журнала транзакций, оба списка анализируются. При этом из списка UNDO удаляются те транзакции, которые попали в список REDO. В нашем случае будет: UNDO = {T3}, REDO = {T2, T4}. </p><p align="justify" class="note-source">     - После этого система просматривает журнал транзакций назад, начиная с момента контрольной точки и откатывая все транзакции из списка UNDO. В нашем случае будут откатываться те операции транзакции T3, которые были выполнены до принятия контрольной точки. </p><p align="justify" class="note-source">     - Окончательно, система просматривает журнал транзакций вперед, начиная с момента контрольной точки, и повторно выполняет все операции транзакций из списка REDO. В нашем случае, система выполнит повторно все операции транзакции T4 и те операции транзакции T2, которые были выполнены после принятия контрольной точки. </p></div></div><span id="lnk65edb695c4bb44b4a1a7c84719d7b032"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Восстановление после жесткого сбоя</b></p></div><span id="lnkd05d14812ba54a018e37b0ed37d1a9fb"> </span><div class="section"><p align="justify" class="paragraph-source">     При жестком сбое база данных на диске нарушается физически. Основой восстановления в этом случае является журнал транзакций и <i><b>архивная копия базы данных</b></i>. Архивная копия базы данных должна создаваться периодически, а именно с учетом скорости наполнения журнала транзакций. </p><p align="justify" class="paragraph-source">     Восстановление начинается с обратного копирования базы данных из архивной копии. Затем выполняется просмотр журнала транзакций для выявления всех транзакций, которые закончились <i>успешно</i> до наступления сбоя. (Транзакции, закончившиеся откатом до наступления сбоя, можно не рассматривать). После этого по журналу транзакций в прямом направлении повторяются все успешно законченные транзакции. При этом нет необходимости отката транзакций, прерванных в результате сбоя, т.к. изменения, внесенными этими транзакциями, отсутствуют после восстановления базы данных из резервной копии. </p><p align="justify" class="paragraph-source">     Наиболее плохим случаем является ситуация, когда разрушены физически и база данных, и журнал транзакций. В этом случае единственное, что можно сделать - это восстановить состояние базы данных на момент последнего резервного копирования. Для того чтобы не допустить возникновение такой ситуации, базу данных и журнал транзакций обычно располагают на <i>физически</i> разных дисках, управляемых физически разными контроллерами. </p><p align="justify" class="paragraph-source">     <b>Восстановление данных и стандарт SQL</b></p><p align="justify" class="paragraph-source">     Стандарт языка SQL не содержит требований к восстановимости данных, оставляя эти вопросы на усмотрение разработчиков СУБД. </p></div><span id="lnk15372a4d30d443c981a9b448015bea7f"> </span><h2 align="left" class="paragraph-headline-source">     Восстановление и копирование базы данных Oracle</h2><span id="lnkbc590bc4369a44b5a19a48d352db45e9"> </span><div class="section"><p align="justify" class="paragraph-source">     Независимо от того, какую схему копирования и восстановления изберете для базы данных ORACLE, резервное копирование средствами операционной системы всех файлов базы данных абсолютно необходимо как часть общей стратегии предохранения от потенциальных сбоев носителя, которые могут повредить эти файлы. </p><p align="justify" class="paragraph-source">     <i><b>Полное копирование </b></i>- это копирование средствами операционной системы всех файлов данных, онлайновых файлов журнала и управляющих файлов, составляющих базу данных ORACLE. Полное копирование должно также включать копирование файлов параметров, ассоциированных с этой базой данных. Полное копирование базы данных проводится, когда база данных чисто закрыта; это означает, что оно не проводится после сбоя инстанции и т.п. В это время все файлы, составляющие базу данных, закрыты, и содержимое их согласовано по отношению к текущему моменту времени.</p><p align="justify" class="paragraph-source">Копии файлов данных, полученные при полном копировании, полезны при любом типе восстановления носителя:</p><p align="justify" class="paragraph-source">     - если база данных работает в режиме NOARCHIVELOG, и сбой диска повреждает некоторые или все файлы, составляющие базу данных, то самые последние полные копии могут использоваться для <i>реставрации </i>(не восстановления) базы данных. Так как архивированный журнал повторения недоступен для приведения базы данных в состояние на текущий момент, вся работа, проделанная в базе данных после последнего полного копирования, должна быть повторена заново;</p><p align="justify" class="paragraph-source">     - если база данных работает в режиме ARCHIVELOG, и сбой диска повреждает некоторые или все файлы, составляющие базу данных, то самые последние полные копии могут использоваться как часть <i>восстановления </i>базы данных. После реставрации необходимых файлов данных из полных копий можно продолжить восстановление путем применения архивированных и текущих онлайновых файлов журнала повторения, чтобы привести реставрированные файлы в состояние на текущий момент времени.</p><p align="justify" class="paragraph-source">     <i><b>Частичное копирование </b></i>- это любое (отличное от полного) копирование средствами операционной системы файлов базы данных, осуществляемое, когда база данных открыта либо закрыта. Примерами частичного копирования служат:</p><p align="justify" class="paragraph-source">     - копирование всех файлов данных конкретного табличного пространства;</p><p align="justify" class="paragraph-source">     - копирование одиночного файла данных;</p><p align="justify" class="paragraph-source">     - копирование управляющего файла.</p><p align="justify" class="paragraph-source">     Частичные копии могут быть полезными лишь для базы данных, работающей в режиме ARCHIVELOG. Так как архивированный журнал повторения присутствует, файлы данных, реставрированные из частичных копий, могут быть согласованы с остальной частью базы данных с помощью процедур восстановления.</p><p align="justify" class="paragraph-source">     Частичное копирование может включать файлы данных базы данных. Отдельные файлы данных или их группы можно копировать независимо от остальных файлов данных, онлайновых файлов журнала и управляющих файлов. Файл данных можно копировать, когда он в состоянии офлайн или онлайн.</p><p align="justify" class="paragraph-source">     Любой файл данных можно копировать, когда он находится в <i>офлайне. </i>Следующие ситуации показывают примеры офлайновых копирований:</p><p align="justify" class="paragraph-source">     - БД закрыта. Как следствие, все файлы данных БД закрыты, или находятся в состоянии офлайн. Любое копирование файлов данных закрытой БД считается офлайновым копированием.</p><p align="justify" class="paragraph-source">     - БД открыта, но табличное пространство находится в состоянии офлайн. Как следствие, все файлы данных этого табличного пространства обычно находятся в офлайне. Любое копирование файлов данных офлайнового табличного пространства считается офлайновым копированием.</p></div><span id="lnkadc5193deead4f54be6a344d990e142a"> </span><div class="section"><p align="justify" class="paragraph-source">     Если база данных работает в режиме ARCHIVELOG, то любой файл данных можно копировать, когда база данных открыта, ассоциированное табличное пространство в онлайне, и сам этот файл данных находится в онлайне и подвергается нормальным операциям базы данных. Такой тип копирования называется <i><b>онлайновым копированием</b></i>.</p><p align="justify" class="paragraph-source">     Копия онлайнового файла данных является копией <i>несогласованных</i> данных; нельзя гарантировать, что все данные в этой копии согласованы по отношению к какой-либо точке времени. Однако эти данные легко сделать согласованными с помощью процедур восстановления базы данных.</p><p align="justify" class="paragraph-source">     Когда начинается копирование онлайнового табличного простраства или индивидуального файла данных (командой ALTER TABLESPACE с опцией BEGIN BACKUP), ORACLE временно прекращает запись контрольных точек в заголовки копируемых файлов данных. Это значит, что после реставрации этого файла данных из копии он "знает" лишь о самой последней контрольной точке, которая была выполнена ПЕРЕД копированием табличного пространства, но не о тех контрольных точках, которые происходили ВО ВРЕМЯ копирования. Как следствие, ORACLE требует, чтобы по время восстановления были применены соответствующие файлы журнала повторения. Когда онлайновое копирование заканчивается (как указывается командой ALTER TABLESPACE с опцией END BACKUP), ORACLE продвигает заголовок файла данных к текущей контрольной точке базы данных.</p></div><span id="lnk5ece5cce05a84e56bcc3a32e032b8951"> </span><h2 align="left" class="paragraph-headline-source">     Восстановление базы данных</h2><span id="lnkc1e6b6f770844b80951ffb21b92d5932"> </span><div class="section"><p align="justify" class="paragraph-source">     <i><b>Процедуры восстановления</b></i></p><p align="justify" class="paragraph-source">     В любой системе баз данных вероятность сбоя системы существует всегда. Когда происходит сбой системы, база данных должна быть восстановлена как можно быстрее и с минимальным возможным ущербом для пользователей.</p><p align="justify" class="paragraph-source">     Восстановление от любого типа системного сбоя требует:</p><p align="justify" class="paragraph-source">     - Определения, какие структуры базы данных не затронуты, а какие требуют восстанвления.</p><p align="justify" class="paragraph-source">     - Осуществления требуемых шагов восстановления.</p><p align="justify" class="paragraph-source">     - Перезапуска базы данных для возобновления нормальной работы.</p><p align="justify" class="paragraph-source">     - Проверки, что никакая работа не потеряна, и что в базе данных нет некорректных данных.</p><p align="justify" class="paragraph-source">     Цель - как можно скорее вернуться к норме, и в то же время изолировать пользователей базы данных от любых проблем и защитить их от возможной потери или дублирования их работы.</p><p align="justify" class="paragraph-source">     Процесс восстановления варьируется в зависимости от типа сбоя и от того, какие файлы базы данных затронуты этим сбоем.</p></div><span id="lnk6034e4aa8e1746b884ae93e437d148a7"> </span><h2 align="left" class="paragraph-headline-source">     Многовариантность</h2><span id="lnk7ca32cd228f6492689e67e3140f99022"> </span><div class="section"><p align="left" class="paragraph-source"></p><p align="justify" class="paragraph-source">     Эта тема очень тесно связана с управлением одновременным доступом, поскольку создает основу для механизмов управления одновременным доступом в СУБД Oracle - Oracle использует модель многовариантной согласованности по чтению при одновременном доступе. По сути это механизм, с помощью которого СУБД Oracle обеспечивает: </p><p align="justify" class="paragraph-source">     - согласованность по чтению для запросов: запросы выдают согласованные результаты на момент начала их выполнения;</p><p align="justify" class="paragraph-source">     - неблокируемые запросы: запросы не блокируются сеансами, в которых изменяются данные, как это бывает в других СУБД.</p><p align="justify" class="paragraph-source">     Это две очень важные концепции СУБД Oracle. Термин многовариантность произошел от того, что фактически СУБД Oracle может одновременно поддерживать множество версий данных в базе данных. Понимая сущность многовариантности, всегда можно понять результаты, получаемые из базы данных.</p><p align="justify" class="paragraph-source">     Еще одна демонстрация многовариантности: в БД имеется несколько версий одной и той же информации, по состоянию на различные моменты времени. СУБД Oracle использует эти сделанные в разное время "моментальные снимки" данных для поддержки согласованности по чтению и неблокируемости запросов. Это согласованное по чтению представление данных всегда выполняется на уровне оператора SQL, - результаты выполнения любого оператора SQL всегда согласованы на момент его начала. Именно это свойство позволяет получать предсказуемый набор данных в результате.</p></div><span id="lnk2435385a3d65445abfee7072167d2c37"> </span><h2 align="left" class="paragraph-headline-source">     Реализация блокирования</h2><span id="lnk1b74f3bd333744c3b94e33a313983186"> </span><div class="section"><p align="justify" class="paragraph-source">     СУБД использует блокировки, чтобы в каждый момент времени те или иные данные могли изменяться только одной транзакцией. Говоря проще, блокировки - это механизм обеспечения одновременного доступа. <b>При </b>отсутствии определенной модели блокирования, предотвращающей одновременное изменение, например, одной строки, многопользовательский доступ к базе данных попросту невозможен. Однако при избыточном или неправильном блокировании одновременный доступ тоже может оказаться невозможным. Если пользователь или сама СУБД блокирует данные без необходимости, то работать одновременно сможет меньшее количество пользователей. Поэтому понимание назначения блокирования и способов его реализации в используемой СУБД принципиально важно для создания корректных и масштабируемых приложений.</p><p align="justify" class="paragraph-source">     <i><b>Блокировка</b></i> - механизм SQL для управления параллельными операциями. Блокировки приостанавливают определенные операции над БД на то время, пока активны другие операции или транзакции.</p><p align="justify" class="paragraph-source">     <i><b>Разделяемые блокировки </b></i>(shared locks) или  S-блокировки (S-locks) - могут одновременно устанавливаться многими пользователями, т.е. любой пользователь имеет доступ к данным, но не может изменять их. </p><p align="justify" class="paragraph-source">     <i><b>Исключительные блокировки</b></i> (exclusive locks) или X-блокировки (X-locks) - позволяют иметь доступ к данным только владельцу блокировки.</p><p align="justify" class="paragraph-source">     <i><b>Последовательность установления блокировок Oracle </b></i>     </p><p align="justify" class="paragraph-source">     - нахождение адреса строки, которую необходимо заблокировать;</p><p align="justify" class="paragraph-source">     - переход на эту строку;</p><p align="justify" class="paragraph-source">     - блокировка этой строки (ожидая снятия блокировки, если она уже заблокирована и при этом на используется NOWAIT).</p><p align="justify" class="paragraph-source">     Простейшими средствами обеспечения очередности доступа, используемые для координации многопользовательского доступа к общим структурам данных, объектам и файлам являются внутренние блокировки и фиксаторы.</p><p align="justify" class="paragraph-source">     <i><b>Фиксаторы</b></i> - блокировки, удерживаемые в течении непродолжительного времени (например для изменения структуры данных в памяти). Используются для защиты определенных структур памяти. <br />     Один процесс - один фиксатор. Если владелец фиксатора «скончается», то очистка выполняется процессом PMON.</p><p align="justify" class="paragraph-source">     <i><b>Внутренние блокировки</b></i> можно устанавливать на разных уровнях, что позволяет иметь несколько разделяемых блокировок и блокировать с разными уровнями совместимости. Работают медленнее фиксаторов, но обеспечивают большие функциональные возможности. </p></div><span id="lnkcdc4611efc5e426eb602d1838cc132e9"> </span><div class="section"><p align="justify" class="paragraph-source">     <i><b>Пессимистические блокировки (pessimistic locks)</b></i> - предотвращают доступ к данным для одновременных транзакций.</p><p align="justify" class="paragraph-source">     Этот метод блокирования должен использоваться непосредственно перед изменением значения на экране, например, когда пользователь выбирает определенную строку с целью изменения (допустим, щелкая на кнопке в окне). Итак, пользователь запрашивает данные без блокирования:</p><p align="justify" class="paragraph-source">     Приложение передает значения для связываемых переменных в соответствии с данными на экране и повторно запрашивает ту же самую строку из базы данных, но в этот раз блокирует ее изменения другими сеансами. Вот почему такой подход называется <i>пессимистическим </i>блокированием. Мы блокируем строку перед попыткой изменения, поскольку сомневается, что она останется неизменной.</p><p align="justify" class="paragraph-source">     <i><b>Оптимистические блокировки (optimistic locks)</b></i> - отслеживают возникновение конфликтов и при необходимости выполняют откат транзакций.</p><p align="justify" class="paragraph-source">     Этот метод состоит в том, чтобы сохранять старое и новое значения в приложении и использовать их при изменении следующим образом:</p><p align="justify" class="paragraph-source"><b>Update table</b></p><p align="justify" class="paragraph-source"><b>Set column1 = :new_column1, column2 = :new_column2, ....</b></p><p align="justify" class="paragraph-source"><b>Where column1 = :old_column1</b></p><p align="justify" class="paragraph-source"><b>And column2 = :old_column2</b></p><p align="justify" class="paragraph-source">     Здесь мы оптимистически надеемся, что данные не изменились. Если в результате изменена <b>одна </b>строка, значит, нам повезло: данные не изменились с момента считывания. Если изменено <b>ноль </b>строк, мы проиграли - кто-то уже изменил данные и необходимо решить, что делать, чтобы это изменение не потерять.</p><p align="justify" class="paragraph-source">     СУБД Oracle обеспечивает грануляцию блокировок по уровням (см. табл. 17)</p></div><span id="lnkca67046cfca14f13902821021d62c6f5"> </span><div align="center"><div class="inline-table-container"><p align="left" class="unit-title">Таблица 17 - Грануляция блокировок</p><table class="inline-table"><col width="152" /><col width="413" /><tbody><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">Уровни блокирования</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Происходящее</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">Таблица</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">блокируется вся таблица</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">Пространство таблицы или БД</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">блокируется физическая область накопителя, в которой размещаются как часть таблицы, так и несколько таблиц</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">Строки</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">применяется к определенной строке таблицы</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">Страницы</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">блокирование страницы (блока) данных на физическом уровне, <i>(</i><i>очень эффективна с точки зрения производительности)</i></p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">Элемент</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">применяется только к одному значению, столбцу или строке (идеально с точки зрения параллелизма, но работает очень медленно)</p></td></tr></tbody></table></div></div><span id="lnk2d492a3c50924046bb777342f5356aec"> </span><div class="section"><p align="justify" class="paragraph-source">     <i><b>Эскалация блокировок </b></i>- увеличение размера блокируемых объектов.</p><p align="justify" class="paragraph-source">     В Oracle применяется <i><b>преобразование блокировок</b></i> - блокировка низкого уровня преобразуется к более высокому (ограничивающему) уровню.</p></div><span id="lnka71292fe85114831a5ce8d2157d04436"> </span><div class="section"><p align="justify" class="paragraph-source">     Стоит заметить, что и в этом случае тоже можно использовать оператор <b>SELECT FOR UPDATE NOWAIT. </b>Представленный выше оператор <b>UPDATE </b>позволяет избежать потери изменений, но может приводить к блокированию, "зависая" в ожидании завершения изменения строки другим сеансом. Если все приложения используют оптимистическое блокирование, то применение простых операторов UPDATE вполне допустимо, поскольку строки блокируются на очень короткое время выполнения и фиксации изменений. Однако если некоторые приложения используют пессимистическое блокирование, удерживая блокировки строк достаточно долго, имеет смысл выполнять оператор <b>SELECT FOR UPDATE NOWAIT </b>непосредственно перед оператором <b>UPDATE, </b>чтобы избежать блокирования другим сеансом </p></div><span id="lnke125ff214fa14db4a80eaefe4914ba0b"> </span><table class="note"><tr><td><p align="left" class="note-source">     Пример:</p><p align="justify" class="note-source">Select … FOR UPDATE; =&gt; исключительная блокировка выбранных строк и ROW SHARED TABLE - совместное блокирование строк таблицы (чтобы ни один сеанс не могли заблокировать всю таблицу). После изменения - преобразование блокировок.</p></td><th><img src="../../00/styles/files/note_problem.png" title="Проблемма" alt="Проблемма" /></th></tr></table><span id="lnkd9b7235d5cfb4a94995f032cc05f9d87"> </span><div class="section"><p align="justify" class="paragraph-source">     При использовании пессимистического блокирования пользователь может быть уверен, что изменяемые им на экране данные сейчас ему "принадлежат" - он получил запись в свое распоряжение, и никто другой не может ее изменять. Можно возразить, что, блокируя строку до изменения, вы лишаете к ней доступа других пользователей и, тем самым, существенно снижаете масштабируемость приложения. Но обновлять строку в каждый момент времени сможет только один пользователь (если мы не хотим потерять изменения). Если сначала заблокировать строку, а затем изменять ее, пользователю будет удобнее работать. Если же пытаться изменить, не заблокировав заранее, пользователь может напрасно потерять время и силы на изменения, чтобы в конечном итоге получить сообщение: "Извините, данные изменились, попробуйте еще раз". Чтобы ограничить время блокирования строки перед изменением, можно снимать блокировку в приложении, если пользователь занялся чем-то другим и некоторое время не использует строку, или использовать профили ресурсов (Resource Profiles) в базе данных для отключения простаивающих сеансов.</p><p align="justify" class="paragraph-source">     Более того, блокирование строки в Oracle не мешает ее читать, как в других СУБД; блокирование строки не мешает обычной работе с базой данных. Все это исключительно благодаря соответствующей реализации механизмов одновременного доступа и блокирования в Oracle. В других СУБД верно как раз обратное. Если попытаться использовать в них пессимистическое блокирование, ни одно приложение не будет работать. Тот факт, что в этих СУБД блокирование строки не дает возможности выполнять к ней запросы, не позволяет даже рассматривать подобный подход. Поэтому иногда приходится "забывать" правила, выработанные в процессе работе с одной СУБД, чтобы успешно разрабатывать приложения для другой.</p></div><span id="lnkbdc2b3e9c9c5470395ab2bfe4a3791cf"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Типы блокировок</b></p></div><span id="lnk174b5473d26e4b9bb980671c84dee949"> </span><div class="section"><p align="justify" class="paragraph-source">     Выделяют общие блокировки, к которым относятся блокировки ЯМД (DML Locks), блокировки ЯОД (DDL Locks) и внутренние блокировки и фиксаторы (защелки) (internal locks, latches), а также для OPS  - Oracle parallel Server характерны распределенные блокировки (distributed locks), которые используются для согласования ресурсов машин, входящих в кластер р (устанавливаются экземплярами баз данных, а не отдельными транзакциями) и блокировки параллельного управления кэшем (PCM Parallel Cache Management Locks) - защищают блоки данных в кэше при использовании несколькими экземплярами.</p><p align="justify" class="paragraph-source">     Подробнее рассмотрим  общие блокировки.</p></div><span id="lnk6cd375b0b8794e45b2e77bf77ec375b0"> </span><div id="see-more6cd375b0b8794e45b2e77bf77ec375b0" class="additional"><table border="0"><tr><td><img src="../../00/styles/files/seecollapsed.gif" alt="Смотрите также:" title="Смотрите также:" class="collapse-img" style="width:16px; height:16px;" /></td><td><a href="javascript:seeMore('6cd375b0b8794e45b2e77bf77ec375b0');" class="paragraph-source">Смотрите также:</a></td></tr></table><div style="display:none;"><p align="justify" class="note-source">     Блокировки ЯМД (DML Locks) позволяют гарантировать, что в каждый момент времени только одному сеансу позволено изменять строку и что не может быть удалена таблица, с которой работает сеанс. Установка блокировок - автоматически по ходу работы.</p><p align="justify" class="note-source">     Выделяют  TX - блокировки транзакций и ТМ - блокировки очередности ЯМД.</p><p align="justify" class="note-source">     ТХ-блокировка устанавливается, когда транзакция инициирует первое изменение и удерживается до выполнения Commit или Rollback. Используется как механизм организации очереди для сеансов, ожидающих завершения транзакции.</p><p align="justify" class="note-source">     Информация о блокировках хранится как часть служебной информации блока - управляется атрибутами хранения INITRANS, MAXTRANS (можно посмотреть в V$TRANSACTION, V$SESSION, V$LOCK).</p><p align="justify" class="note-source">     При установлении ТМ-блокировки структура таблицы не может быть изменена  при изменении ее содержимого. Общее количество ТМ - блокировок конфигурируется администратором (параметр DBMS_Lokcs в файле init.ora). Если 0, то не разрешены операции DDL.</p><p align="justify" class="note-source">     Ниже приведенной командой устанавливается ТМ-блокировка:</p><p align="justify" class="note-source">Alter Table имя_таблицы DISABLE TABLE LOCK.</p><p align="justify" class="note-source">     Блокировки ЯОД автоматически устанавливаются на объекты в ходе выполнения операторов DDL для защиты их от изменения другими сеансами. Операторы DDL всегда фиксируют транзакцию (даже при неудачном завершении).</p><p align="justify" class="note-source">     Выделяют исключительные блокировки, разделяемые блокировки и нарушаемые блокировки разбора.</p><p align="justify" class="note-source">     <b>Исключительные блокировки:</b></p><p align="justify" class="note-source">     - Предотвращают установку блокировок DDL или ТМ другими сеансами. </p><p align="justify" class="note-source">     - Можно запрашивать объекты в ходе выполнения операторов DDL, но нельзя его изменять. </p><p align="justify" class="note-source">     - Большинство операторов DDL устанавливают Исключительную  блокировку DDL .</p><p align="justify" class="note-source">     <b>Разделяемые блокировки:</b></p><p align="justify" class="note-source">     - Защищают структуру соответствующего объекта от изменения другими сеансами, но разрешают изменять данные.</p><p align="justify" class="note-source">     - Устанавливаются на объекты от которых зависят скомпилированные хранимые объекты, типы процедур и представлений.</p><p align="justify" class="note-source">     <b>Нарушаемые блокировки разбора:</b></p><p align="justify" class="note-source">     - Позволяют объекту (план запроса, хранящемуся в кэше разделяемого пула) зарегистрировать свою зависимость от другого объекта.</p><p align="justify" class="note-source">     - Используется для отметки «недействительный» при изменении или удалении объекта, упоминаемого в операторе. </p><p align="justify" class="note-source">     - Они не предотвращают выполнение операторов DDL.</p></div></div><span id="lnkf7d44da1d4a946fdada6a3e21e277d5e"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Примеры блокирования вручную</b></p></div><span id="lnk05e96b8c00134017a36ff8e06d620743"> </span><div class="section"><p align="justify" class="paragraph-source">SELECT … FOR UPDATE - основной метод явного блокирования данных вручную.</p><p align="justify" class="paragraph-source">LOCK TABLE - блокировка таблиц, но не строк в ней.</p><p align="justify" class="paragraph-source">LOCK TABLE IN EXCLUSIVE MODE - блокировка таблицы в эксклюзивном режиме (используется редко, при выполнении большого пакетного изменения).</p></div><span id="lnkf73132f532c04a52bf45af3b167254ac"> </span><h2 align="left" class="paragraph-headline-source">     Уровни изоляции транзакций</h2><span id="lnk02a7e6dff31840bcaf61cae1b482b3c8"> </span><div class="section"><p align="justify" class="paragraph-source">     Уровни<i><b> </b></i>изоляции транзакций показывают какие типы конфликтов допустимы (см. табл.18)</p></div><span id="lnk27cf9ac496dd4dde95ed02221c2af7a6"> </span><div align="center"><div class="inline-table-container"><p align="left" class="unit-title">Таблица 18 - Уровни изволяции транзакций</p><table class="inline-table"><col width="137" /><col width="112" /><col width="78" /><col width="161" /><col width="77" /><tbody><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">Уровень изоляции</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Потерянные изменения</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Грязное чтение</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Неповторяющееся чтение</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Фантом</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">READ UNCOMMITED</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Нет</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Да</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Да</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Да</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">READ COMMITED</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Нет</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Нет</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Да</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Да</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">REPEATABLE READ</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Нет</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Нет</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Нет</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Да</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">SERIALIZABLE</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Нет</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Нет</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Нет</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Нет</p></td></tr></tbody></table></div></div><span id="lnkd68ec08431b547dc91301a2253f9677e"> </span><div class="section"><p align="justify" class="paragraph-source">     <i><b>READ UNCOMMITED (</b></i><i><b>чтение без фиксации)</b></i> - допускает неоднократное выполнение одного и того же запроса с разными результатами независимо от того, были ли результаты параллельных транзакций зафиксированы.</p><p align="justify" class="paragraph-source">     <i><b>READ COMMITED (</b></i><i><b>чтение с фиксацией)</b></i> - допускает неоднократное выполнение одного и того же запроса с разными результатами, но при условии, что результаты параллельных транзакций были зафиксированы.</p><p align="justify" class="paragraph-source">     <i><b>REPEATABLE READ (</b></i><i><b>повторяющееся чтение)</b></i> - допускает из всех возможных видов неповторяющегося чтения только фантомные вставки.</p><p align="justify" class="paragraph-source">     <i><b>SERIALIZABLE (</b></i><i><b>последовательное выполнение)</b></i> - каждая транзакция выполняется изолированно, не влияя на выполнение других параллельных транзакций.</p></div><span id="lnkc4dd202385bc42ada67bd1118c701e0f"> </span><div class="section"><p align="justify" class="paragraph-source">     На всех уровнях изоляции потерянные изменения не допускаются, т.е. при наличии внутри транзакции запроса параллельным транзакциям запрещается обновлять или удалять любые данные, выбранные этим запросом, до полного завершения транзакции.</p><p align="justify" class="paragraph-source">     Транзакции только для чтения (<i><b>READ ONLY)</b></i> очень похожи на транзакции с уровнем изолированности <b>SERIALIZABLE. </b>Эти транзакция не устанавливает никаких блокировок на данные, но и не может их обновлять.</p><p align="justify" class="paragraph-source">     Транзакция <i><b>READ WRITE</b></i> - может выполнять как запросы, так и изменения данных.</p></div><span id="lnk2bfb70f8e741446da200443cddbe097c"> </span><h2 align="left" class="paragraph-headline-source">     Двухфазная фиксация (2ФФ)</h2><span id="lnk59e996dee6a542199d60d3c59190c548"> </span><div class="section"><p align="justify" class="paragraph-source">     Двухфазная фиксация важна всякий раз, когда определенная транзакция может взаимодействовать с несколькими независимыми <i>администраторами ресурсов</i>, каждый из которых руководит своим собственным набором восстанавливаемых ресурсов и поддерживает собственный файл регистрации (журнал). Например, пусть транзакция, запущенная в среде MVS компьютера IBM, модифицирует как базу данных IMS, так и базу данных DB2 (между прочим, такая транзакция вполне допустима). Если транзакция завершается успешно, то все ее обновления, как для данных IMS, так и для данных DB2, могут быть выполнены. В противном случае <i>все </i>ее обновления могут быть отменены или транзакция перестанет быть атомарной.</p><p align="justify" class="paragraph-source">     Для транзакции не имеет смысла выполнять COMMIT для IMS и ROLLBACK для DB2, и, даже если подобная инструкция будет выполнена для обеих баз, система все равно может дать сбой между двумя этими операциями. Вместо этого транзакция выполняет общесистемную команду COMMIT (или ROLLBACK). Этими операциями руководит системный компонент, называемый <i><b>координатором</b></i>. Он гарантирует, что оба администратора ресурсов (т.е. IMS и DB2 в примере) передают или отменяют обновления, за которые они ответственны. Более того, он обеспечивает такую гарантию, <i>даже если система отказала в середине процесса</i>. Это происходит благодаря <i>протоколу двухфазной фиксации</i>.</p><p align="justify" class="paragraph-source">     Ниже приведена последовательность работы координатора. Для простоты примем, что транзакция в базе данных выполнена успешно, а значит, выдана системная операция COMMIT, а не ROLLBACK. После получения запроса на выполнение COMMIT координатор осуществляет следующий двухфазный процесс.</p><p align="justify" class="paragraph-source">     Во-первых, он дает указание всем администраторам ресурсов быть готовыми действовать на транзакцию "любым способом". На практике это означает, что каждый <i>участник </i>процесса, т.е. каждый администратор ресурсов, должен насильно сохранить все записи журнала (файла регистрации) для локальных ресурсов, используемых транзакцией вне собственных физических файлов регистрации (т.е. вне энергозависимой памяти). Теперь, что бы ни случилось, администратор ресурсов не будет выполнять <i>постоянной записи </i>от имени транзакции, а сможет при необходимости передавать свои обновления и отменять их. Если насильственная запись прошла успешно, администратор ресурсов отвечает координатору, что все "ОК". или, наоборот, - "Not OK".</p><p align="justify" class="paragraph-source">     Во вторых, когда координатор получил соответствующие ответы от всех участников, он насильственно заносит записи в собственный физический файл регистрации, указывая свое решение относительно транзакции. Если все ответы были "ОК", то решение будет "выполнить", а если был ответ "Not ОК", то - "прокрутить назад". Затем координатор любым способом информирует каждого участника о своем решении, и <i>каждый участник согласно инструкции должен локально зафиксировать или аннулировать транзакции</i>. Отметьте, что каждый участник должен делать то, что ему велел координатор во время фазы 2, - в этом и состоит протокол.</p><p align="justify" class="paragraph-source">     Обратите также внимание, что именно появление записи решения в физическом файле регистрации координатора и отмечает переход с фазы 1 на фазу 2.</p><p align="justify" class="paragraph-source">     Теперь, если система дает сбой в какой-либо точке во время полного процесса, процедура перезагрузки будет искать запись решения в файле регистрации координатора. </p><p align="justify" class="paragraph-source">     Если она ее обнаружит, то сможет указать, где произошла остановка. Если эта запись не будет обнаружена, значит, принятым решением будет <i>откат </i>и, следовательно, процесс будет завершен.</p><p align="justify" class="paragraph-source">     Стоит подчеркнуть, что если координатор и участники выполняют свою работу на различных механизмах (поскольку они могут представлять собой распределенную систему), то ошибка в работе координатора может привести к тому, что некий участник довольно долго будет ожидать решения координатора. Во <i>время ожидания </i>ни одно обновление, произведенное транзакцией, не сможет произойти с помощью этого участника, оно будет как бы скрыто от других транзакций (иными словами, такое обновление будет <i>заблокировано</i>, об этом еще будет идти речь в следующих главах).</p><p align="justify" class="paragraph-source">     Отметим, что диспетчер передачи данных, также называемый администратором передачи данных, может считаться администратором ресурсов в описанном выше смысле. </p><p align="justify" class="paragraph-source">     Это означает, что сообщения можно считать такими же восстанавливаемыми ресурсами, как и базу данных, а администратор передачи данных способен участвовать в процессе двухфазной фиксации.</p></div><span id="lnka26349283cea4df695ca575be924513f"> </span><h2 align="left" class="paragraph-headline-source">     Распределенные транзакции</h2><span id="lnk709b13ad81084598b940cf200261a549"> </span><div class="section"><p align="justify" class="paragraph-source">     <b>Распределенные транзакции</b> обращаются к двум и более узлам и обновляют на них данные.</p><p align="justify" class="paragraph-source">     Основная проблема распределенных транзакций - соблюдение логической целостности данных. Транзакция на всех узлах должна завершиться одинаково: или фиксацией, или откатом. </p><p align="justify" class="paragraph-source">     Выполнение распределенных транзакций осуществляется с помощью специального алгоритма, который называется <b>двухфазная фиксация</b>. </p><p align="justify" class="paragraph-source">     <i><b>Координатор транзакции</b></i> - узел, который контролирует выполнение этого протокола (обычно, тот узел, который инициирует данную транзакцию).</p><p align="justify" class="paragraph-source">     Остальные узлы, на которых выполняется транзакция, называются <i><b>участниками транзакции</b></i>.</p><p align="justify" class="paragraph-source">     На рис.2 приведены схемы взаимодействия участников при поддержке протокола двухфазной фиксации транзакций для различных схем реализации.</p></div><span id="lnk85425e2f325240e597e03dbad893b891"> </span><div class="section"><p align="center" class="paragraph-source"><img src="../res/files/jpgcef_0_.jpg" height="471px" width="606px" alt="" /> </p><p align="center" class="paragraph-source">Рисунок 2 - Реализация протокола 2ФФ</p></div><span id="lnkbbc8c83590c040a6ba1069f31079d6be"> </span><div class="section"><p align="left" class="paragraph-source">     На рис. 3 приведен протокол протокол двухфазной фиксации</p></div><span id="lnkaf2ebec27d3f476398c36721bfc3fdfe"> </span><div class="section"><p align="center" class="paragraph-source"><img src="../res/files/jpgcf0_0_.jpg" height="310px" width="554px" alt="" /> </p><p align="center" class="paragraph-source">Рисунок 3 - Протокол двухфазной фиксации</p></div><span id="lnk5eb14f56acf04178b374a90ae45215ea"> </span><div class="section"><p align="justify" class="paragraph-source">     <i><b>Действия координатора транзакции</b></i></p></div><span id="lnke59aec103363446d883d2eef7c023c4b"> </span><div id="see-moree59aec103363446d883d2eef7c023c4b" class="additional"><table border="0"><tr><td><img src="../../00/styles/files/seecollapsed.gif" alt="Смотрите также:" title="Смотрите также:" class="collapse-img" style="width:16px; height:16px;" /></td><td><a href="javascript:seeMore('e59aec103363446d883d2eef7c023c4b');" class="paragraph-source">Смотрите также:</a></td></tr></table><div style="display:none;"><p align="justify" class="note-source">     Координатор выполняет протокол 2ФФ по следующему алгоритму:     </p><p align="justify" class="note-source">     Фаза 1 (голосование).</p><p align="justify" class="note-source">     Занести запись begin_commit в системный журнал и обеспечить ее перенос из буфера в ОП на ВЗУ. Отправить всем участникам команду PREPARE.</p><p align="justify" class="note-source">     Ожидать ответов всех участников в пределах установленного тайм-аута.</p><p align="justify" class="note-source">     Фаза 2 (принятие решения).</p><p align="justify" class="note-source">     При поступлении сообщения ABORT: занести в системный журнал запись abort и обеспечить ее перенос из буфера в ОП на ВЗУ; отправить всем участникам сообщение GLOBAL_ABORT и ждать ответов участников (тайм-аут).</p><p align="justify" class="note-source">     Если участник не отвечает в течение установленного тайм-аута, координатор считает, что данный участник откатит свою часть транзакции и запускает протокол ликвидации.</p><p align="justify" class="note-source">     Если все участники прислали COMMIT, поместить в системный журнал запись commit и обеспечить ее перенос из буфера в ОП на ВЗУ. Отправить всем участникам сообщение GLOBAL_COMMIT и ждать ответов всех участников.</p><p align="justify" class="note-source">     После поступления подтверждений о фиксации от всех участников: поместить в системный журнал запись end_transaction и обеспечить ее перенос из буфера в ОП на ВЗУ.</p><p align="justify" class="note-source">     Если некоторые узлы не прислали подтверждения фиксации, координатор заново направляет им сообщения о принятом решении и поступает по этой схеме до получения всех требуемых подтверждений.</p></div></div><span id="lnk4586504493004a62b0691d9e16cf0369"> </span><div class="section"><p align="justify" class="paragraph-source">     <i><b>Действия участника транзакции</b></i>     </p></div><span id="lnk75cd80b27c8d498ba1385945502402dd"> </span><div id="see-more75cd80b27c8d498ba1385945502402dd" class="additional"><table border="0"><tr><td><img src="../../00/styles/files/seecollapsed.gif" alt="Смотрите также:" title="Смотрите также:" class="collapse-img" style="width:16px; height:16px;" /></td><td><a href="javascript:seeMore('75cd80b27c8d498ba1385945502402dd');" class="paragraph-source">Смотрите также:</a></td></tr></table><div style="display:none;"><p align="justify" class="note-source">     Участник выполняет протокол 2ФФ по следующему алгоритму:</p><p align="justify" class="note-source">     а)При получении команды PREPARE, если он готов зафиксировать свою часть транзакции, он помещает запись ready_commit в файл журнала транзакций и отправляет координатору сообщение READY_COMMIT. Если он не может зафиксировать свою часть транзакции, он помещает запись abort в файл журнала транзакций, отправляет координатору сообщение ABORT и откатывает свою часть транзакции (не дожидаясь общего сигнала GLOBAL_ABORT).</p><p align="justify" class="note-source">     б)Если участник отправил координатору сообщение READY_COMMIT, то он ожидает ответа координатора в пределах установленного тайм-аута.</p><p align="justify" class="note-source">     в)При получении GLOBAL_ABORT участник помещает запись abort в файл журнала транзакций, откатывает свою часть транзакции и отправляет координатору подтверждение отката.</p><p align="justify" class="note-source">     г)При получении GLOBAL_COMMIT участник помещает запись commit в файл журнала транзакций, фиксирует свою часть транзакции и отправляет координатору подтверждение фиксации.</p><p align="justify" class="note-source">     д)Если в течение установленного тайм-аута участник не получает сообщения от координатора, он откатывает свою часть транзакции.</p></div></div><span id="lnka5775f4bdd934fb5b41d63eadc10ab5e"> </span><div class="section"><p align="justify" class="paragraph-source">     <i><b>Протокол ликвидации для координатора</b></i></p></div><span id="lnkfab8c5392d564bbab1c51bdb4b5d4e58"> </span><div id="see-morefab8c5392d564bbab1c51bdb4b5d4e58" class="additional"><table border="0"><tr><td><img src="../../00/styles/files/seecollapsed.gif" alt="Смотрите также:" title="Смотрите также:" class="collapse-img" style="width:16px; height:16px;" /></td><td><a href="javascript:seeMore('fab8c5392d564bbab1c51bdb4b5d4e58');" class="paragraph-source">Смотрите также:</a></td></tr></table><div style="display:none;"><p align="justify" class="note-source">     Протокол ликвидации для координатора:</p><p align="justify" class="note-source">     а)Тайм-аут в состоянии WAITING: координатор не может зафиксировать транзакцию, потому что не получены все подтверждения от участников о фиксации. Ликвидация заключается в откате транзакции.</p><p align="justify" class="note-source">     б)Тайм-аут в состоянии DECIDED: координатор повторно рассылает сведения и принятом глобальном решении и ждет ответов от участников.</p><p align="justify" class="note-source">     Простейший протокол ликвидации для участника заключается в блокировании процесса до тех пор, пока сеанс связи с координатором не будет восстановлен. Но в целях повышения производительности (и автономности) узлов могут быть предприняты и другие действия:</p><p align="justify" class="note-source">     а)Тайм-аут в состоянии INITIAL: участник не может сообщить о своем решении координатору и не может зафиксировать транзакцию. Но может откатить свою часть транзакции. Если он позднее получит команду PREPARE, он может проигнорировать ее или отправить координатору сообщение ABORT.</p><p align="justify" class="note-source">     б)Тайм-аут в состоянии PREPARED: участник уже известил координатор о решении COMMIT, то он не может его изменить. Участник оказывается заблокированным.</p></div></div><span id="lnk06ab8769f1f24d77b5b760f666b9ebfc"> </span><div class="section"><p align="justify" class="paragraph-source">     Действия, которые выполняются на отказавшем узле после его перезагрузки, называются <i><b>протоколом восстановления</b></i>. </p><p align="justify" class="paragraph-source">     Они зависят от того, в каком состоянии находился узел, когда произошел сбой, и какую роль выполнял этот узел в момент отказа: координатора или участника.</p><p align="justify" class="paragraph-source">     </p></div><span id="lnkdb560f413edf400fa3fd3e800be338c6"> </span><div id="see-moredb560f413edf400fa3fd3e800be338c6" class="additional"><table border="0"><tr><td><img src="../../00/styles/files/seecollapsed.gif" alt="Смотрите также:" title="Смотрите также:" class="collapse-img" style="width:16px; height:16px;" /></td><td><a href="javascript:seeMore('db560f413edf400fa3fd3e800be338c6');" class="paragraph-source">Смотрите также:</a></td></tr></table><div style="display:none;"><p align="justify" class="note-source">     <b>При отказе координатора:</b></p><p align="justify" class="note-source">     - В состоянии INITIAL: процедура 2ФФ еще не запускалась, поэтому после перезагрузки следует ее запустить;</p><p align="justify" class="note-source">     - в состоянии WAITING: координатор уже направил команду PREPARE, но еще не получил всех ответов и не получил ни одного сообщения ABORT. В этом случае он перезапускает процедуру 2ФФ;</p><p align="justify" class="note-source">     - в состоянии DECIDED: координатор уже направил участникам глобальное решение. Если после перезапуска он получит все подтверждения, то транзакция считается успешно зафиксированной. В противном случае он должен прибегнуть к протоколу ликвидации.</p><p align="justify" class="note-source">     <b>При отказе участника</b> цель протокола восстановления - гарантировать, что после восстановления узел выполнит в отношении транзакции то же действие, которое выполнили другие участники, и сделает это независимо от координатора, т.е. по возможности без дополнительных подтверждений. </p><p align="justify" class="note-source">     Рассмотрим три возможных момента возникновения отказа:</p><p align="justify" class="note-source">     - в состоянии INITIAL: участник еще не успел сообщит о своем решении координатору, поэтому он может выполнить откат, т.к. координатор не мог принять решение о глобальной фиксации транзакции без голоса этого участника;</p><p align="justify" class="note-source">     - в состоянии PREPARED: участник уже направил сведения о своем решении координатору, поэтому он должен запустить свой протокол ликвидации;</p><p align="justify" class="note-source">     - в состоянии ABORTED/COMMITED: участник уже завершил обработку своей части транзакции, поэтому никаких дополнительных действий не требуется.</p></div></div></div></td></tr></table></td></tr><tr><td id="bottomOuter"><table id="bottomInner"><tr><td class="cell1"><div> </div></td><td class="cell2"><div>© 2012 ХНУРЭ, ПИ, Широкопетлева М.С., <a href="mailto:mshirokopetleva@gmail.com">mshirokopetleva@gmail.com</a>;   ХНУРЭ, ПИ, Черепанова Ю.Ю.<br /><a href="http://lersus.de/" title="Данный курс создан с помощью авторской системы LERSUS" target="_blank">Разработано с помощью LERSUS</a></div></td></tr></table></td></tr></table></body></html>