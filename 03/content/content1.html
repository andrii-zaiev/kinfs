<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="LERSUS 3.3.0.0" /><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Корпоративные информационные системы — Теория — Оптимизация запросов</title><script language="javascript" type="text/javascript" src="../../00/styles/files/apiwrapper.js"> </script><script language="javascript" type="text/javascript" src="../../00/styles/files/sco.js"> </script><link href="../../00/styles/files/style.css" rel="stylesheet" type="text/css" /></head><body><table id="mainOuter"><tr><td id="topOuter"><table id="topInner"><tr class="row1"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4" id="shortcuts"><div><ul class="level0"><li><a href="../../00/content/authors1.html">Авторы</a></li><li>|</li><li><a href="../../00/content/contacts1.html">Контакты</a></li><li>|</li><li><a href="../../00/content/instructions1.html">Методические указания</a></li><li>|</li><li><a href="../../00/content/annotation1.html">Аннотация</a></li><li>|</li><li><a href="#" onclick="history.back(); return false;">Назад</a></li></ul></div></td></tr><tr class="row2"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4"><div id="courseTitle">Корпоративные информационные системы</div><div id="courseSubTitle">Языки запросов к базам данных : Оптимизация запросов</div></td></tr></table></td></tr><tr><td id="contentOuter"><table id="contentInner"><tr><td class="menuOuter"><table class="menuInner"><tr><td><ul class="level0"><li><a href="../../00/styles/courses.html">Содержание курса</a></li><li><span>Теория</span></li><ul class="level1"><li><a href="../../03/content/content1.html">Оптимизация запросов</a></li><li><a href="../../03/content/content2.html">Окружение 4-го поколения</a></li><li><a href="../../03/content/content3.html">Язык PL / SQL. Общие положения </a></li><li><a href="../../03/content/content4.html">Переменные и константы. Кодовое множество</a></li><li><a href="../../03/content/content5.html">Типы данных</a></li><li><a href="../../03/content/content6.html">Команды управления</a></li><li><a href="../../03/content/content7.html">Создание хранимых процедур и функций </a></li><li><a href="../../03/content/content8.html">Параметры подпрограмм</a></li><li><a href="../../03/content/content9.html">Встроенные функции PL / SQL</a></li><li><a href="../../03/content/content10.html">Курсоры</a></li><li><a href="../../03/content/content11.html">Исключительные ситуации</a></li><li><a href="../../03/content/content12.html">Обработчики исключений </a></li><li><a href="../../03/content/content13.html">Пакеты</a></li><li><a href="../../03/content/content14.html">Триггеры объектов </a></li></ul><li><span>Практика</span></li><ul class="level1"><li><a href="../../03/content/example1.html">Практика 2. Использование подпрограмм в языках  программирования 4-го поколения</a></li><li><a href="../../03/content/example2.html">Лабораторная работа 2 Подпрограммы как средство создания серверных частей информационных систем на примере СУБД Oracle </a></li><li><a href="../../03/content/example3.html">Практика 3. Создание  и работа с триггерами объектов и событий</a></li><li><a href="../../03/content/example4.html">Лабораторная работа 3. Триггеры объектов и событий базы данных </a></li></ul><li><span>Текущий контроль знаний</span></li><ul class="level1"><li><a href="../../03/content/multiply-choice-test25.html">Управляющие структуры</a></li><li><a href="../../03/content/multiply-answers-test7.html">Подпрограммы языка PL/SQL</a></li><li><a href="../../03/content/multiply-choice-test1.html">Курсоры</a></li><li><a href="../../03/content/multiply-answers-test12.html">Исключительные ситуации</a></li><li><a href="../../03/content/multiply-choice-test19.html">Пакеты</a></li><li><a href="../../03/content/multiply-answers-test3.html">Триггеры</a></li></ul><li><a href="../../03/styles/glossary.html">Словарь терминов</a></li><li><a href="../../03/03.pdf" target="_blank">Версия для печати</a></li></ul></td></tr></table></td><td class="content"><div id="content"><div id="topBlankStripe"> </div><span id="lnke182b54726ad4d9cb653a1ca3d2b0ed4"> </span><h1 align="left" class="headline-source">     Оптимизация запросов</h1><span id="lnk8a886886422048cc9950ccc9054f9e60"> </span><div class="section"><p align="justify" class="paragraph-source">     Оптимизация запросов - это:</p><p align="justify" class="paragraph-source">     а) функция СУБД, осуществляющая поиск оптимального <b>плана выполнения запросов</b> из всех возможных для заданного запроса, </p><p align="justify" class="paragraph-source">     б) процесс изменения запроса и/или структуры БД с целью уменьшения использования вычислительных ресурсов при выполнении запроса. </p><p align="justify" class="paragraph-source">     Один и тот же результат может быть получен СУБД различными способами (планами выполнения запросов), которые могут существенно отличаться как по затратам ресурсов, так и по времени выполнения. Задача оптимизации заключается в нахождении оптимального способа.</p><p align="justify" class="paragraph-source">     В реляционной СУБД оптимальный план выполнения запроса - это такая последовательность применения операторов реляционной алгебры к исходным и промежуточным отношениям, которое для конкретного текущего состояния БД (её структуры и наполнения) может быть выполнено с минимальным использованием вычислительных ресурсов.</p><p align="justify" class="paragraph-source">     В настоящее время известны две стратегии поиска оптимального плана:</p><p align="justify" class="paragraph-source">     - грубой силы путём оценки всех перестановок соединяемых таблиц;</p><p align="justify" class="paragraph-source">     - на основе генетического алгоритма путём оценки ограниченного числа перестановок.</p><p align="justify" class="paragraph-source">     Планы выполнения запроса сравниваются исходя из следующих факторов:</p><p align="justify" class="paragraph-source">     - потенциальное число строк, извлекаемое из каждой таблицы, получаемое из статистики;</p><p align="justify" class="paragraph-source">     - наличие индексов;</p><p align="justify" class="paragraph-source">     - возможность выполнения слияний (merge-join).</p><p align="justify" class="paragraph-source">     В общем случае соединение выполняется вложенными циклами. Однако этот алгоритм может оказаться менее эффективен, чем специализированные алгоритмы. Если у сливаемых таблиц есть индексы по соединяемым полям, или одна или обе таблицы достаточно малы, чтобы быть отсортированными в памяти, то исследуется возможность выполнения слияний.</p></div><span id="lnk41537659ca954e949df681ec2e6e29a6"> </span><h2 align="left" class="paragraph-headline-source">     Общая схема обработки запроса</h2><span id="lnkd0216966d2d741278bc08484c1790616"> </span><div class="section"><p align="justify" class="paragraph-source">     Можно представить, что обработка поступившего в систему запроса состоит из фаз, изображенных на рис. 1.</p><p align="justify" class="paragraph-source">     </p><p align="center" class="paragraph-source"><img src="../res/files/jpgb52_0_.jpg" height="198px" width="377px" alt="" /> </p><p align="center" class="paragraph-source">Рисунок 1 - Фазы выполнения запроса</p><p align="center" class="paragraph-source">     </p></div><span id="lnkd8e2154687f447d4a5152a2890c42471"> </span><div class="section"><p align="justify" class="paragraph-source">     На <b>первой </b>фазе запрос, заданный на языке запросов, подвергается лексическому и синтаксическому анализу. При этом вырабатывается его внутреннее представление, отражающее структуру запроса и содержащее информацию, которая характеризует объекты базы данных, упомянутые в запросе (отношения, поля и константы). Информация о хранимых в базе данных объектах выбирается из каталогов базы данных. Внутреннее представление запроса используется и преобразуется на следующих стадиях обработки запроса. Форма внутреннего представления должна быть достаточно удобной для последующих оптимизационных преобразований.</p><p align="justify" class="paragraph-source">     На <b>второй </b>фазе запрос во внутреннем представлении подвергается логической оптимизации. Могут применяться различные преобразования, "улучшающие" начальное представление запроса. Среди преобразований могут быть эквивалентные, после проведения которых получается внутреннее представление, семантически эквивалентное начальному (например, приведение запроса к некоторой канонической форме), Преобразования могут быть и семантическими: получаемое представление не является семантически эквивалентным начальному, но гарантируется, что результат выполнения преобразованного запроса совпадает с результатом запроса в начальной форме при соблюдении ограничений целостности, существующих в базе данных. После выполнения второй фазы обработки запроса его внутреннее представление остается непроцедурным, хотя и является в некотором смысле более эффективным, чем начальное.</p><p align="justify" class="paragraph-source">     <b>Третий </b>этап обработки запроса состоит в выборе на основе информации, которой располагает оптимизатор, набора альтернативных процедурных планов выполнения данного запроса в соответствии с его внутреннем представлением, полученным на второй фазе. Для каждого плана оценивается предполагаемая стоимость выполнения запроса. При оценках используется статистическая информация о состоянии базы данных, доступная оптимизатору. Из полученных альтернативных планов выбирается наиболее дешевый, и его внутреннее представление теперь соответствует обрабатываемому запросу.</p><p align="justify" class="paragraph-source">     На <b>четвертом </b>этапе по внутреннему представлению наиболее оптимального плана выполнения запроса формируется выполняемое представление плана. Выполняемое представление плана может быть программой в машинных кодах, что не принципиально, поскольку четвертая фаза обработки запроса уже не связана с оптимизацией.</p><p align="justify" class="paragraph-source">     Наконец, на <b>пятом </b>этапе обработки запроса происходит его реальное выполнение. Это либо выполнение соответствующей подпрограммы, либо вызов интерпретатора с передачей ему для интерпретации выполняемого плана.</p></div><span id="lnk28dcdcd637d546ff838478cb583b89ad"> </span><h2 align="left" class="paragraph-headline-source">     Стратегии оптимизации</h2><span id="lnk92f8f64894b14ac2ab72877a4cc678ad"> </span><div class="section"><p align="justify" class="paragraph-source">     Суть оптимизации заключается в поиске минимума функции стоимости от перестановки таблиц. Независимо от стратегии, оптимизатор обязан уметь анализировать стоимость для произвольной перестановки, в то время как сами перестановки для анализа предоставляются другим алгоритмом. Исследуемое множество перестановок может отличаться от всего пространства перестановок. Исходя из этого, обобщённый алгоритм работы оптимизатора можно записать так: «Перебор всех планов в поисках наилучшего»</p></div><span id="lnk3b164c0b67bc4cc6bd9f1ebc56f81232"> </span><div class="section"><p align="justify" class="paragraph-source">     <b>Стратегия грубой силы</b></p><p align="justify" class="paragraph-source">     В теории, при использовании стратегии грубой силы оптимизатор запросов исследует все пространство перестановок всех исходных выбираемых таблиц и сравнивает суммарные оценки стоимости выполнения соединения для каждой перестановки. На практике, было предложено ограничить пространство исследования только левосторонними соединениями, чтобы при выполнении запроса одна из таблиц всегда была представлена образом на диске. Исследование нелевосторонних соединений имеет смысл если таблицы, входящие в соединения, расположены на более чем одном узле.</p><p align="justify" class="paragraph-source">     Для каждой таблицы в каждой из перестановок по статистике оценивается возможность использования индексов. Перестановка с минимальной оценкой и есть итоговый план выполнения запроса.</p></div><span id="lnkaab09e5049a7406f8ebf40f76ac6f580"> </span><div class="section"><p align="justify" class="paragraph-source">     <b>Синтаксическая оптимизация запросов</b></p><p align="justify" class="paragraph-source">     При классическом подходе к организации оптимизаторов запросов на этапе логической оптимизации производятся эквивалентные преобразования внутреннего представления запроса, которые "улучшают" начальное внутреннее представление в соответствии с фиксированными стратегиями оптимизатора. Характер "улучшений" связан со спецификой общей организации оптимизатора, в частности, с особенностями процедуры поиска возможных процедурных планов запросов, выполняемой на третьей фазе обработки запроса.</p><p align="justify" class="paragraph-source">     Поэтому трудно привести полную характеристику и классификацию методов логической оптимизации.</p></div><span id="lnkef0ea4447de24042b9db0fb92033bae3"> </span><div class="section"><p align="justify" class="paragraph-source">     <b>Простые логические преобразования запросов</b></p><p align="justify" class="paragraph-source">     Очевидный класс логических преобразований запроса составляют преобразования предикатов, входящих в условие выборки, к каноническому представлению. Имеются в виду предикаты, содержащие операции сравнения простых значений.</p></div><span id="lnk8da811c0a69e4077a2d190336fe2c494"> </span><div class="section"><p align="justify" class="paragraph-source">     <b>Преобразования запросов с изменением порядка реляционных операций</b></p><p align="justify" class="paragraph-source">     В традиционных оптимизаторах распространены логические преобразования, связанные с изменением порядка выполнения реляционных операций. Примером соответствующего правила преобразования в терминах реляционной алгебры может быть следующее (A и B - имена отношений):</p><p align="justify" class="paragraph-source">(A JOIN B) WHERE restriction-on-A AND restriction-on-B</p><p align="justify" class="paragraph-source">эквивалентно выражению</p><p align="justify" class="paragraph-source">A WHERE restriction-on-A) JOIN (B WHERE restriction-on-B).</p><p align="justify" class="paragraph-source">     Здесь JOIN обозначает реляционный оператор естественного соединения отношений; A WHERE restriction - оператор ограничения отношения A в соответствии с предикатом restriction.</p><p align="justify" class="paragraph-source">     Хотя немногие реляционные системы имеют языки запросов, основанные в чистом виде на реляционной алгебре, правила преобразований алгебраических выражений могут быть полезны и в других случаях. Довольно часто реляционная алгебра используется в качестве основы внутреннего представления запроса. Естественно, что после этого можно выполнять и алгебраические преобразования.</p><p align="justify" class="paragraph-source">     Разумное преобразование запроса на SQL к алгебраическому представлению сокращает пространство поиска планов выполнения запроса с гарантией того, что оптимальные планы потеряны не будут.</p></div><span id="lnk7eb4f784acd74b6d8770d8d3d0078778"> </span><div class="section"><p align="justify" class="paragraph-source">     <b>Приведение запросов со вложенными подзапросами к запросам с соединениями</b></p><p align="justify" class="paragraph-source">     Основным отличием языка SQL от языка реляционной алгебры является возможность использовать в логическом условии выборки предикаты, содержащие вложенные подзапросы. Глубина вложенности не ограничивается языком, т.е., вообще говоря, может быть произвольной. Предикаты с вложенными подзапросами при наличии общего синтаксиса могут обладать весьма различной семантикой. Единственным общим для всех возможных семантик вложенных подзапросов алгоритмом выполнения запроса является вычисление вложенного подзапроса всякий раз при вычислении значения предиката. Поэтому естественно стремиться к такому преобразованию запроса, содержащего предикаты со вложенными подзапросами, которое сделает семантику подзапроса более явной, предоставив тем самым в дальнейшем оптимизатору возможность выбрать способ выполнения запроса, наиболее точно соответствующий семантике подзапроса.</p></div><span id="lnk41959f0155204b29b67c882e521b3ae9"> </span><div class="section"><p align="justify" class="paragraph-source">     Предикаты, допустимые в запросах языка SQL, можно разбить на следующие четыре группы:</p><p align="justify" class="paragraph-source">     - простые предикаты;</p><p align="justify" class="paragraph-source">     - предикаты со вложенными подзапросами;</p><p align="justify" class="paragraph-source">     - предикаты соединения;</p><p align="justify" class="paragraph-source">     - предикаты деления.</p><p align="justify" class="paragraph-source">     <i>Простые предикаты</i>. Это предикаты вида Ri.Ck op X, где X - константа или список констант, и op - оператор скалярного сравнения (=, !=, &gt;, &gt;=, &lt;, &lt;=) или оператор проверки вхождения во множество (IS IN, IS NOT IN).</p><p align="justify" class="paragraph-source">     <i>Предикаты со вложенными подзапросами</i>. Это предикаты вида Ri.Ck op Q, где Q - блок запроса, а op может быть таким же, как для простых предикатов. Предикат может также иметь вид Q op Ri.Ck. В этом случае оператор принадлежности ко множеству заменяется на CONTAINS или DOES NOT CONTAIN. Эти две формы симметричны. Достаточно рассматривать только одну.</p><p align="justify" class="paragraph-source">     <i>Предикаты соединения</i>. Это предикаты вида Ri.Ck op Rj.Cn, где Ri != Rj и op - оператор скалярного сравнения.</p><p align="justify" class="paragraph-source">     <i>Предикаты деления</i>. Это предикаты вида Qi op Qj, где Qi и Qj - блоки запросов, а op может быть оператором скалярного сравнения или оператором проверки вхождения в множество.</p><p align="justify" class="paragraph-source">     Приведенная классификация является упрощением реальной ситуации в SQL. Не рассматриваются предикаты соединения общего вида, включающие арифметические выражения с полями более чем двух отношений.</p><p align="justify" class="paragraph-source">     Каноническим представлением запроса на n отношениях называется запрос, содержащий n-1 предикат соединения и не содержащий предикатов со вложенными подзапросами. Фактически, каноническая форма - это алгебраическое представление запроса.</p><p align="justify" class="paragraph-source">     Ниже приводятся два примера канонических форм запросов с предикатами разного типа. Соответствующая техника существует и для других видов предикатов.</p><p align="justify" class="paragraph-source">SELECT Ri.Ck FROM Ri WHERE Ri.Ch IS IN</p><p align="justify" class="paragraph-source">  SELECT Rj.Cm FROM Rj WHERE Ri.Cn = Rj.Cp</p><p align="justify" class="paragraph-source">эквивалентно</p><p align="justify" class="paragraph-source">SELECT Ri.Ck FROM Ri, Rj WHERE</p><p align="justify" class="paragraph-source">  Ri.Ch = Rj.Cm AND Ri.Cn = Rj.Cp</p><p align="justify" class="paragraph-source">SELECT Ri.Ck FROM Ri WHERE Ri.Ch =</p><p align="justify" class="paragraph-source">  SELECT AVG (Rj.Cm) FROM Rj WHERE Rj.Cn = Ri.Cp</p><p align="justify" class="paragraph-source">эквивалентно</p><p align="justify" class="paragraph-source">SELECT Ri.Ck FROM Ri, Rt  WHERE</p><p align="justify" class="paragraph-source">  Ri.Ch = Rt.Cm AND  Ri.Cp = Rt.Cn</p><p align="justify" class="paragraph-source">-  Rt ( Cp, Cn ) = SELECT Rj.Cp, AVG (Rj.Cn) FROM  Rj</p><p align="justify" class="paragraph-source">    GROUP BY Rj.Cp</p><p align="justify" class="paragraph-source">     Разумность таких преобразований обосновывается тем, что оптимизатор получает возможность выбора большего числа способов выполнения запросов. Часто открывающиеся после преобразований способы выполнения более эффективны, чем планы, используемые в традиционном оптимизаторе. При использовании в оптимизаторе запросов подобного подхода не обязательно производить формальные преобразования запросов. </p></div><span id="lnka6aa12fe42f14e70a0ccfceafe53f00c"> </span><h2 align="left" class="paragraph-headline-source">     Семантическая оптимизация запросов</h2><span id="lnk90757d38c57148ee95307dbc2d38c2d7"> </span><div class="section"><p align="justify" class="paragraph-source">     Рассмотренные преобразования запросов основывались на семантике языка запросов, но в них не использовалась семантика базы данных, к которой адресуется запрос. Любое преобразование может быть произведено независимо от того, какая конкретная база данных имеется в виду. На самом же деле, при каждой истинно реляционной базе данных хранится и некоторая семантическая информация, определяющая, например, целостность базы данных.</p><p align="justify" class="paragraph-source">     Если говорить о базах данных, то эта информация хранится в системных каталогах базы данных в виде заданных ограничений целостности. Поскольку СУБД гарантирует целостность базы данных, то ограничения целостности можно рассматривать как аксиомы, в окружении которых формулируются запросы к базе данных.</p><p align="justify" class="paragraph-source">     Семантическая оптимизация запросов СУБД - процесс валидации и преобразования синтаксического дерева запроса в форму, пригодную для дальнейших шагов оптимизации.</p><p align="justify" class="paragraph-source">     На этой стадии выполняется:</p><p align="justify" class="paragraph-source">     а)  преобразование запросов в каноническую форму:</p><p align="justify" class="paragraph-source">          1) раскрытие представлений;</p><p align="justify" class="paragraph-source">          2) преобразование подзапросов в соединения;</p><p align="justify" class="paragraph-source">          3) спуск предикатов;</p><p align="justify" class="paragraph-source">     б) упрощение условий и распределение предикатов;</p><p align="justify" class="paragraph-source">     в) преобразование дерева условий в пути выборки.</p></div><span id="lnk982b923a9c1e456e9f0a63c43add9a20"> </span><div class="section"><p align="justify" class="paragraph-source">     <i>Преобразование запросов в каноническую форму</i></p><p align="justify" class="paragraph-source">     Запросы приводятся в каноническую форму, то есть переписываются так, чтобы они содержали минимальное количество операторов SELECT (соединение-фильтрация-проекция). Везде, где возможно, запрос должен быть приведен к форме единственного оператора SELECT. Это может позволить последующим фазам оптимизации сгенерировать значительно более эффективный (на 2-3 порядка) план выполнения для сложных запросов.</p><p align="justify" class="paragraph-source">     <i>Раскрытие представлений</i></p><p align="justify" class="paragraph-source">     Раскрытие представлений применяется для того, чтобы итоговый запрос содержал ссылки только на материализованные отношения (таблицы) и было возможным использовать конвейерную обработку данных.</p><p align="justify" class="paragraph-source">     <i>Преобразование подзапросов в соединения </i></p><p align="justify" class="paragraph-source">     Преобразование подзапросов в соединения необходимо для применения конвейерной обработки данных и минимизации объема результатов подзапросов, аккумулируемых во временной дисковой или в оперативной памяти. </p><p align="justify" class="paragraph-source">     Пример преобразования  показан в таблице 1.</p></div><span id="lnked2d7317eaa24aee9c1eb773824f1aec"> </span><div align="center"><div class="inline-table-container"><p align="left" class="unit-title">Таблица 1 - Пример преобразования</p><table class="inline-table"><col width="307" /><col width="258" /><tbody><tr><td style="background-color:#ffffff"><p align="center" class="inline-table"><b>Исходный запрос</b></p></td><td style="background-color:#ffffff"><p align="center" class="inline-table"><b>Результат</b></p></td></tr><tr><td style="background-color:#ffffff"><p align="justify" class="inline-table">select distinct T.a from T</p><p align="left" class="inline-table">where T.b in ( select T1.b from T1 where T1.c &lt; T.c)</p></td><td style="background-color:#ffffff"><p align="justify" class="inline-table">select distinct T.a</p><p align="left" class="inline-table">from T,T1 where T.b = T1.b and T1.c &lt; T.c</p></td></tr></tbody></table></div></div><span id="lnkeb0fe79928b04c6ea7f04687a4cff402"> </span><div class="section"><p align="justify" class="paragraph-source">     <i>Упрощение условий</i></p><p align="justify" class="paragraph-source">     Выполняется путем преобразования дерева логических операций в КНФ и упрощения полученной логической функции.</p><p align="justify" class="paragraph-source">     Преобразования дерева логических операций в КНФ выполняется следующим образом:     </p><p align="justify" class="paragraph-source">     Для всех дизъюнкций, входящих в прямом виде, применяется распределительный закон:</p><p align="justify" class="paragraph-source">P OR (Q AND R) = (P OR Q) AND (P OR R)</p><p align="justify" class="paragraph-source">(P AND Q) OR R = (P OR R) AND (Q OR R)</p><p align="justify" class="paragraph-source">     Для всех дизъюнкций, входящих в инверсном виде, применяется правило де Моргана:</p><p align="justify" class="paragraph-source">NOT (P OR Q) = NOT P AND NOT Q</p><p align="justify" class="paragraph-source">     Преобразование продолжается рекурсивно до тех пор, пока дерево не будет состоять из конъюнкций конституэнт 0.</p><p align="justify" class="paragraph-source">     Полученная логическая функция находится в конъюнктивной нормальной форме, но избыточна. Для упрощения применяют методы оптимизации логических функций, такие как Эспрессо или Куайна-Мак-Класки.</p></div><span id="lnk31054c8590c64b449193bc3306f15734"> </span><div class="section"><p align="justify" class="paragraph-source">     <i>Распределение предикатов</i></p><p align="justify" class="paragraph-source">     Распределение предикатов выполняется для всех предикатов вида:  </p><p align="justify" class="paragraph-source">A.B pred C для которых существует предикат A.B = D.E</p><p align="justify" class="paragraph-source">     В результате получаем предикат D.B pred C</p><p align="justify" class="paragraph-source">где C - константа; A,D - отношения; B,E - сравниваемые атрибуты. Данное упрощение выполняется на основе предположения, что исходный предикат A.B pred C может быть эффективней для отношения D.</p><p align="justify" class="paragraph-source">     Для каждого условия объединения вида:</p><p align="justify" class="paragraph-source">A.B pred D.E генерируется обратное условие D.E inversed pred A.B</p><p align="justify" class="paragraph-source">для возможности выполнить соединение в обратном порядке.</p></div><span id="lnk95f14a6dcb304a9991554e554e6c03ca"> </span><div class="section"><p align="justify" class="paragraph-source">     <i>Преобразование дерева условий в пути выборки</i></p><p align="justify" class="paragraph-source">     После упрощения дерева условий каждая конъюнкция в дереве представляет собой путь выборки. Предикаты внутри конъюнкций группируются по принадлежности к отношениям. Для получения итогового результата необходимо объединить результаты каждого из путей выборки.</p></div><span id="lnk18334fd24c244253bda2f68f198b77a5"> </span><h2 align="left" class="paragraph-headline-source">     Оценка стоимости плана запроса</h2><span id="lnk5ab17e53f63d46b0b6209dd8901d7e69"> </span><div class="section"><p align="justify" class="paragraph-source">     После генерации множества планов выполнения запроса на основе разумных стратегий декомпозиции и эффективных стратегий выполнения элементарных операций нужно выбрать один план, в соответствии с которым будет происходить реальное выполнение запроса. При неверном выборе запрос будет выполнен неэффективно. Прежде всего необходимо определить, что понимается под эффективностью выполнения запроса. Это понятие неоднозначно и зависит от специфики операционной среды СУБД. В одних условиях можно считать, что эффективность выполнения запроса определяется временем его выполнения, т.е. реактивностью системы по отношению к обрабатываемым ею запросам. В других условиях определяющей является общая пропускная способность системы по отношению к смеси параллельно выполняемых запросов. Тогда мерой эффективности запроса можно считать количество системных ресурсов, требуемых для его выполнения и т.д.</p><p align="justify" class="paragraph-source">     Следуя принятой терминологии, мы будем говорить о стоимости плана выполнения запроса, определяемой ресурсами процессора и устройств внешней памяти, которые расходуются при выполнении запроса.</p></div><span id="lnk21c1747b511147519ee2166df4b365d0"> </span><div class="section"><p align="justify" class="paragraph-source">     <i><b>Оценка числа извлекаемых строк</b></i></p><p align="justify" class="paragraph-source">     Оценка числа извлекаемых из таблицы строк используется для принятия решения о полном сканировании таблицы вместо доступа по индексу. Решение принимается на том основании, что каждое чтение листовой страницы индекса с диска влечет за собой 1 или более позиционирований и 1 или более чтений страниц таблицы. Поскольку индекс содержит ещё и нелистовые страницы, то извлечение более 0.1-1 % строк из таблицы, как правило, эффективней выполнять полным сканированием таблицы.</p><p align="justify" class="paragraph-source">     Более точная оценка получится на основе следующих показателей:</p><p align="justify" class="paragraph-source">     - число извлекаемых строк;</p><p align="justify" class="paragraph-source">     - средняя длина ключа в индексе;</p><p align="justify" class="paragraph-source">     - среднее число строк в странице индекса;</p><p align="justify" class="paragraph-source">     - длина страницы индекса;</p><p align="justify" class="paragraph-source">     - высота B*-дерева в индексе;</p><p align="justify" class="paragraph-source">     - средняя длина строки в таблице;</p><p align="justify" class="paragraph-source">     - среднее число строк в странице таблицы;</p><p align="justify" class="paragraph-source">     - длина страницы таблицы.</p><p align="justify" class="paragraph-source">     СУБД старается организовать хранение блоков данных одной таблицы последовательно с целью исключить накладные расходы на позиционирование при полном сканировании (СУБД Oracle использует предварительное выделение дискового пространства для файлов данных). Эффективность полного сканирования так же увеличивается за счёт упреждающего чтения. При упреждающем чтении СУБД одновременно выдает внешней памяти команды чтения нескольких блоков. Сканирование начинается по завершении чтения любого из блоков. Одновременно продолжается чтение остальных блоков. Эффективность достигается за счёт параллелизма чтения и сканирования.</p></div><span id="lnk194c7761c24e463aa3b1ca02d78d92c2"> </span><h2 align="left" class="paragraph-headline-source">     Статистика</h2><span id="lnk8eb7999e492d458ea0f00533604e136e"> </span><div class="section"><p align="justify" class="paragraph-source">     Для оценки потенциального числа строк, извлекаемого из таблицы, РСУБД использует статистику. Статистика имеет вид гистограмм для каждой колонки таблицы, где по горизонтали располагается шкала значений, а высотой столбца отмечается оценка числа строк в процентах от общего числа строк (см. рис. 2).</p><p align="justify" class="paragraph-source">     </p></div><span id="lnkdc05fc6e191a45b988081fb453166a6f"> </span><div class="section"><p align="center" class="paragraph-source"><img src="../res/files/jpgb53_0_.jpg" height="232px" width="427px" alt="" /> </p><p align="center" class="paragraph-source">Рисунок 2 - Гистограмма статистики</p><p align="center" class="paragraph-source">     </p><p align="justify" class="paragraph-source">     Таким образом, если из таблицы извлекаются строки со значением колонки C с ограничением [V1, V2], то можно оценить число строк, попадающих в этот интервал. Алгоритм оценки числа извлекаемых строк следующий:</p><p align="justify" class="paragraph-source">     а) определить, в какие интервалы гистограммы попадает ограничение [V1, V2];</p><p align="justify" class="paragraph-source">     б) найти оценки числа строк Ri для каждого интервала i в процентах;</p><p align="justify" class="paragraph-source">     в) если [V1, V2] попадает в некоторый интервал [S1, S2] частично или полностью лежит в интервале, то:</p><p align="justify" class="paragraph-source">          1) найти пересечение [V1, V2] и [S1, S2];</p><p align="justify" class="paragraph-source">          2) откорректировать число значений в частичном интервале (это либо Ri * (V1 - S2 + 1) / (S1 - S2 + 1), либо Ri * (S1 - V2 + 1) / (S1 - S2 + 1), либо Ri * (V1 - V2 + 1) / (S1 - S2 + 1));</p><p align="justify" class="paragraph-source">     г) иначе оценка для интервала равна Ri;</p><p align="justify" class="paragraph-source">     д) просуммировать оценки в процентах для всех интервалов;</p><p align="justify" class="paragraph-source">     е) перевести оценку в процентах в число строк.</p><p align="justify" class="paragraph-source">     Как правило, СУБД не знает и не может знать точное число строк в таблице (даже для выполнения запроса SELECT COUNT(*) FROM TABLE выполняется сканирование первичного индекса), поскольку в базе могут храниться одновременно несколько образов одной и той же таблицы с различным числом строк. Для оценки числа строк используются следующие данные:</p><p align="justify" class="paragraph-source">     - число страниц в таблице;</p><p align="justify" class="paragraph-source">     - длина страницы;</p><p align="justify" class="paragraph-source">     - средняя длина строки в таблице.</p><p align="justify" class="paragraph-source">     Статистика так же может храниться нарастающим итогом (см. рис. 3). В этом случае каждый интервал содержит суммарную оценку всех предыдущих интервалов плюс собственную оценку. Для получения оценки числа строк для ограничения [V1, V2] достаточно из оценки интервала, в который попадает V2, вычесть оценку интервала, в который попадает V1.</p><p align="justify" class="paragraph-source">     </p></div><span id="lnk22750c7bbebc43f3b243b095393484a4"> </span><div class="section"><p align="center" class="paragraph-source"><img src="../res/files/jpgb54_0_.jpg" height="232px" width="427px" alt="" /> </p><p align="center" class="paragraph-source">Рисунок 3 - Хранение статистики нарастающим итогом</p><p align="center" class="paragraph-source">     </p></div><span id="lnk13a65c897fa946c199a657fde6adfaa1"> </span><div class="section"><p align="justify" class="paragraph-source">     Сбор статистики для построения гистограмм осуществляется либо специальными командами СУБД, либо фоновыми процессами СУБД. При этом, ввиду того, что база может содержать существенный объём данных, делается выборка меньшего объёма из всей генеральной совокупности строк. Оценка репрезентативности (достоверности) выборки может осуществляться, например, по критерию согласия Колмогорова.</p><p align="justify" class="paragraph-source">     Если данные в таблице существенно изменяются в короткий промежуток времени, то статистика перестает быть актуальной и оптимизатор принимает неверные решения о полном сканировании таблиц. Режим работы базы данных должен быть спланирован таким образом, чтобы поддерживать актуальную статистику, либо не использовать оптимизацию на основе статистики.</p></div></div></td></tr></table></td></tr><tr><td id="bottomOuter"><table id="bottomInner"><tr><td class="cell1"><div> </div></td><td class="cell2"><div>© 2012 ХНУРЭ, ПИ, Широкопетлева М.С., <a href="mailto:mshirokopetleva@gmail.com">mshirokopetleva@gmail.com</a>;   ХНУРЭ, ПИ, Черепанова Ю.Ю.;   ХНУРЭ, ПИ, Мазурова О.А.<br /><a href="http://lersus.de/" title="Данный курс создан с помощью авторской системы LERSUS" target="_blank">Разработано с помощью LERSUS</a></div></td></tr></table></td></tr></table></body></html>