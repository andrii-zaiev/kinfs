<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="LERSUS 3.3.0.0" /><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Корпоративные информационные системы — Теория — Пакеты</title><script language="javascript" type="text/javascript" src="../../00/styles/files/apiwrapper.js"> </script><script language="javascript" type="text/javascript" src="../../00/styles/files/sco.js"> </script><link href="../../00/styles/files/style.css" rel="stylesheet" type="text/css" /></head><body><table id="mainOuter"><tr><td id="topOuter"><table id="topInner"><tr class="row1"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4" id="shortcuts"><div><ul class="level0"><li><a href="../../00/content/authors1.html">Авторы</a></li><li>|</li><li><a href="../../00/content/contacts1.html">Контакты</a></li><li>|</li><li><a href="../../00/content/instructions1.html">Методические указания</a></li><li>|</li><li><a href="../../00/content/annotation1.html">Аннотация</a></li><li>|</li><li><a href="#" onclick="history.back(); return false;">Назад</a></li></ul></div></td></tr><tr class="row2"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4"><div id="courseTitle">Корпоративные информационные системы</div><div id="courseSubTitle">Языки запросов к базам данных : Пакеты</div></td></tr></table></td></tr><tr><td id="contentOuter"><table id="contentInner"><tr><td class="menuOuter"><table class="menuInner"><tr><td><ul class="level0"><li><a href="../../00/styles/courses.html">Содержание курса</a></li><li><span>Теория</span></li><ul class="level1"><li><a href="../../03/content/content1.html">Оптимизация запросов</a></li><li><a href="../../03/content/content2.html">Окружение 4-го поколения</a></li><li><a href="../../03/content/content3.html">Язык PL / SQL. Общие положения </a></li><li><a href="../../03/content/content4.html">Переменные и константы. Кодовое множество</a></li><li><a href="../../03/content/content5.html">Типы данных</a></li><li><a href="../../03/content/content6.html">Команды управления</a></li><li><a href="../../03/content/content7.html">Создание хранимых процедур и функций </a></li><li><a href="../../03/content/content8.html">Параметры подпрограмм</a></li><li><a href="../../03/content/content9.html">Встроенные функции PL / SQL</a></li><li><a href="../../03/content/content10.html">Курсоры</a></li><li><a href="../../03/content/content11.html">Исключительные ситуации</a></li><li><a href="../../03/content/content12.html">Обработчики исключений </a></li><li><a href="../../03/content/content13.html">Пакеты</a></li><li><a href="../../03/content/content14.html">Триггеры объектов </a></li></ul><li><span>Практика</span></li><ul class="level1"><li><a href="../../03/content/example1.html">Практика 2. Использование подпрограмм в языках  программирования 4-го поколения</a></li><li><a href="../../03/content/example2.html">Лабораторная работа 2 Подпрограммы как средство создания серверных частей информационных систем на примере СУБД Oracle </a></li><li><a href="../../03/content/example3.html">Практика 3. Создание  и работа с триггерами объектов и событий</a></li><li><a href="../../03/content/example4.html">Лабораторная работа 3. Триггеры объектов и событий базы данных </a></li></ul><li><span>Текущий контроль знаний</span></li><ul class="level1"><li><a href="../../03/content/multiply-choice-test25.html">Управляющие структуры</a></li><li><a href="../../03/content/multiply-answers-test7.html">Подпрограммы языка PL/SQL</a></li><li><a href="../../03/content/multiply-choice-test1.html">Курсоры</a></li><li><a href="../../03/content/multiply-answers-test12.html">Исключительные ситуации</a></li><li><a href="../../03/content/multiply-choice-test19.html">Пакеты</a></li><li><a href="../../03/content/multiply-answers-test3.html">Триггеры</a></li></ul><li><a href="../../03/styles/glossary.html">Словарь терминов</a></li><li><a href="../../03/03.pdf" target="_blank">Версия для печати</a></li></ul></td></tr></table></td><td class="content"><div id="content"><div id="topBlankStripe"> </div><span id="lnk0d50b6104ff047b7aed71cb82901fd3e"> </span><h1 align="left" class="headline-source">     Пакеты</h1><span id="lnka2605b7c078e4cb9a96a9460bde61eac"> </span><div class="section"><p align="justify" class="paragraph-source">     <i><b>Пакет</b></i> - это объект базы данных, который группирует логически связанные типы, программные объекты и подпрограммы PL/SQL. Пакеты обычно состоят из двух частей, спецификации и тела, хотя иногда в теле нет необходимости. </p><p align="justify" class="paragraph-source">     <i><b>Спецификация пакета </b></i>- это интерфейс с вашими приложениями; она объявляет типы, переменные, константы, исключения, курсоры и подпрограммы, доступные для использования в пакете. </p><p align="justify" class="paragraph-source">     <i><b>Тело пакета  </b></i>полностью определяет курсоры и подпрограммы, тем самым реализуя спецификацию пакета. В отличие от подпрограмм, пакеты нельзя вызывать, передавать им параметры или вкладывать их друг в друга. </p><p align="justify" class="paragraph-source">     В остальном формат пакета аналогичен формату подпрограммы: </p><p align="left" class="paragraph-source">PACKAGE имя IS -- спецификация (видимая часть) <br />-- объявления общих типов и объектов <br />-- спецификации подпрограмм <br />END [имя]; <br />PACKAGE BODY имя IS -- тело (скрытая часть) <br />-- объявления личных типов и объектов <br />-- тела подпрограмм <br />[BEGIN <br />-- предложения инициализации] <br />END [имя]; </p></div><span id="lnk37173cb2622f44a7aeed3cb9a3c29858"> </span><div class="section"><p align="justify" class="paragraph-source">     Спецификация содержит <i><b>общие</b></i> объявления, которые видимы вашему приложению. </p><p align="justify" class="paragraph-source">     Тело содержит детали реализации и <i><b>личные</b></i> объявления, которые скрыты от вашего приложения. Представляйте себе спецификацию как функциональный интерфейс, а тело - как "черный ящик" </p><p align="justify" class="paragraph-source">     Пакеты создаются интерактивно в SQL*Plus или SQL*DBA с помощью команд CREATE PACKAGE и CREATE PACKAGE BODY . </p><p align="justify" class="paragraph-source">     В следующем примере пакетируются тип записи, курсор и две процедуры работы с товарами: </p><p align="left" class="paragraph-source">CREATE PACKAGE p_goods AS -- спецификация <br />TYPE Good_RecTyp IS RECORD (goods_id INTEGER, Volume Real, Price REAL); <br />CURSOR Goods_cur RETURN Good_RecTyp; <br />PROCEDURE change_price (goods_id1 NUMBER, price1 NUMBER); <br />PROCEDURE delete_ (goods_id1 NUMBER); <br />END p_goods; </p><p align="left" class="paragraph-source">CREATE PACKAGE BODY p_goods AS -- тело <br />CURSOR Goods_cur RETURN Good_RecTyp IS <br />SELECT goods_id, Volume, Price FROM goods; <br />PROCEDURE change_price (goods_id1 NUMBER, price1 NUMBER) IS </p><p align="left" class="paragraph-source">BEGIN <br />UPDATE goods SET price = price1 WHERE goods_id = goods_id1; <br />END change _ price ; <br />PROCEDURE delete_ (goods_id1 NUMBER) IS <br />BEGIN <br />DELETE FROM goods WHERE goods_id = goods_id1; <br />END delete_; <br />END p_goods; </p><p align="justify" class="paragraph-source">     Видимыми и доступными для приложений являются лишь объявления в спецификации пакета. Детали реализации в теле пакета скрыты и недоступны. Поэтому вы можете исправлять тело (реализацию), не перекомпилируя вызывающих программ. </p></div><span id="lnk3dbf4a17b60c457ba5d98e48e55db048"> </span><h2 align="left" class="paragraph-headline-source">     Спецификация пакета </h2><span id="lnk9213693cd2b5432c9f686142614db25d"> </span><div class="section"><p align="justify" class="paragraph-source">     Спецификация пакета содержит общие объявления. Сфера этих объявлений локальна для вашей схемы в базе данных и глобальна для самого пакета. Таким образом, объявленные объекты доступны из вашего приложения и из любого места в пакете. </p><p align="justify" class="paragraph-source">     Спецификация перечисляет ресурсы пакета, доступные приложениям. Она содержит всю информацию, необходимую вашему приложению для использования этих ресурсов. </p><p align="justify" class="paragraph-source">     Например, следующее объявление показывает, что функция с именем fac принимает один аргумент типа INTEGER и возвращает значение типа INTEGER: </p><p align="left" class="paragraph-source">FUNCTION fac (n INTEGER) RETURN INTEGER; -- возвращает n! </p><p align="justify" class="paragraph-source">     Это вся информация, необходимая вам для вызова данной функции. Вам нет необходимости рассматривать фактическую реализацию функции fac (например, итеративна она или рекурсивна). </p><p align="justify" class="paragraph-source">     Только подпрограммы и курсоры имеют реализацию, или ОПРЕДЕЛЕНИЕ. Поэтому, если спецификация пакета объявляет лишь типы, константы, переменные и исключения, тело пакета не нужно. </p></div><span id="lnkda7f6e9ea2654565bc11ad10941bc6be"> </span><div class="section"><p align="left" class="paragraph-source">     Приведем пример такого пакета: </p><p align="left" class="paragraph-source">-- пакет, состоящий только из спецификации <br />PACKAGE opt_data IS <br />TYPE TimeTyp IS RECORD (minute SMALLINT, hour SMALLINT); <br />TYPE DateTyp IS RECORD (day INTEGER, mounth VARCHAR2, year INTEGER, time TimeTyp); <br />min_quant CONSTANT INTEGER := 10; <br />max_volume REAL:=1000.00; <br />not_type_storage EXCEPTION; <br />END opt _ data ; </p><p align="justify" class="paragraph-source">     Пакет opt _ data не нуждается в теле, потому что типы, константы, переменные и исключения не требуют реализации. Такие пакеты позволяют вам определять глобальные переменные - для использования подпрограммами и триггерами - которые существуют на протяжении всей сессии. </p></div><span id="lnk515cca79131640c39ff1db555f89bfa4"> </span><h2 align="left" class="paragraph-headline-source">     Обращение к содержимому пакета </h2><span id="lnk1a009b05bf5e4bb0ab2edd0d51832972"> </span><div class="section"><p align="justify" class="paragraph-source">     Для обращения к типам, объектам и подпрограммам, объявленным в спецификации пакета, используются квалифицированные ссылки: </p><p align="left" class="paragraph-source">имя_пакета.имя_типа </p><p align="left" class="paragraph-source">имя_пакета.имя_объекта </p><p align="left" class="paragraph-source">имя_пакета.имя_подпрограммы </p><p align="justify" class="paragraph-source">     Вы можете обращаться к содержимому пакета из триггеров базы данных, хранимых подпрограмм, встроенных блоков PL/SQL, а также анонимных блоков PL/SQL, посылаемых в ORACLE интерактивно через SQL*Plus или SQL*DBA. </p><p align="justify" class="paragraph-source">     В следующем примере вы обращаетесь к пакетированной переменной max _ volume, которая объявлена в пакете opt _ data : </p><p align="left" class="paragraph-source">DECLARE <br />new_volume REAL; <br />... <br />BEGIN <br />... <br />IF new_volume &gt; max_volume THEN <br />... <br />END IF; <br />... <br />END; </p></div><span id="lnkd581be4105594a6ba3ce2ce04644eb56"> </span><h2 align="left" class="paragraph-headline-source">     Тело пакета </h2><span id="lnk64b10436d6ef44a8afad2cd1924280f3"> </span><div class="section"><p align="justify" class="paragraph-source">     Тело пакета реализует спецификацию пакета. Оно содержит определения всех курсоров и подпрограмм, объявленных в спецификации пакета. Не забывайте, что любая подпрограмма, определенная в теле пакета, доступна извне пакета лишь в том случае, если ее спецификация также появляется в спецификации пакета. Тело пакета может также содержать личные объявления, которые определяют типы и объекты, необходимые для внутренней работы пакета. Сфера таких объявлений локальна в теле пакета. Поэтому объявленные здесь типы и объекты недоступны нигде, кроме тела пакета. В отличие от спецификации пакета, декларативная часть тела пакета может содержать тела подпрограмм. За декларативной частью тела пакета может следовать необязательная часть инициализации, которая обычно содержит предложения, инициализирующие некоторые из переменных, ранее объявленных в пакете. Часть инициализации пакета не играет большой роли, потому что, в отличие от подпрограмм, пакет нельзя вызывать или передавать ему параметры. Следовательно, часть инициализации пакета отрабатывает лишь один раз, при первом обращении к пакету. </p></div><span id="lnk1a33e71a452a46de80b4bdcde1661409"> </span><h2 align="left" class="paragraph-headline-source">     Преимущества пакетов </h2><span id="lnkcf1044490c474805806d6f197847f67a"> </span><div class="section"><p align="justify" class="paragraph-source">     Пакеты предлагают несколько преимуществ: модульность, облегчение проектирования приложений, скрытие информации, расширенная функциональность и лучшая производительность. </p></div><span id="lnkd3f97587295e438681e0cddd320c82f5"> </span><div id="see-mored3f97587295e438681e0cddd320c82f5" class="additional"><table border="0"><tr><td><img src="../../00/styles/files/seecollapsed.gif" alt="Смотрите также:" title="Смотрите также:" class="collapse-img" style="width:16px; height:16px;" /></td><td><a href="javascript:seeMore('d3f97587295e438681e0cddd320c82f5');" class="paragraph-source">Смотрите также:</a></td></tr></table><div style="display:none;"><p align="justify" class="note-source">     <b>Модульность </b></p><p align="justify" class="note-source">     Пакеты позволяют вам инкапсулировать логически связанные типы, объекты и подпрограммы в поименованный модуль PL/SQL. Каждый пакет легко понять, а интерфейсы между пакетами просты, ясны и хорошо определены. Это облегчает разработку приложений. </p><p align="justify" class="note-source">     <b>Облегчение проектирования </b></p><p align="justify" class="note-source">     Все, что вам надо изначально знать при проектировании приложения - это информация интерфейса для спецификации пакета. Вы можете кодировать и компилировать спецификацию без тела. После того, как спецификация откомпилирована, хранимые подпрограммы, обращающиеся к пакету, также могут быть откомпилированы. Вы не обязаны полностью определять тела пакетов до тех пор, пока не будете готовы к реализации деталей приложения. </p><p align="justify" class="note-source">     <b>Скрытие информации </b></p><p align="justify" class="note-source">     С помощью пакетов вы можете указывать, какие типы, объекты и подпрограммы являются общими (видимыми и доступными) или личными (скрытыми и недоступными). Например, если пакет содержит четыре подпрограммы, то три из них могут быть общими, а одна личной. Пакет скрывает определение личной подпрограммы, так что лишь этот пакет, а не ваши приложения, будет затронут, если это определение изменится. Это упрощает сопровождение и развитие. Кроме того, скрывая детали реализации от пользователей, вы защищаете целостность вашей базы данных. </p><p align="justify" class="note-source">     <b>Расширенная функциональность</b></p><p align="justify" class="note-source">     Пакетированные общие переменные и курсоры продолжают существовать в течение всей сессии. Поэтому они могут совместно использоваться всеми процедурами, выполняющимися в данном окружении. Кроме того, через них можно передавать данные между транзакциями без необходимости записывать такие данные в базу данных. </p><p align="justify" class="note-source">     <b>Улучшенная производительность </b></p><p align="justify" class="note-source">     Когда вы вызываете пакетированную подпрограмму первый раз, в память загружается весь пакет. Поэтому последующие вызовы других подпрограмм этого пакета не требуют операций ввода-вывода. Помимо этого, пакеты останавливают каскадные зависимости, и тем самым избегают излишних перекомпиляций. Например, когда вы изменяете определение независимой функции, ORACLE должен перекомпилировать все хранимые подпрограммы, которые вызывают эту функцию. Однако, когда вы изменяете определение пакетированной функции, перекомпиляция вызывающих подпрограмм не требуется, потому что они не зависят от тела пакета. </p></div></div><span id="lnkf5dc11f73d994f7c8d3107332d0b49ef"> </span><h2 align="left" class="paragraph-headline-source">     Применения пакетов </h2><span id="lnkd88624202b884e15a8eeba62f3dc6875"> </span><div class="section"><p align="justify" class="paragraph-source">     Пакеты используются для определения взаимосвязанных процедур, переменных и курсоров. С помощью пакетов часто достигаются преимущества в следующих областях: </p><p align="justify" class="paragraph-source">     - инкапсуляция связанных процедур и переменных; </p><p align="justify" class="paragraph-source">     - разделение спецификации пакета и тела этого пакета; </p><p align="justify" class="paragraph-source">     - объявление общих и личных процедур, переменных, констант и курсоров; </p><p align="justify" class="paragraph-source">     - определение переменных, сохраняющих значение между вызовами; </p><p align="justify" class="paragraph-source">     - улучшение производительности. </p></div><span id="lnk233908973e83498e8ca60de876f66685"> </span><div id="see-more233908973e83498e8ca60de876f66685" class="additional"><table border="0"><tr><td><img src="../../00/styles/files/seecollapsed.gif" alt="Смотрите также:" title="Смотрите также:" class="collapse-img" style="width:16px; height:16px;" /></td><td><a href="javascript:seeMore('233908973e83498e8ca60de876f66685');" class="paragraph-source">Смотрите также:</a></td></tr></table><div style="display:none;"><p align="justify" class="note-source">     <b>Инкапсуляция </b></p><p align="justify" class="note-source">     Пакеты позволяют вам инкапсулировать логически связанные типы данных, хранимые процедуры, переменные и т.д. в единую поименованную единицу, хранящуюся в базе данных. Каждый пакет легко понять, а интерфейсы между пакетами просты, ясны и хорошо определены. Это облегчает разработку приложений. Инкапсуляция процедурных конструктов в пакет также облегчает управление привилегиями. Назначение привилегии на использование пакета делает все конструкты в этом пакете доступными тому, кто получает привилегию. </p><p align="justify" class="note-source">     <b>Общие и личные данные и процедуры </b></p><p align="justify" class="note-source">     С помощью пакетов вы можете указывать, какие типы, объекты и подпрограммы являются: </p><p align="justify" class="note-source">     - общими (Непосредственно видимыми пользователю пакета); </p><p align="justify" class="note-source">     - личными (Скрытыми от пользователя пакета).      </p><p align="justify" class="note-source">     Например, пакет может содержать десять процедур. Однако этот пакет может быть определен так, что лишь три процедуры являются общими, и потому доступными для выполнения пользователю пакета; остальные процедуры являются личными, и могут использоваться лишь процедурами внутри самого пакета. </p><p align="justify" class="note-source">     <b>Сравнение личных и общих объектов </b></p><p align="justify" class="note-source">     Если в теле пакета объявляется переменная, то она может использоваться только внутри пакета. Следовательно, код PL/SQL вне пакета не может обращаться к этой переменной. Такие элементы называются ЛИЧНЫМИ. Однако элементы, объявленные в спецификации пакета являются видимыми вне пакета. Следовательно, код PL/SQL вне пакета может обращаться к таким элементам. Такие элементы называются ОБЩИМИ. Если вам надо поддерживать какие-нибудь элементы на протяжении всей сессии или между транзакциями, помещайте их в декларативную часть тела пакета. Если вы должны сделать какие-нибудь элементы общими, помещайте их в спецификацию пакета. </p><p align="justify" class="note-source">     <b>Разделение спецификации и тела пакета </b></p><p align="justify" class="note-source">     Пакет создается из двух частей: спецификации и тела. </p><p align="justify" class="note-source">     <b>Спецификация пакета </b>объявляет все общие конструкты этого пакета, а тело определяет все конструкты (как общие, так и личные). Это разделение на две части предоставляет следующие преимущества: </p><p align="justify" class="note-source">     - Определяя спецификацию пакета отдельно от тела пакета, разработчик получает большую гибкость в цикле разработки. После создания спецификации к общим процедурам можно обращаться еще до того, как создано тело пакета.      </p><p align="justify" class="note-source">     - Тела процедур, содержащиеся в теле пакета, можно изменять независимо от из публично объявленных спецификаций в спецификации пакета. Пока не изменяется сама спецификация процедуры, объекты, которые обращаются к изменяющимся процедурам, никогда не помечаются как недействительные; иными словами, они никогда не требуют перекомпиляции. </p><p align="justify" class="note-source">     <b>Улучшение производительности </b>     </p><p align="justify" class="note-source">     Использование пакетов вместо независимых хранимых процедур дает следующие преимущества: </p><p align="justify" class="note-source">     - Когда вы вызываете пакетированную подпрограмму первый раз, в память загружается весь пакет. Эта загрузка выполняется за одну операцию, в отличие от отдельных загрузок, требуемых для независимых процедур. Поэтому последующие вызовы других подпрограмм этого пакета не требуют операций ввода-вывода.</p><p align="justify" class="note-source">      - Тело пакета можно заменять и перекомпилировать, не затрагивая его спецификацию. Как следствие, объекты, которые обращаются к конструктам пакета (всегда через его спецификацию), никогда не требуют перекомпиляции, пока не будет изменена также спецификация пакета. Благодаря пакетам, количество перекомпиляций может быть минимизировано, что улучшает общую производительность базы данных. </p></div></div><span id="lnk2bb8792b8eca473295f1bd1bb5bfeb0a"> </span><h2 align="left" class="paragraph-headline-source">     Как ORACLE хранит процедуры и пакеты </h2><span id="lnke3c54c5572ea4ecaa89c2588f4e713c3"> </span><div class="section"><p align="justify" class="paragraph-source">     Хранимые процедуры, определенные вне контекста пакета, называются независимыми процедурами. Процедуры, определенные внутри пакета (пакетированные), рассматриваются как часть пакета. </p><p align="justify" class="paragraph-source">     Когда вы создаете процедуру или пакет, ORACLE автоматически выполняет следующие шаги: </p><p align="justify" class="paragraph-source">     а) Компилирует процедуру или пакет. </p><p align="justify" class="paragraph-source">     б) Сохраняет откомпилированный код в основной памяти. </p><p align="left" class="paragraph-source">     в) Сохраняет процедуру или пакет в базе данных. </p></div><span id="lnk45b9c2675d774a5dba168bd896d69f06"> </span><div id="see-more45b9c2675d774a5dba168bd896d69f06" class="additional"><table border="0"><tr><td><img src="../../00/styles/files/seecollapsed.gif" alt="Смотрите также:" title="Смотрите также:" class="collapse-img" style="width:16px; height:16px;" /></td><td><a href="javascript:seeMore('45b9c2675d774a5dba168bd896d69f06');" class="paragraph-source">Смотрите также:</a></td></tr></table><div style="display:none;"><p align="justify" class="note-source">     <b>Компиляция процедур и пакетов </b></p><p align="justify" class="note-source">     Компиляцию исходного кода осуществляет компилятор PL/SQL. Этот компилятор является частью процессора PL/SQL, содержащегося в ORACLE. Если по время компиляции происходит ошибка, то возвращается сообщение об ошибке. </p><p align="justify" class="note-source">     <b>Сохранение откомпилированного кода в памяти </b></p><p align="justify" class="note-source">     ORACLE кэширует откомпилированную процедуру или пакет в разделяемом пуле в области SGA. Это позволяет быстро исполнять откомпилированный код и использовать его совместно всеми пользователями. Откомпилированная версия процедуры или пакета остается в разделяемом пуле столько, сколько это позволит алгоритм LRU, даже если первоначальный создатель процедуры закончит свою сессию. </p><p align="justify" class="note-source">     <b>Сохранение процедур и пакетов в базе данных </b></p><p align="justify" class="note-source">     Во время создания и компиляции процедуры или пакета ORACLE автоматически сохраняет в базе данных следующую информацию: имя объекта ORACLE использует это имя для идентификации процедуры или пакета. Вы задаете это имя в предложениях CREATE PROCEDURE , CREATE FUNCTION , CREATE PACKAGE и CREATE PACKAGE BODY . исходный код Компилятор PL/SQL разбирает исходный код и и дерево генерирует разобранное представление исходного разбора кода, называемое ДЕРЕВОМ РАЗБОРА. псевдокод Компилятор PL/SQL генерирует ПСЕВДОКОД, или (P-код) P-код, на основе разобранного кода. Процессор PL/SQL исполняет этот код при вызове процедуры или пакета. сообщения ORACLE может генерировать ошибки во время об ошибках компиляции процедуры или пакета. Чтобы избежать излишних перекомпиляций процедуры или пакета, в базе данных сохраняются как дерево разбора, так и псевдокод объекта. Это позволяет процессору PL/SQL при обращении к процедуре или пакету прочитать откомпилированную версию в разделяемый пул в SGA, если его еще нет в SGA. Дерево разбора используется при компиляции кода, вызывающего процедуру. Все части процедур базы данных сохраняются в табличном пространстве SYSTEM (словаре данных) соответствующей базы данных. Администратор базы данных должен планировать размер табличного пространства SYSTEM, имея в виду, что все хранимые процедуры требуют места в этом табличном пространстве.</p></div></div><span id="lnkd4f4fa77f44b411eb621b6461d755ef0"> </span><h2 align="left" class="paragraph-headline-source">     Как ORACLE исполняет процедуры и пакеты </h2><span id="lnk82afeff38bb145b5beb4e788ed92957b"> </span><div class="section"><p align="left" class="paragraph-source">     Когда вызывается независимая или пакетированная процедура, ORACLE выполняет следующие шаги: </p><p align="left" class="paragraph-source">     а) Проверяет права пользователя. </p><p align="left" class="paragraph-source">     б) Проверяет действительность процедуры. </p><p align="left" class="paragraph-source">     в) Исполняет процедуру. </p></div><span id="lnk46448cdfd4f54142b977b82cdc7e453d"> </span><div id="see-more46448cdfd4f54142b977b82cdc7e453d" class="additional"><table border="0"><tr><td><img src="../../00/styles/files/seecollapsed.gif" alt="Смотрите также:" title="Смотрите также:" class="collapse-img" style="width:16px; height:16px;" /></td><td><a href="javascript:seeMore('46448cdfd4f54142b977b82cdc7e453d');" class="paragraph-source">Смотрите также:</a></td></tr></table><div style="display:none;"><p align="justify" class="note-source">     <b>Проверка прав пользователя </b></p><p align="justify" class="note-source">     ORACLE проверяет, что вызывающий пользователь владеет вызываемой процедурой или имеет привилегию EXECUTE для процедуры или объемлющего ее пакета. Пользователю, вызывающему процедуру, не требуется привилегий доступа к процедурам или объектам, к которым есть обращения в данной процедуре; такие привилегии требуются лишь для владельца процедуры или пакета. </p><p align="justify" class="note-source">     <b>Проверка действительности процедуры</b></p><p align="justify" class="note-source">      ORACLE проверяет состояние процедуры или пакета в словаре данных на действительность. Объект (процедура или пакет) помечается как НЕДЕЙСТВИТЕЛЬНЫЙ, если после последней компиляции этого объекта произошло одно из следующих событий: </p><p align="justify" class="note-source">     - Хотя бы один из объектов (таблиц, обзоров, других процедур), к которым обращается процедура, был изменен (ALTER) или удален (DROP). (Например, вы добавили в таблицу столбец.) </p><p align="justify" class="note-source">     - Системная привилегия была отобрана у PUBLIC или у владельца процедуры или пакета. </p><p align="justify" class="note-source">     - Привилегия объекта для одного или нескольких объектов, к которым обращается процедура или пакет, была отобрана у PUBLIC или у владельца процедуры или пакета. Процедура ДЕЙСТВИТЕЛЬНА, если она не была отмечена как недействительная по одной из перечисленных выше причин. Если вызывается действительная независимая или пакетированная процедура, то исполняется ее откомпилированный код. Если вызывается недействительная независимая или пакетированная процедура, то она автоматически перекомпилируется перед исполнением. </p><p align="justify" class="note-source">     <b>Исполнение процедуры </b></p><p align="justify" class="note-source">     Процессор PL/SQL исполняет процедуру или пакет различными методами, в зависимости от ситуации: </p><p align="justify" class="note-source">     - Если процедура действительна и сейчас находится в памяти, то процессор PL/SQL просто исполняет ее псевдокод.      </p><p align="justify" class="note-source">     - Если процедура действительна, но сейчас не находится в памяти, то процессор PL/SQL загружает с диска в память ее откомпилированный псевдокод и исполняет его. В случае пакета, загружаются все конструкты пакета (т.е. все процедуры, переменные и т.п., которые были откомпилированы как единица кода). Процессор PL/SQL обрабатывает процедуру предложение за предложением, исполняя все процедурные предложения самостоятельно и передавая предложения SQL исполнителю предложений SQL. </p></div></div><span id="lnkd390914165134a2895fa7f3515644ffe"> </span><h2 align="left" class="paragraph-headline-source">     Пакетированные курсоры </h2><span id="lnka35ffcc8b2b843bda227285d647dfcb9"> </span><div class="section"><p align="justify" class="paragraph-source">     При помещении курсора в пакет вы можете отделить спецификацию курсора от его тела, используя фразу RETURN, как показывает следующий пример: </p><p align="left" class="paragraph-source">CREATE PACKAGE audit_actions AS <br />/* Объявить спецификацию курсоров */ <br />CURSOR c1 RETURN goods%ROWTYPE; <br />CURSOR c2 RETURN warehouses%ROWTYPE; <br />CURSOR c3 RETURN storages%ROWTYPE; <br />... <br />END audit_actions; <br />CREATE PACKAGE BODY audit_actions AS <br />/* Определить тела курсоров */ <br />CURSOR c1 RETURN goods%ROWTYPE SELECT * FROM goods WHERE goods_id &gt; 100; <br />CURSOR c2 RETURN warehouses%ROWTYPE SELECT * FROM warehouses WHERE ware_id &gt; 10; <br />CURSOR c3 RETURN storages%ROWTYPE SELECT * FROM storages WHERE storage_id &gt; 1000; <br />... <br />END audit _actions; </p><p align="justify" class="paragraph-source">     Это позволит вам изменять тело курсора, не затрагивая его спецификацию. Так, в последнем примере можно было бы изменить фразу WHERE : </p><p align="justify" class="paragraph-source">CURSOR c1 RETURN goods%ROWTYPE SELECT * FROM goods WHERE goods_id =115; </p><p align="justify" class="paragraph-source">     В спецификации курсора отсутствует предложение SELECT, потому что фразы RETURN достаточно, чтобы определить тип данных результирующего значения. Вы можете использовать в фразе RETURN атрибут %ROWTYPE, чтобы указать тип записи, которая будет представлять строку в таблице базы данных. Вы также можете использовать в фразе RETURN атрибут %TYPE, чтобы указать тип данных переменной, константы или столбца базы данных. Тело курсора должно содержать предложение SELECT, а также точно такую же фразу RETURN, как и в спецификации курсора. Более того, количество и типы данных элементов списка в предложении SELECT должны соответствовать фразе RETURN. </p></div><span id="lnka28ca6f89e2047978f0ce3c1e426d5d0"> </span><h2 align="left" class="paragraph-headline-source">     Перекрытие имен </h2><span id="lnke9b2f967a2e64b82929531946454841a"> </span><div class="section"><p align="justify" class="paragraph-source">     PL/SQL позволяет двум или нескольким пакетированным подпрограммам иметь одно и то же имя. Эта возможность полезна, когда вы хотите, чтобы подпрограмма могла принимать параметры, принадлежащие разным типам данных. </p><p align="justify" class="paragraph-source">     Например, следующий пакет определяет две процедуры с именем date _ storages : </p><p align="left" class="paragraph-source">PACKAGE storages_date IS <br />PROCEDURE date_storages (stor_id NUMBER, stor_date CHAR); <br />PROCEDURE date_storages (stor_id NUMBER, stor_date NUMBER); <br />END storages_date; <br />PACKAGE BODY storages_date IS <br />PROCEDURE date_storages (stor_id NUMBER, stor_date CHAR) IS <br />BEGIN <br />UPDATE storages SET begin_time= TO_DATE(stor_date, 'DD-MON-YYYY') <br />WHERE srorage_id=stor_id; <br />END date_storages; <br />PROCEDURE date_storages (stor_id NUMBER, stor_date NUMBER) IS <br />BEGIN <br />UPDATE storages SET begin_time= TO_DATE(stor_date, 'J') <br />WHERE srorage_id=stor_id; <br />END date_storages; <br />END storages_date; </p><p align="justify" class="paragraph-source">     Первая процедура принимает дату stor _ date как строку символов, тогда как вторая - как число (юлианский день). Тем не менее, обе процедуры обрабатывают эти данные как следует. </p></div><span id="lnk78ae1470046b474482943844378c2f34"> </span><h2 align="left" class="paragraph-headline-source">     Вызов пакетированных подпрограмм </h2><span id="lnke8e9e56a050947cea54e64d2ec769260"> </span><div class="section"><p align="justify" class="paragraph-source">     Пакетированные подпрограммы должны вызываться с помощью квалифицированной ссылки, как показывает следующий пример: </p><p align="justify" class="paragraph-source">storages_date.date_storages (4, '12-MAY-2003'); </p><p align="justify" class="paragraph-source">     Это указывает компилятору PL / SQL , что date _ storages находится в пакете storages _ date. Вы можете вызывать пакетированные подпрограммы из триггера базы данных, другой хранимой подпрограммы, приложения прекомпилятора ORACLE, приложения OCI, или из инструмента ORACLE, такого как SQL*Plus. </p></div><span id="lnkef8910f5ac3344a9a75254be874d52fc"> </span><div id="see-moreef8910f5ac3344a9a75254be874d52fc" class="additional"><table border="0"><tr><td><img src="../../00/styles/files/seecollapsed.gif" alt="Смотрите также:" title="Смотрите также:" class="collapse-img" style="width:16px; height:16px;" /></td><td><a href="javascript:seeMore('ef8910f5ac3344a9a75254be874d52fc');" class="paragraph-source">Смотрите также:</a></td></tr></table><div style="display:none;"><p align="left" class="note-source">     <b>Из другой хранимой подпрограммы </b></p><p align="justify" class="note-source">     Хранимая подпрограмма может вызывать пакетированную подпрограмму. Например, в независимой подпрограмме может появиться следующий вызов пакетированной процедуры date _ storages : </p><p align="justify" class="note-source">storages_date.date_storages (4, '12-MAY-2003'); </p><p align="justify" class="note-source">     <b>Из инструмента ORACLE </b></p><p align="justify" class="note-source">     Вы можете вызывать пакетированные подпрограммы интерактивно из инструментов ORACLE, таких как SQL*Plus, SQL*Forms или SQL*DBA. Например, из SQL*Plus вы могли бы вызвать пакетированную процедуру hire_employee следующим образом: </p><p align="justify" class="note-source">SQL&gt; EXECUTE storages_date.date_storages (4, '12-MAY-2003'); </p><p align="justify" class="note-source">     <b>Удаленный доступ </b></p><p align="justify" class="note-source">     Для вызова пакетированных подпрограмм, хранимых в удаленной базе данных ORACLE, используйте следующий синтаксис: </p><p align="justify" class="note-source">имя_пакета.имя_подпрограммы@связьБД(параметр1, параметр2, ...); </p><p align="justify" class="note-source">     В следующем примере вызывается пакетированная процедура date _ storages , определенная в пакете storages _ date в базе данных newyork : storages_date.date_storages@newyork(4, '12-MAY-2003'); </p><p align="justify" class="note-source">     <i>Ограничение </i></p><p align="justify" class="note-source">     Тело пакетированной подпрограммы может содержать любое предложение SQL или PL/SQL. Однако подпрограммы, участвующие в распределенной транзакции, триггерах базы данных и приложениях SQL*Forms, не могут вызывать пакетированных подпрограмм, содержащих предложения COMMIT, ROLLBACK или SAVEPOINT. </p></div></div><span id="lnka6d735ed1b134a1c9c61bdb37860c2ed"> </span><h2 align="left" class="paragraph-headline-source">     Состояния пакетов и зависимости </h2><span id="lnkc9d724aa29384d7e96a94d37f6f88241"> </span><div class="section"><p align="justify" class="paragraph-source">     Спецификация пакета всегда находится в одном из двух состояний: действительна или недействительна. </p><p align="justify" class="paragraph-source">     Спецификация пакета ДЕЙСТВИТЕЛЬНА, если ни ее исходный код, ни любой из объектов, к которым она обращается, не был ни удален (DROP), ни заменен (REPLACE), ни изменен (ALTER) с момента последней компиляции этой спецификации. </p><p align="justify" class="paragraph-source">     С другой стороны, спецификация пакета НЕДЕЙСТВИТЕЛЬНА, если ее исходный код или любой из объектов, к которым она обращается, был либо удален (DROP), либо заменен (REPLACE), либо изменен (ALTER) с момента последней компиляции этой спецификации. </p><p align="justify" class="paragraph-source">     Когда ORACLE помечает спецификацию пакета как недействительную, он также помечает как недействительные все объекты, обращающиеся к этому пакету. К телу пакета применяются те же правила, с той разницей, что ORACLE может перекомпилировать тело пакета, НЕ помечая его спецификацию как недействительную. Эта возможность позволяет ограничить каскад перекомпиляций, вызываемых зависимостями. </p></div><span id="lnk80e1bd581d97490292cfb2a86b2efc1e"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Зависимости </b></p></div><span id="lnkeb32c88d3a5541ccb07737d2d5b00412"> </span><div class="section"><p align="justify" class="paragraph-source">     Когда спецификация пакета перекомпилируется, ORACLE помечает зависимые объекты как недействительные. К таким объектам относятся независимые или пакетированные подпрограммы, которые вызывают или обращаются к объектам, объявленным в перекомпилируемой спецификации пакета. </p><p align="justify" class="paragraph-source">     Когда вы вызовете или обратитесь к зависимому, но еще не перекомпилированному, объекту, ORACLE автоматически перекомпилирует его во время выполнения. Когда перекомпилируется тело пакета, ORACLE определяет, действительны ли объекты, от которых зависит тело пакета. К таким объектам относятся независимые подпрограммы и спецификации пакетов, к которым существуют обращения из процедур или курсоров, определенных в перекомпилируемом теле пакета. </p><p align="justify" class="paragraph-source">     Если среди таких объектов есть недействительные, ORACLE перекомпилирует их, прежде чем перекомпилировать тело пакета. Если все перекомпиляции успешны, тело пакета становится действительным. В противном случае ORACLE возвращает ошибку выполнения, а тело пакета остается недействительным. </p><p align="justify" class="paragraph-source">     Ошибки компиляции сохраняются в словаре данных вместе с пакетом. ORACLE хранит спецификацию и тело пакета раздельно в словаре данных. Другие объекты, которые вызывают глобальные объекты данного пакета или обращаются к ним, зависят только от спецификации пакета. Поэтому вы можете переопределять объекты в теле пакета (что приведет к перекомпиляции тела), не нарушая действительности зависимых объектов. </p></div></div></td></tr></table></td></tr><tr><td id="bottomOuter"><table id="bottomInner"><tr><td class="cell1"><div> </div></td><td class="cell2"><div>© 2012 ХНУРЭ, ПИ, Широкопетлева М.С., <a href="mailto:mshirokopetleva@gmail.com">mshirokopetleva@gmail.com</a>;   ХНУРЭ, ПИ, Черепанова Ю.Ю.;   ХНУРЭ, ПИ, Мазурова О.А.<br /><a href="http://lersus.de/" title="Данный курс создан с помощью авторской системы LERSUS" target="_blank">Разработано с помощью LERSUS</a></div></td></tr></table></td></tr></table></body></html>