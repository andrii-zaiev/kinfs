<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="LERSUS 3.3.0.0" /><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Корпоративные информационные системы — Теория — Курсоры</title><script language="javascript" type="text/javascript" src="../../00/styles/files/apiwrapper.js"> </script><script language="javascript" type="text/javascript" src="../../00/styles/files/sco.js"> </script><link href="../../00/styles/files/style.css" rel="stylesheet" type="text/css" /></head><body><table id="mainOuter"><tr><td id="topOuter"><table id="topInner"><tr class="row1"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4" id="shortcuts"><div><ul class="level0"><li><a href="../../00/content/authors1.html">Авторы</a></li><li>|</li><li><a href="../../00/content/contacts1.html">Контакты</a></li><li>|</li><li><a href="../../00/content/instructions1.html">Методические указания</a></li><li>|</li><li><a href="../../00/content/annotation1.html">Аннотация</a></li><li>|</li><li><a href="#" onclick="history.back(); return false;">Назад</a></li></ul></div></td></tr><tr class="row2"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4"><div id="courseTitle">Корпоративные информационные системы</div><div id="courseSubTitle">Языки запросов к базам данных : Курсоры</div></td></tr></table></td></tr><tr><td id="contentOuter"><table id="contentInner"><tr><td class="menuOuter"><table class="menuInner"><tr><td><ul class="level0"><li><a href="../../00/styles/courses.html">Содержание курса</a></li><li><span>Теория</span></li><ul class="level1"><li><a href="../../03/content/content1.html">Оптимизация запросов</a></li><li><a href="../../03/content/content2.html">Окружение 4-го поколения</a></li><li><a href="../../03/content/content3.html">Язык PL / SQL. Общие положения </a></li><li><a href="../../03/content/content4.html">Переменные и константы. Кодовое множество</a></li><li><a href="../../03/content/content5.html">Типы данных</a></li><li><a href="../../03/content/content6.html">Команды управления</a></li><li><a href="../../03/content/content7.html">Создание хранимых процедур и функций </a></li><li><a href="../../03/content/content8.html">Параметры подпрограмм</a></li><li><a href="../../03/content/content9.html">Встроенные функции PL / SQL</a></li><li><a href="../../03/content/content10.html">Курсоры</a></li><li><a href="../../03/content/content11.html">Исключительные ситуации</a></li><li><a href="../../03/content/content12.html">Обработчики исключений </a></li><li><a href="../../03/content/content13.html">Пакеты</a></li><li><a href="../../03/content/content14.html">Триггеры объектов </a></li></ul><li><span>Практика</span></li><ul class="level1"><li><a href="../../03/content/example1.html">Практика 2. Использование подпрограмм в языках  программирования 4-го поколения</a></li><li><a href="../../03/content/example2.html">Лабораторная работа 2 Подпрограммы как средство создания серверных частей информационных систем на примере СУБД Oracle </a></li><li><a href="../../03/content/example3.html">Практика 3. Создание  и работа с триггерами объектов и событий</a></li><li><a href="../../03/content/example4.html">Лабораторная работа 3. Триггеры объектов и событий базы данных </a></li></ul><li><span>Текущий контроль знаний</span></li><ul class="level1"><li><a href="../../03/content/multiply-choice-test25.html">Управляющие структуры</a></li><li><a href="../../03/content/multiply-answers-test7.html">Подпрограммы языка PL/SQL</a></li><li><a href="../../03/content/multiply-choice-test1.html">Курсоры</a></li><li><a href="../../03/content/multiply-answers-test12.html">Исключительные ситуации</a></li><li><a href="../../03/content/multiply-choice-test19.html">Пакеты</a></li><li><a href="../../03/content/multiply-answers-test3.html">Триггеры</a></li></ul><li><a href="../../03/styles/glossary.html">Словарь терминов</a></li><li><a href="../../03/03.pdf" target="_blank">Версия для печати</a></li></ul></td></tr></table></td><td class="content"><div id="content"><div id="topBlankStripe"> </div><span id="lnk92bdfdef9e1046fa9d502c0079824553"> </span><h1 align="left" class="headline-source">     Курсоры</h1><span id="lnk7c840588700c455c921d6f995c8447b6"> </span><h2 align="left" class="paragraph-headline-source">     Извлечение записей </h2><span id="lnkff2f31423e6940f6ad6e5de96d3d9876"> </span><div class="section"><p align="justify" class="paragraph-source">     Для выполнения предложений SQL и хранения их результатов ORACLE использует рабочие области, называемые <i><b>личными областями</b></i> SQL. Конструкт PL/SQL, называемый КУРСОРОМ, позволяет вам обращаться к личной области SQL по имени и извлекать из нее информацию. Есть два вида курсоров: <i><b>неявные </b></i>и <i><b>явные</b></i>. PL/SQL неявно объявляет курсор для любого предложения манипулирования данными SQL, в том числе для запроса, возвращающего только одну строку. Для запросов, возвращающих более одной строки, вы можете явно объявить курсор, чтобы обрабатывать возвращаемые строки по одной. </p></div><span id="lnk89ec120a58144260b32d3f96b5ac84ad"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Явные курсоры </b></p></div><span id="lnkc50b40001d5d48eb9825ef4a80bc682a"> </span><div class="section"><p align="justify" class="paragraph-source">     Множество строк, возвращаемых запросом (активное множество), может состоять из нуля, одной или нескольких строк, в зависимости от того, сколько строк удовлетворяют вашим поисковым условиям. Когда запрос возвращает несколько строк, вы можете явно определить курсор для обработки этих строк. </p><p align="justify" class="paragraph-source">     Вы определяете курсор в декларативной части блока PL/SQL, подпрограммы или пакета путем задания его имени и специфицирования запроса. После этого вы манипулируете курсором при помощи трех команд: OPEN, FETCH и CLOSE. </p><p align="justify" class="paragraph-source">     Прежде всего, вы инициализируете курсор предложением OPEN, которое идентифицирует активное множество. Затем с помощью предложения FETCH вы извлекаете первую строку. Вы можете повторять FETCH неоднократно, пока не будут извлечены все строки. После обработки последней строки вы освобождаете курсор предложением CLOSE. Вы можете обрабатывать параллельно несколько запросов, объявив и открыв несколько курсоров. </p></div><span id="lnke8385bf757e545e8b45fc625f9d97c83"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Неявные курсоры </b></p></div><span id="lnk35ce8a09fcde47028b05824dd0542fd7"> </span><div class="section"><p align="justify" class="paragraph-source">     ORACLE неявно открывает курсор для обработки каждого предложения SQL, не ассоциированного с явно объявленным курсором. PL/SQL позволяет вам обращаться к последнему открытому неявному курсору через имя "SQL". Поэтому, хотя вы не можете манипулировать неявным курсором посредством предложений OPEN, FETCH и CLOSE, вы можете опрашивать атрибуты этого курсора, чтобы получить полезную информацию о последней выполненной операции SQL. </p></div><span id="lnk96985454c2f54b7185a386f133a8a901"> </span><h2 align="left" class="paragraph-headline-source">     Объявление курсора </h2><span id="lnk42f517d5302e4af9b3ea6044b3c35d0a"> </span><div class="section"><p align="justify" class="paragraph-source">     Ссылки вперед недопустимы в PL/SQL. Поэтому вы должны объявить курсор, прежде чем сможете ссылаться на него в других предложениях. Объявляя курсор, вы даете ему имя и ассоциируете его с конкретным запросом. </p><p align="left" class="paragraph-source">     В следующем примере объявляется курсор с именем c 1: </p><p align="left" class="paragraph-source">DECLARE <br />CURSOR c1 IS SELECT quantity, begin_time, end_time FROM storages <br />WHERE ware_id=1; <br />... <br />BEGIN <br />... </p><p align="justify" class="paragraph-source">     Имя курсора - это необъявленный ранее идентификатор, а не переменная PL/SQL; его можно использовать только для обращения к запросу. Вы не можете присваивать значений имени курсора или использовать его в выражениях. Однако, имена курсоров подчиняются тем же правилам сферы, что и имена переменных. </p></div><span id="lnk7e98ed7b0e244aa7ad35ec05864fa582"> </span><h2 align="left" class="paragraph-headline-source">     Параметризованные курсоры </h2><span id="lnkc3175b06ada0477492e00f6bc34942d0"> </span><div class="section"><p align="justify" class="paragraph-source">     Курсоры могут принимать параметры, как показывает следующий пример. Параметр курсора может появляться в запросе всюду, где допускается появление константы. </p><p align="left" class="paragraph-source">CURSOR c1(ware_num IN NUMBER) IS SELECT quantity, begin_time, end_time FROM storages <br />WHERE ware_id= ware_num; </p><p align="left" class="paragraph-source">     Для объявления формальных параметров курсора используется синтаксис </p><p align="left" class="paragraph-source">CURSOR имя [ (параметр [, параметр, ...]) ] IS SELECT ... </p><p align="left" class="paragraph-source">где "параметр", в свою очередь, имеет следующий синтаксис: </p><p align="left" class="paragraph-source">имя_переменной [IN] тип_данных [{:= | DEFAULT} значение] </p><p align="justify" class="paragraph-source">     Формальные параметры курсора должны иметь моду IN. Для обсуждения мод параметров обратитесь к разделу "Моды параметров". </p><p align="justify" class="paragraph-source">     Как показывает следующий пример, вы можете инициализировать параметры курсора умалчиваемыми значениями. Таким способом вы можете передавать курсору различное число фактических параметров, принимая или перекрывая умалчиваемые значения по своему желанию. Более того, вы можете добавлять в курсор новые формальные параметры без необходимости отыскивать и исправлять все обращения к курсору в тексте программы. </p><p align="left" class="paragraph-source">DECLARE <br />CURSOR c1 (ware_num NUMBER DEFAULT 1, goods_num NUMBER DEFAULT 5) IS SELECT ... <br />... </p><p align="justify" class="paragraph-source">     Сфера параметров курсора локальна в этом курсоре, что означает, что к этим параметрам можно обращаться лишь в запросе, который участвует в объявлении курсора. Значения параметров курсора используются ассоциированным запросом в момент открытия курсора. </p></div><span id="lnkcb0dccef35264642b9ec3bbca0f67c48"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Открытие курсора </b></p></div><span id="lnk9f5f01f2fe964550a10e087c12533c80"> </span><div class="section"><p align="justify" class="paragraph-source">     Открытие курсора предложением OPEN исполняет предложение SELECT и идентифицирует АКТИВНОЕ МНОЖЕСТВО, т.е. все строки, удовлетворяющие поисковым условиям запроса. Для курсоров, объявленных с фразой FOR UPDATE, предложение OPEN также осуществляет блокировку этих строк. Пример предложения OPEN: </p><p align="left" class="paragraph-source">OPEN c1; </p><p align="justify" class="paragraph-source">     Предложение OPEN не извлекает строк активного множества. Для этого используется предложение FETCH. </p></div><span id="lnk2c9389f63da84bd789c2c04ab6f93f62"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Передача параметров </b></p></div><span id="lnkf897f044c34c40e48e07ff3d4575d64b"> </span><div class="section"><p align="left" class="paragraph-source">     Курсору могут быть переданы параметры при открытии. </p><p align="left" class="paragraph-source">     Например, при объявлении курсора </p><p align="left" class="paragraph-source">CURSOR c1 (ware_num NUMBER, goods_num NUMBER) IS SELECT … </p><p align="left" class="paragraph-source">любое из следующих предложений открывает этот курсор: </p><p align="left" class="paragraph-source">OPEN c1( 3, 5); <br />OPEN c1(new_ware, 5); <br />OPEN c1(3, goods_num); </p><p align="justify" class="paragraph-source">     В последнем примере переменная, специфицированная в предложении OPEN, имеет такое же имя, что и параметр в объявлении курсора. Когда идентификатор goods _ num используется в объявлении курсора, он обозначает формальный параметр курсора. Когда этот же идентификатор используется вне объявления курсора, он обозначает переменную PL/SQL с этим именем. Однако, для ясности, рекомендуется использовать уникальные идентификаторы. Если вы не хотите принять умалчиваемые значения, каждому формальному параметру в объявлении курсора следует сопоставить соответствующий фактический параметр в предложении OPEN. Формальные параметры, объявленные с умалчиваемым значением, могут и не иметь соответствующих им фактических параметров. В этом случае они просто принимают свое умалчиваемое значение во время выполнения OPEN. Не забывайте, что формальные параметры курсора должны быть параметрами IN, так что они не могут возвращать значений фактическим параметрам. Чтобы сопоставить фактические параметры в предложении OPEN формальным параметрам в объявлении курсора, вы можете использовать позиционную или именную нотацию. Каждый фактический параметр должен иметь тип данных, совместимый с типом данных соответствующего формального параметра. </p></div><span id="lnk3c9c21502dfd4dfdbc06ec7e2a0f0e7a"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Извлечение данных из курсора </b></p></div><span id="lnk3f23aa75d991447188597349e4183ae1"> </span><div class="section"><p align="justify" class="paragraph-source">     Предложение FETCH извлекает очередную строку из активного множества. При каждом выполнении FETCH курсор продвигается к следующей строке в активном множестве. </p><p align="left" class="paragraph-source">     Пример предложения FETCH : </p><p align="left" class="paragraph-source">FETCH c1 INTO my_quantity, my_begin_time, my_end_time; </p><p align="justify" class="paragraph-source">     Для каждого значения столбца, извлекаемого запросом, ассоциированного с курсором, в списке INTO должна быть соответствующая переменная, имеющая совместимый с этим столбцом тип данных. </p><p align="justify" class="paragraph-source">     Любые переменные в фразе WHERE запроса, ассоциированного с курсором, вычисляются лишь в момент открытия курсора. Как показывает следующий пример, запрос может обращаться к переменным PL/SQL внутри своей сферы: </p><p align="left" class="paragraph-source">DECLARE <br />Volume1 warehouses.volume%TYPE; <br />Volume_rest1 warehouses.volume_rest%TYPE; <br />My_ware NUMBER(6,2):= 1; <br />CURSOR c1 (ware_id1 NUMBER) IS SELECT volume, volume_rest FROM warehouses <br />WHERE ware_id=ware_id1; </p><p align="left" class="paragraph-source">BEGIN <br />... <br />OPEN c1(my_ware); -- здесь my_ware равен 0 <br />LOOP <br />FETCH c1 INTO volume1, volume_rest1; <br />EXIT WHEN c1%NOTFOUND; <br />... <br />my_ware := my_ware + 1; -- не окажет влияния на FETCH <br />END LOOP; <br />END; </p></div><span id="lnked5c2b0b7e5f4e5a9178febff26b9480"> </span><div class="section"><p align="justify" class="paragraph-source">     Однако для каждой операции FETCH на одном и том же курсоре вы можете использовать собственный список INTO. Каждая FETCH извлекает строку и присваивает значения своим переменным INTO, как показывает следующий пример: </p><p align="left" class="paragraph-source">DECLARE <br />CURSOR c1 IS SELECT name FROM goods; <br />name1 goods.name%TYPE; <br />name2 goods.name%TYPE; <br />name3 goods.name%TYPE; </p><p align="left" class="paragraph-source">BEGIN <br />OPEN c1; <br />FETCH c 1 INTO name 1; -- извлекает первую строку <br />FETCH c 1 INTO name 2; -- извлекает вторую строку <br />FETCH c 1 INTO name 3; -- извлекает третью строку <br />... <br />CLOSE c1; <br />END; </p><p align="justify" class="paragraph-source">     Если вы выдаете FETCH, но в активном множестве больше нет строк, то значения переменных в списке INTO не определены. </p></div><span id="lnkc06773d7b0254d50abcba62234b2d034"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Закрытие курсора </b></p></div><span id="lnk7be196759f934587b8d4db5a3f5cdf66"> </span><div class="section"><p align="left" class="paragraph-source">     Предложение CLOSE деактивирует курсор, и активное множество становится неопределенным. </p><p align="left" class="paragraph-source">     Пример предложения CLOSE: </p><p align="left" class="paragraph-source">CLOSE c1; </p><p align="left" class="paragraph-source">     После того, как курсор закрыт, вы можете снова открыть его. Любая иная операция на закрытом курсоре возбуждает предопределенное исключение INVALID_CURSOR, которое соответствует ошибке ORACLE с кодом ORA-01001. </p></div><span id="lnk6dc4442f385b41df9b00a78b0d89b1ba"> </span><h2 align="left" class="paragraph-headline-source">     Курсорные циклы FOR </h2><span id="lnk6862755ae425471ea5e42b561ce8b9a0"> </span><div class="section"><p align="justify" class="paragraph-source">     В большинстве ситуаций, требующих курсора, вы можете использовать курсорный цикл FOR, чтобы упростить кодирование. Курсорный цикл FOR неявно объявляет свой индекс цикла как запись типа %ROWTYPE, открывает курсор, в цикле извлекает строки из активного множества в поля записи, и закрывает курсор, когда все строки обработаны или когда вы выходите из цикла. Рассмотрим следующий блок PL/SQL, который анализирует данные, собранные в ходе лабораторных экспериментов, и помещает результаты во временную таблицу. Переменная c1rec, используемая как индекс в курсорном цикле FOR, неявно объявляется как запись, хранящая все элементы данных, возвращаемые одной операцией FETCH для курсора c1. Вы обращаетесь к элементам данных, хранящимся в полях записи, используя квалифицированные ссылки. </p><p align="left" class="paragraph-source">DECLARE <br />res itog.volume_use%TYPE; <br />CURSOR c1 IS SELECT ware_id, volume, volume_rest FROM warehouses; </p><p align="left" class="paragraph-source">BEGIN <br />FOR c1rec IN c1 LOOP <br />/* вычислить и сохранить результаты */ <br />res := c1rec.volume - c1rec.volume_rest; <br />INSERT INTO itog VALUES (c1rec.ware_id, res); <br />END LOOP; <br />COMMIT; <br />END ; </p></div><span id="lnk2f89762f75454a52ab8fd002ba3e45a1"> </span><div class="section"><p align="justify" class="paragraph-source">     Перед каждой итерацией курсорного цикла FOR, PL/SQL извлекает данные в неявно объявленную запись, которая эквивалентна следующей явно объявленной записи: c1rec c1%ROWTYPE; Эта запись определена только внутри цикла. Вы не можете обращаться к ее полям вне цикла. </p><p align="left" class="paragraph-source">     Например, следующая ссылка незаконна: </p><p align="left" class="paragraph-source">BEGIN <br />... <br />FOR c1rec IN c1 LOOP <br />... <br />END LOOP; <br />res := c1rec.volume - 100; -- незаконно <br />END; </p><p align="justify" class="paragraph-source">     Последовательность предложений внутри цикла выполняется один раз для каждой строки, которая удовлетворяет запросу, ассоциированному с курсором. Когда вы выходите из цикла, курсор закрывается автоматически. Это справедливо даже тогда, когда вы выходите из цикла принудительно, с помощью EXIT или GOTO, или когда внутри цикла возбуждается исключение. </p><p align="justify" class="paragraph-source">     Поля в неявно объявленной записи курсорного цикла FOR содержат значения столбцов из последней извлеченной строки. Эти поля имеют такие же имена, что и соответствующие столбцы в списке SELECT запроса. Однако что, если элемент списка SELECT является выражением? Рассмотрим следующий пример: </p><p align="left" class="paragraph-source">CURSOR c1 IS SELECT ware_id, volume - volume_rest FROM ... </p><p align="justify" class="paragraph-source">     В таких случаях вы должны предоставлять алиас для элемента списка SELECT. В следующем примере для вычисляемого элемента volume - volume _ rest используется алиас use : </p><p align="left" class="paragraph-source">CURSOR c1 IS SELECT ware_id, volume - volume_rest use FROM ... </p><p align="justify" class="paragraph-source">     При обращениях к соответствующему полю вы используете алиас в квалифицированной ссылке, например: </p><p align="left" class="paragraph-source">IF c1_rec.use &lt; 1000 THEN ... </p></div><span id="lnkd2050547edf44461b1f058dddee5c85c"> </span><h2 align="left" class="paragraph-headline-source">     Атрибуты явного курсора</h2><span id="lnk710b30411d524b0aa6e8308ba4e4b21e"> </span><div class="section"><p align="justify" class="paragraph-source">     Каждый курсор, явно объявленный вами, имеет четыре атрибута: % NOTFOUND , % FOUND , % ROWCOUNT и % ISOPEN . Атрибуты позволяют вам получать полезную информацию о выполнении многострочного запроса. Для обращения к атрибуту просто присоедините его имя к имени курсора. Атрибуты явного курсора можно использовать в процедурных предложениях, но не в предложениях SQL. </p></div><span id="lnk001ce8db2a3543909bf4666e699f975a"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Использование %NOTFOUND </b></p></div><span id="lnk8f3b705e6cb94fe0864d04b2fb4e5b73"> </span><div class="section"><p align="justify" class="paragraph-source">     Когда курсор открыт, строки, удовлетворяющие ассоциированному запросу, идентифицированы и образуют активное множество. Эти строки извлекаются операцией FETCH по одной за раз. Если последняя операция FETCH вернула строку, %NOTFOUND дает FALSE. Если последняя операция FETCH не смогла вернуть строку (так как активное множество исчерпано), %NOTFOUND дает TRUE. </p><p align="justify" class="paragraph-source">     Операция FETCH должна в конце концов исчерпать активное множество, так что, когда это происходит, никакого исключения не возбуждается. В следующем примере вы используете %NOTFOUND, чтобы выйти из цикла, когда FETCH не сможет вернуть строку: </p><p align="left" class="paragraph-source">LOOP <br />FETCH c1 INTO my_ware, my_use; <br />EXIT WHEN c1%NOTFOUND; <br />... <br />END LOOP; </p><p align="justify" class="paragraph-source">     Перед первой операцией FETCH атрибут %NOTFOUND дает NULL. Поэтому, если FETCH ни разу не выполнится успешно, вы никогда не выйдете из этого цикла. Причина в том, что предложение EXIT WHEN выполняется только в том случае, когда условие WHEN дает TRUE. Поэтому для безопасности вы можете предпочесть такой вариант предложения EXIT : </p><p align="left" class="paragraph-source">EXIT WHEN c1%NOTFOUND OR c1%NOTFOUND IS NULL; </p><p align="justify" class="paragraph-source">     Вы можете открыть несколько курсоров, а затем использовать %NOTFOUND, чтобы проверять, в каких курсорах еще есть строки. Если курсор не открыт, обращение к нему через %NOTFOUND возбуждает предопределенное исключение INVALID_CURSOR. </p></div><span id="lnk609b86f0026b4b0c825f808b453f68c9"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Использование %FOUND </b></p></div><span id="lnk92250245be974c7fa9e681706053a3aa"> </span><div class="section"><p align="justify" class="paragraph-source">     %FOUND логически противоположен атрибуту %NOTFOUND. После открытия явного курсора, но до первой операции FETCH, %FOUND дает NULL. Впоследствии он дает TRUE, если последняя операция FETCH вернула строку, или FALSE, если последняя операция FETCH не смогла извлечь строку, так как больше нет доступных строк. Следующий пример использует %FOUND, чтобы выбрать одно из двух альтернативных действий: </p><p align="left" class="paragraph-source">LOOP <br />FETCH c1 INTO my_ware, my_use; <br />IF c1%FOUND THEN -- извлечение успешно <br />INSERT INTO itog VALUES (...); <br />ELSE EXIT; <br />... <br />END LOOP; </p><p align="justify" class="paragraph-source">     Вы можете открыть несколько курсоров, а затем использовать %FOUND, чтобы проверять, в каких курсорах еще есть строки. Если курсор не открыт, обращение к нему через %FOUND возбуждает предопределенное исключение INVALID_CURSOR. </p><p align="left" class="paragraph-source"> </p></div><span id="lnk10367e7c3371411dad2bcc9d7d99b127"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Использование %ROWCOUNT</b></p></div><span id="lnk0d46e490b36c4291a01aa8bf0893530f"> </span><div class="section"><p align="justify" class="paragraph-source">      Когда вы открываете курсор, его атрибут %ROWCOUNT обнуляется. Перед первой операцией FETCH %ROWCOUNT возвращает 0. Впоследствии, %ROWCOUNT возвращает число строк, извлеченных операциями FETCH из активного множества на данный момент. Это число увеличивается, если последняя FETCH вернула строку. Следующий пример использует %ROWCOUNT, чтобы предпринять определенные действия, если выбрано более 10 строк: </p><p align="left" class="paragraph-source">LOOP <br />FETCH c1 INTO my_ware, my_use; <br />IF c1%ROWCOUNT &gt; 10 THEN -- выбрано больше 10 строк <br />... <br />END IF; <br />END LOOP; </p><p align="justify" class="paragraph-source">     Вы можете открыть несколько курсоров, а затем использовать %ROWCOUNT, чтобы проверять, сколько строк извлечено из каждого курсора. Если курсор не открыт, обращение к нему через %ROWCOUNT возбуждает предопределенное исключение INVALID_CURSOR.</p></div><span id="lnk8ef55851bb4848ad9c9bd5d0c1863875"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Использование %ISOPEN </b></p></div><span id="lnk4024b987a5ca491088c86d5a19637bf4"> </span><div class="section"><p align="justify" class="paragraph-source">     %ISOPEN дает TRUE, если явный курсор открыт, и FALSE в противном случае. Следующий пример использует %ISOPEN для выбора действия: </p><p align="left" class="paragraph-source">IF с1%ISOPEN THEN -- курсор открыт <br />... <br />ELSE -- курсор закрыт, открыть его <br />OPEN c1; <br />END IF; </p><p align="justify" class="paragraph-source">     Таблица 5 показывает значения, возвращаемые атрибутами явного курсора перед и после выполнения операций OPEN, FETCH и CLOSE. Обратите внимание, что перед первой операцией FETCH атрибуты %NOTFOUND и %FOUND возвращают NULL на открытом курсоре. </p></div><span id="lnk9cd5ccdace2a43fbaf19d0dc49726b46"> </span><div align="center"><div class="inline-table-container"><p align="left" class="unit-title">Таблица 5 - Атрибуты курсора</p><table class="inline-table"><col width="106" /><col width="94" /><col width="105" /><col width="118" /><col width="100" /><col width="221" /><tbody><tr><td colspan="2" style="background-color:#ffffff"> </td><td style="background-color:#ffffff"><p align="center" class="inline-table">%NOTFOUND</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">%FOUND </p></td><td style="background-color:#ffffff"><p align="center" class="inline-table"> %ROWCOUNT</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">%ISOPEN</p></td></tr><tr><td rowspan="2" style="background-color:#ffffff"><p align="left" class="inline-table">OPEN</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Перед</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">*</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">*</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">*</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">FALSE</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">После</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">NULL</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">NULL</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">0</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">TRUE</p></td></tr><tr><td rowspan="2" style="background-color:#ffffff"><p align="left" class="inline-table">Первая FETCH</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Перед</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">NULL</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">NULL</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">0</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">TRUE</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">После</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">FALSE</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">TRUE</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">1</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">TRUE</p></td></tr><tr><td rowspan="2" style="background-color:#ffffff"><p align="left" class="inline-table">Промежуточные FETCH</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Перед</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">FALSE</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">TRUE</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">1</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">TRUE</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">После</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">FALSE</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">TRUE</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">**</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">TRUE</p></td></tr><tr><td rowspan="2" style="background-color:#ffffff"><p align="left" class="inline-table">Последняя FETCH</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Перед</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">FALSE</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">TRUE</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">**</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">TRUE</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">После</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">TRUE</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">FALSE</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">**</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">TRUE</p></td></tr><tr><td rowspan="2" style="background-color:#ffffff"><p align="left" class="inline-table">CLOSE</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Перед</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">TRUE</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">FALSE</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">**</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">TRUE</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">После</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">*</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">*</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">*</p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">FALSE</p></td></tr></tbody></table><p align="left" class="unit-comment">* Возбуждает предопределенное исключение INVALID _ CURSOR <br />** Зависит от данных</p></div></div><span id="lnk27d90e9f828341c896d16e330d000c9b"> </span><div class="section"><p align="left" class="paragraph-source">     Пример использования явного курсора см. в практическом занятии 2. </p></div><span id="lnk6d3b3aebd7e74e8594f638a10738a2f9"> </span><h2 align="left" class="paragraph-headline-source">     Атрибуты неявного курсора </h2><span id="lnkd8624d1f06ba4b59899911f82448dd24"> </span><div class="section"><p align="justify" class="paragraph-source">     Курсор SQL имеет четыре атрибута: % NOTFOUND , % FOUND , % ROWCOUNT и % ISOPEN . Эти атрибуты, присоединяемые к имени курсора (SQL), дают вам доступ к информации о выполнении предложений INSERT, UPDATE, DELETE и однострочных предложений SELECT INTO. Вы можете использовать атрибуты неявного курсора в процедурных предложениях, но не в предложениях SQL. Значения атрибутов неявного курсора всегда относятся к последней выполненной операции SQL, где бы она ни появилась. Соответствующее предложение SQL может даже находиться в другой сфере (например, в подблоке). Поэтому, если вы хотите сохранить значение такого атрибута, немедленно присвойте его булевской переменной. </p><p align="justify" class="paragraph-source">     Следующий пример показывает, как несоблюдение этого правила может привести к логической ошибке: </p><p align="left" class="paragraph-source">UPDATE storages SET quantity = quantity - 100 WHERE storage_id=5 AND quantity&gt;100; <br />Buy _ goods (5, 20); -- вызов процедуры <br />IF SQL%NOTFOUND THEN -- рискованно ! <br />... <br />END IF; </p><p align="justify" class="paragraph-source">     В этом примере рискованно полагаться на условие IF, потому что процедура Buy _ goods , возможно, изменила значение %NOTFOUND. Вы можете исправить этот код следующим образом, объявив в декларативной части булевскую переменную sql_notfound: </p><p align="left" class="paragraph-source">UPDATE storages SET quantity = quantity - 100 WHERE storage_id=5 AND quantity&gt;100; <br />sql_notfound := SQL%NOTFOUND; <br />Buy _ goods (5, 20); -- вызов процедуры <br />IF sql_notfound THEN ... <br />END IF ; </p></div><span id="lnkcaffb97ff5cc4fb28d859733cd96927f"> </span><div class="section"><p align="justify" class="paragraph-source">     Пока ORACLE автоматически не открыл курсор SQL, атрибуты неявного курсора возвращают NULL. </p><p align="justify" class="paragraph-source">     Использование %NOTFOUND %NOTFOUND дает TRUE, если INSERT, UPDATE или DELETE не обработала ни одной строки, или если операция SELECT INTO не возвратила ни одной строки. В противном случае %NOTFOUND дает FALSE. </p><p align="justify" class="paragraph-source">     В следующем примере вы используете %NOTFOUND, чтобы вставить новую строку, если операция обновления не нашла строки: </p><p align="left" class="paragraph-source">UPDATE storages SET quantity = quantity - 100 WHERE storage_id=5 AND quantity&gt;100; <br />IF SQL%NOTFOUND THEN -- обновление не прошло <br />INSERT INTO storages VALUES (...); <br />END IF ; </p><p align="justify" class="paragraph-source">     Если предложение SELECT INTO не возвращает ни одной строки, возбуждается предопределенное исключение NO_DATA_FOUND, независимо от того, проверяете ли вы %NOTFOUND в следующей строке или нет. </p></div><span id="lnka72f0ad73c9c44adba66602d686d15ff"> </span><div class="section"><p align="justify" class="paragraph-source">     %FOUND логически противоположен атрибуту %NOTFOUND. Перед выполнением предложения манипулирования данными SQL SQL%FOUND дает NULL. Впоследствии, этот атрибут дает TRUE, если операция INSERT, UPDATE или DELETE затронула хотя бы одну строку, или если операция SELECT INTO вернула хотя бы одну строку. В противном случае SQL%FOUND дает FALSE. </p><p align="justify" class="paragraph-source">     В следующем примере вы используете %FOUND, чтобы вставить строку при успехе операции удаления: </p><p align="left" class="paragraph-source">DELETE FROM storages WHER ware_id = 5; <br />IF SQL%FOUND THEN -- удаление успешно <br />INSERT INTO temp VALUES ...; <br />END IF ; </p><p align="justify" class="paragraph-source">     Использование % ROWCOUNT SQLROWCOUNT возвращает число строк, на которое воздействовала операция INSERT , UPDATE или DELETE , или число строк, возвращенных операцией SELECT INTO. %ROWCOUNT возвращает 0, если операция INSERT, UPDATE или DELETE не затронула ни одной строки, или если операция SELECT INTO не возвратила ни одной строки. </p></div><span id="lnkacb862386e984370af3df465fb19b934"> </span><div class="section"><p align="justify" class="paragraph-source">     Следующий пример использует %ROWCOUNT, чтобы предпринять определенные действия, если было удалено более 5 строк: </p><p align="left" class="paragraph-source">DELETE FROM storages WHER ware_id = 5; <br />IF SQL % ROWCOUNT &gt; 5 THEN -- удалено больше 5 строк <br />... <br />END IF; </p><p align="justify" class="paragraph-source">     Если операция SELECT INTO возвращает более одной строки, то возбуждается предопределенное исключение TOO_MANY_ROWS, а атрибут %ROWCOUNT устанавливается в 1, а НЕ в действительное число строк, удовлетворяющих запросу. </p><p align="justify" class="paragraph-source">     Использование %ISOPEN ORACLE автоматически закрывает неявный курсор после выполнения связанной с ним операции SQL. Поэтому атрибут SQL%ISOPEN всегда возвращает FALSE. </p><p align="justify" class="paragraph-source">     В <a title="" target="_self" href="../../03/content/example1.html#lnk2a46871b95f044a6906e5e3d4c1bc2bc">практическом занятии 2</a> приведено еще несколько примеров использования курсоров для БД. </p></div></div></td></tr></table></td></tr><tr><td id="bottomOuter"><table id="bottomInner"><tr><td class="cell1"><div> </div></td><td class="cell2"><div>© 2012 ХНУРЭ, ПИ, Широкопетлева М.С., <a href="mailto:mshirokopetleva@gmail.com">mshirokopetleva@gmail.com</a>;   ХНУРЭ, ПИ, Черепанова Ю.Ю.;   ХНУРЭ, ПИ, Мазурова О.А.<br /><a href="http://lersus.de/" title="Данный курс создан с помощью авторской системы LERSUS" target="_blank">Разработано с помощью LERSUS</a></div></td></tr></table></td></tr></table></body></html>