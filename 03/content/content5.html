<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="LERSUS 3.3.0.0" /><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Корпоративные информационные системы — Теория — Типы данных</title><script language="javascript" type="text/javascript" src="../../00/styles/files/apiwrapper.js"> </script><script language="javascript" type="text/javascript" src="../../00/styles/files/sco.js"> </script><link href="../../00/styles/files/style.css" rel="stylesheet" type="text/css" /></head><body><table id="mainOuter"><tr><td id="topOuter"><table id="topInner"><tr class="row1"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4" id="shortcuts"><div><ul class="level0"><li><a href="../../00/content/authors1.html">Авторы</a></li><li>|</li><li><a href="../../00/content/contacts1.html">Контакты</a></li><li>|</li><li><a href="../../00/content/instructions1.html">Методические указания</a></li><li>|</li><li><a href="../../00/content/annotation1.html">Аннотация</a></li><li>|</li><li><a href="#" onclick="history.back(); return false;">Назад</a></li></ul></div></td></tr><tr class="row2"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4"><div id="courseTitle">Корпоративные информационные системы</div><div id="courseSubTitle">Языки запросов к базам данных : Типы данных</div></td></tr></table></td></tr><tr><td id="contentOuter"><table id="contentInner"><tr><td class="menuOuter"><table class="menuInner"><tr><td><ul class="level0"><li><a href="../../00/styles/courses.html">Содержание курса</a></li><li><span>Теория</span></li><ul class="level1"><li><a href="../../03/content/content1.html">Оптимизация запросов</a></li><li><a href="../../03/content/content2.html">Окружение 4-го поколения</a></li><li><a href="../../03/content/content3.html">Язык PL / SQL. Общие положения </a></li><li><a href="../../03/content/content4.html">Переменные и константы. Кодовое множество</a></li><li><a href="../../03/content/content5.html">Типы данных</a></li><li><a href="../../03/content/content6.html">Команды управления</a></li><li><a href="../../03/content/content7.html">Создание хранимых процедур и функций </a></li><li><a href="../../03/content/content8.html">Параметры подпрограмм</a></li><li><a href="../../03/content/content9.html">Встроенные функции PL / SQL</a></li><li><a href="../../03/content/content10.html">Курсоры</a></li><li><a href="../../03/content/content11.html">Исключительные ситуации</a></li><li><a href="../../03/content/content12.html">Обработчики исключений </a></li><li><a href="../../03/content/content13.html">Пакеты</a></li><li><a href="../../03/content/content14.html">Триггеры объектов </a></li></ul><li><span>Практика</span></li><ul class="level1"><li><a href="../../03/content/example1.html">Практика 2. Использование подпрограмм в языках  программирования 4-го поколения</a></li><li><a href="../../03/content/example2.html">Лабораторная работа 2 Подпрограммы как средство создания серверных частей информационных систем на примере СУБД Oracle </a></li><li><a href="../../03/content/example3.html">Практика 3. Создание  и работа с триггерами объектов и событий</a></li><li><a href="../../03/content/example4.html">Лабораторная работа 3. Триггеры объектов и событий базы данных </a></li></ul><li><span>Текущий контроль знаний</span></li><ul class="level1"><li><a href="../../03/content/multiply-choice-test25.html">Управляющие структуры</a></li><li><a href="../../03/content/multiply-answers-test7.html">Подпрограммы языка PL/SQL</a></li><li><a href="../../03/content/multiply-choice-test1.html">Курсоры</a></li><li><a href="../../03/content/multiply-answers-test12.html">Исключительные ситуации</a></li><li><a href="../../03/content/multiply-choice-test19.html">Пакеты</a></li><li><a href="../../03/content/multiply-answers-test3.html">Триггеры</a></li></ul><li><a href="../../03/styles/glossary.html">Словарь терминов</a></li><li><a href="../../03/03.pdf" target="_blank">Версия для печати</a></li></ul></td></tr></table></td><td class="content"><div id="content"><div id="topBlankStripe"> </div><span id="lnk00278dfec81844de90eb42648f994866"> </span><h1 align="left" class="headline-source">     Типы данных</h1><span id="lnkda0c975404b64824bde0153a601869bd"> </span><div class="section"><p align="justify" class="paragraph-source">     Каждая константа и переменная имеет ТИП ДАННЫХ, который специфицирует ее формат хранения, ограничения и допустимый интервал значений. PL/SQL предусматривает разнообразие предопределенных скалярных и составных типов данных. СКАЛЯРНЫЙ тип не имеет внутренних компонент. СОСТАВНОЙ тип имеет внутренние компоненты, которыми можно манипулировать индивидуально. </p><p align="left" class="paragraph-source">     Рассмотрим скалярные типы данных ORACLE (см.табл. 3): </p><p align="left" class="paragraph-source">     - CHAR ;</p><p align="left" class="paragraph-source">     -  VARCHAR2 ;</p><p align="left" class="paragraph-source">     - VARCHAR ;</p><p align="left" class="paragraph-source">     -  NUMBER;</p><p align="left" class="paragraph-source">     - DATE ;</p><p align="left" class="paragraph-source">     - LONG ;</p><p align="left" class="paragraph-source">     - RAW ;</p><p align="left" class="paragraph-source">     - LONG RAW ;</p><p align="left" class="paragraph-source">     - ROWID ;</p><p align="left" class="paragraph-source">     -  MLSLABEL ;</p><p align="left" class="paragraph-source">     - BINARY_INTEGER .</p></div><span id="lnk40c77b853ff74be2b36def33e66de8f3"> </span><div class="section"></div><span id="lnk73d4c22010cb49d98eaf757a5bfe28e6"> </span><div align="center"><div class="inline-table-container"><p align="left" class="unit-title">Таблица 3 - Типы данных </p><table class="inline-table"><col width="130" /><col width="94" /><col width="105" /><col width="236" /><tbody><tr><td style="background-color:#ffffff"><p align="center" class="inline-table"><b>Тип данных</b></p></td><td style="background-color:#ffffff"><p align="center" class="inline-table"><b>Таблицы</b></p></td><td style="background-color:#ffffff"><p align="center" class="inline-table"><b>Переменные PL/SQL</b></p></td><td style="background-color:#ffffff"><p align="center" class="inline-table"><b>Комментарии</b></p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">BINARY_INTEGER</p><p align="left" class="inline-table"></p><p align="left" class="inline-table">              <i>NATURAL</i></p><p align="left" class="inline-table"><i>              POSITIVE</i></p></td><td colspan="2" style="background-color:#ffffff"><p align="left" class="inline-table">[-231-1; 231-1]</p><p align="left" class="inline-table">(-2147483647 .. 2147483647) </p><p align="left" class="inline-table"><i>(0 .. 2147483647)</i></p><p align="left" class="inline-table"><i>(1 .. 2147483647) </i></p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Целые числа со знаком </p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">NUMBER [(точность, масштаб)]</p><p align="left" class="inline-table"><i> DEC </i></p><p align="left" class="inline-table"><i>DECIMAL </i></p><p align="left" class="inline-table"><i> DOUBLE PRECISION </i></p><p align="left" class="inline-table"><i>FLOAT </i></p><p align="left" class="inline-table"><i>SMALLINT </i></p><p align="left" class="inline-table"><i>INT / INTEGER </i></p><p align="left" class="inline-table"><i>NUMERIC REAL</i> </p></td><td colspan="2" style="background-color:#ffffff"><p align="left" class="inline-table">[10-130;9.99*10125]</p><p align="left" class="inline-table">До 38 значащих цифр</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table"></p><p align="left" class="inline-table">Точность - общее число цифрМасштаб - число цифр справа от десятичной точки</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">Boolean</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">НЕТ</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">NULL, TRUE, FALSE</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Не принимает параметров. Нельзя выбирать значения столбцов в Boolean-переменные</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">CHAR <i>[(</i><i>байт)]</i></p><p align="left" class="inline-table"><i>CHARACTER </i></p><p align="left" class="inline-table"><i>STRING</i></p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">1.255</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">До 32767 байт</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Хранит строки <b>фиксированной</b> длины</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">VARCHAR2 (символов)</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">1..2000</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">До 32767 байт</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Хранит символьные строки <b>переменной</b> длины </p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">VARCHAR</p></td><td colspan="2" style="background-color:#ffffff"><p align="left" class="inline-table">Аналог VARCHAR2</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Иное сравнение</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">Long</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">До 2Гб</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">32767 байт</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Нельзя использовать в вызовах функций, фразах SQL: WHERE, GROPU BY и CONNECT BY </p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">RAW (целое число)</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">255 байт</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">32767 байт</p></td><td rowspan="2" style="background-color:#ffffff"><p align="left" class="inline-table">Предназначены для двоичных данных или байтовых строк.</p><p align="left" class="inline-table">НЕИНТЕРПРЕТИРУЕМЫЕ ДАННЫЕ</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">LONG RAW</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">До 2Гб</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">32767 байт</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">DATE</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">1.01.4712 г. до н.э. до 31.12. 4712 г. н.э. </p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">от 1.01.14712 г. до н.э. до 31.12. 314712 г. н.э.</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Хранит значения в виде точек времени (т.е. дату и время. Время хранится в секундах после полуночи. </p></td></tr></tbody></table></div></div><span id="lnk5805e215e0874a8faf9ef065b6e78621"> </span><h2 align="left" class="paragraph-headline-source">     Тип ROWID </h2><span id="lnk7df3e278fabd44c58e45bf3695fd79b5"> </span><div class="section"><p align="justify" class="paragraph-source">     Внутренне, каждая таблица в базе данных ORACLE имеет псевдостолбец ROWID, в котором хранятся 6-байтовые двоичные значения, называемые ИДЕНТИФИКАТОРАМИ СТРОК. Идентификатор строки уникально идентифицирует строку в таблице и предоставляет самый быстрый способ доступа к конкретной строке. Вы используете тип данных ROWID для хранения идентификаторов строк в читабельном формате. </p><p align="justify" class="paragraph-source">     ROWID - это подтип типа CHAR. Поэтому, после выбора или извлечения идентификатора строки в переменную ROWID, вы можете использовать функцию ROWIDTOCHAR, которая преобразует двоичное значение в 18-байтовую символьную строку, возвращая ее в формате </p><p align="justify" class="paragraph-source">BBBBBBBB.RRRR.FFFF <br /></p><p align="left" class="paragraph-source">где BBBBBBBB - номер блока в файле базы данных (блоки нумеруются с 0), <br />RRRR - номер строки в блоке (строки нумеруются с 0), <br />FFFF - номер файла базы данных. </p><p align="left" class="paragraph-source">     Все эти числа шестнадцатеричные. </p></div><span id="lnk1f02862c262b4f18887742294d9a411f"> </span><h2 align="left" class="paragraph-headline-source">     Преобразования типов данных </h2><span id="lnkcfb4a60c37ab4a35a2a567ba93fbea82"> </span><div class="section"><p align="justify" class="paragraph-source">     Иногда бывает необходимо преобразовать значение из одного типа данных в другой. Например, если вы хотите исследовать идентификатор строки, вы должны преобразовать его в символьную строку. PL/SQL поддерживает как явные, так и неявные (автоматические) преобразования типов данных. </p></div><span id="lnkb9d5bf1bf80e4ec99833b7ee25994c4e"> </span><h2 align="left" class="paragraph-headline-source">     Явные преобразования типов </h2><span id="lnk0f227802c8734f0fa15f1253b14174ae"> </span><div class="section"><p align="justify" class="paragraph-source">     Чтобы специфицировать явные преобразования типов, вы используете встроенные функции, которые преобразуют значения из одних типов данных в другие (см.рис 6).</p><p align="justify" class="paragraph-source">     </p></div><span id="lnk9b07492afcf64305b8fac77d8dbfefd1"> </span><div class="section"><p align="center" class="paragraph-source"><img src="../res/files/jpgbe_0__0_.jpeg" height="294px" width="672px" alt="" /> </p><p align="center" class="paragraph-source">Рисунок 6 - Функции преобразования типов данных </p><p align="center" class="paragraph-source">     </p></div><span id="lnk168f3197211e4e019c9c10ea443b6a96"> </span><h2 align="left" class="paragraph-headline-source">     Неявные преобразования типов </h2><span id="lnkc5604ffe858c4a45ba2339ba25fdd487"> </span><div class="section"><p align="justify" class="paragraph-source">     Когда это имеет смысл, PL/SQL преобразует тип данных значения неявно. Это позволяет вам использовать литералы, переменные и параметры одного типа там, где ожидается другой тип. В следующем примере, символьные переменные start_time и finish_time хранят строковые значения, представляющие число секунд после полуночи. </p><p align="justify" class="paragraph-source">     Разность между этими значениями должна быть присвоена числовой переменной elapsed_time. Поэтому PL/SQL неявно преобразует значения CHAR в тип NUMBER. </p></div><span id="lnkd27c94d50e324e6fb311b77e05930372"> </span><table class="note"><tr><td><p align="left" class="note-source">DECLARE <br />start_time CHAR(5); <br />finish_time CHAR(5); <br />elapsed_time NUMBER(5); <br />BEGIN <br />/* Получить системное время <br />в секундах после полуночи. */ <br />SELECT TO_CHAR(SYSDATE, 'SSSSS') INTO start_time FROM sys.dual; <br />-- выполнить какие-нибудь действия <br />/* Снова получить системное время. */ <br />SELECT TO_CHAR(SYSDATE, 'SSSSS') INTO finish_time FROM sys.dual; <br />/* Вычислить затраченное время в секундах. */ <br />elapsed_time := finish_time - start_time; <br />INSERT INTO results VALUES (..., elapsed_time); <br />END; </p></td><th><img src="../../00/styles/files/note_comment.png" title="" alt="" /></th></tr></table><span id="lnk7bb6bfc9ca654ce7a8f523a0139fcde4"> </span><div class="section"><p align="justify" class="paragraph-source">     Перед присваиванием выбранного значения столбца переменной PL/SQL, если необходимо, преобразует это значение из типа данных исходного столбца в тип данных целевой переменной. Это происходит, например, когда вы выбираете значение столбца DATE в переменную VARCHAR2. Аналогично, перед присваиванием или сравнением значения переменной со значением столбца базы данных PL/SQL, если необходимо, преобразует значение из типа данных переменной в тип данных целевого столбца. </p><p align="justify" class="paragraph-source">     Если PL/SQL не может определить, какое неявное преобразование необходимо, вы получите ошибку компиляции. В таких случаях вы должны использовать явные функции преобразования типов данных. </p><p align="justify" class="paragraph-source">     В общем случае, не следует полагаться на неявные преобразования типов данных, потому что они могут повредить производительности и подвержены изменениям от одной версии программного обеспечения к другой. К тому же, неявные преобразования чувствительны к контексту, и потому не всегда предсказуемы. Вместо этого используйте функции преобразования типов данных. Это сделает ваши приложения более надежными и сопровождаемыми. </p></div></div></td></tr></table></td></tr><tr><td id="bottomOuter"><table id="bottomInner"><tr><td class="cell1"><div> </div></td><td class="cell2"><div>© 2012 ХНУРЭ, ПИ, Широкопетлева М.С., <a href="mailto:mshirokopetleva@gmail.com">mshirokopetleva@gmail.com</a>;   ХНУРЭ, ПИ, Черепанова Ю.Ю.;   ХНУРЭ, ПИ, Мазурова О.А.<br /><a href="http://lersus.de/" title="Данный курс создан с помощью авторской системы LERSUS" target="_blank">Разработано с помощью LERSUS</a></div></td></tr></table></td></tr></table></body></html>