<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="LERSUS 3.3.0.0" /><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Корпоративные информационные системы — Теория — Обработчики исключений </title><script language="javascript" type="text/javascript" src="../../00/styles/files/apiwrapper.js"> </script><script language="javascript" type="text/javascript" src="../../00/styles/files/sco.js"> </script><link href="../../00/styles/files/style.css" rel="stylesheet" type="text/css" /></head><body><table id="mainOuter"><tr><td id="topOuter"><table id="topInner"><tr class="row1"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4" id="shortcuts"><div><ul class="level0"><li><a href="../../00/content/authors1.html">Авторы</a></li><li>|</li><li><a href="../../00/content/contacts1.html">Контакты</a></li><li>|</li><li><a href="../../00/content/instructions1.html">Методические указания</a></li><li>|</li><li><a href="../../00/content/annotation1.html">Аннотация</a></li><li>|</li><li><a href="#" onclick="history.back(); return false;">Назад</a></li></ul></div></td></tr><tr class="row2"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4"><div id="courseTitle">Корпоративные информационные системы</div><div id="courseSubTitle">Языки запросов к базам данных : Обработчики исключений </div></td></tr></table></td></tr><tr><td id="contentOuter"><table id="contentInner"><tr><td class="menuOuter"><table class="menuInner"><tr><td><ul class="level0"><li><a href="../../00/styles/courses.html">Содержание курса</a></li><li><span>Теория</span></li><ul class="level1"><li><a href="../../03/content/content1.html">Оптимизация запросов</a></li><li><a href="../../03/content/content2.html">Окружение 4-го поколения</a></li><li><a href="../../03/content/content3.html">Язык PL / SQL. Общие положения </a></li><li><a href="../../03/content/content4.html">Переменные и константы. Кодовое множество</a></li><li><a href="../../03/content/content5.html">Типы данных</a></li><li><a href="../../03/content/content6.html">Команды управления</a></li><li><a href="../../03/content/content7.html">Создание хранимых процедур и функций </a></li><li><a href="../../03/content/content8.html">Параметры подпрограмм</a></li><li><a href="../../03/content/content9.html">Встроенные функции PL / SQL</a></li><li><a href="../../03/content/content10.html">Курсоры</a></li><li><a href="../../03/content/content11.html">Исключительные ситуации</a></li><li><a href="../../03/content/content12.html">Обработчики исключений </a></li><li><a href="../../03/content/content13.html">Пакеты</a></li><li><a href="../../03/content/content14.html">Триггеры объектов </a></li></ul><li><span>Практика</span></li><ul class="level1"><li><a href="../../03/content/example1.html">Практика 2. Использование подпрограмм в языках  программирования 4-го поколения</a></li><li><a href="../../03/content/example2.html">Лабораторная работа 2 Подпрограммы как средство создания серверных частей информационных систем на примере СУБД Oracle </a></li><li><a href="../../03/content/example3.html">Практика 3. Создание  и работа с триггерами объектов и событий</a></li><li><a href="../../03/content/example4.html">Лабораторная работа 3. Триггеры объектов и событий базы данных </a></li></ul><li><span>Текущий контроль знаний</span></li><ul class="level1"><li><a href="../../03/content/multiply-choice-test25.html">Управляющие структуры</a></li><li><a href="../../03/content/multiply-answers-test7.html">Подпрограммы языка PL/SQL</a></li><li><a href="../../03/content/multiply-choice-test1.html">Курсоры</a></li><li><a href="../../03/content/multiply-answers-test12.html">Исключительные ситуации</a></li><li><a href="../../03/content/multiply-choice-test19.html">Пакеты</a></li><li><a href="../../03/content/multiply-answers-test3.html">Триггеры</a></li></ul><li><a href="../../03/styles/glossary.html">Словарь терминов</a></li><li><a href="../../03/03.pdf" target="_blank">Версия для печати</a></li></ul></td></tr></table></td><td class="content"><div id="content"><div id="topBlankStripe"> </div><span id="lnkdca8cd6cbbc04c37a2a00e774893b4c7"> </span><h1 align="left" class="headline-source">     Обработчики исключений </h1><span id="lnk894431ff1d6f43e2b0ed360ae8bec87d"> </span><div class="section"><p align="justify" class="paragraph-source">     Когда возбуждается исключение, нормальное исполнение вашего блока PL/SQL или подпрограммы останавливается, и управление передается на обработчик исключений этого блока или подпрограммы, что оформляется следующим образом: </p><p align="left" class="paragraph-source">... <br />EXCEPTION <br />WHEN имя_исключения1 THEN <br />-- обработчик ряд_предложений1 <br />WHEN имя_исключения2 THEN <br />-- другой обработчик ряд_предложений2 <br />... <br />WHEN OTHERS THEN <br />-- необязательный обработчик ряд_предложений3 <br />END; </p><p align="justify" class="paragraph-source">     Чтобы перехватывать возбуждаемые исключения, вы должны написать обработчики исключений. Каждый обработчик состоит, во-первых, из фразы WHEN, которая специфицирует имя исключения, и, во-вторых, из последовательности предложений, которые будут выполняться при возбуждении этого исключения. Эти предложения завершат исполнение блока или подпрограммы при исключении - управление больше не вернется в точку, где возникло исключение. Иными словами, вы не сможете возобновить работу с того места, где возникло исключение. </p><p align="justify" class="paragraph-source">     Необязательный обработчик исключений OTHERS - всегда последний обработчик исключений в блоке; он действует как обработчик для всех исключений, не перечисленных персонально в этом блоке. Таким образом, блок или подпрограмма может содержать только один обработчик OTHERS. </p></div><span id="lnk75dbaa2c64e14c828af8fd97aafd4718"> </span><table class="note"><tr><td><p align="left" class="note-source">     Рассмотрим следующий пример. Использование обработчика OTHERS гарантирует, что ни одно исключение не пройдет необработанным. </p></td><th><img src="../../00/styles/files/note_problem.png" title="Проблемма" alt="Проблемма" /></th></tr></table><span id="lnk157963127591409b9fe0f8cd5b52e5ea"> </span><div class="section"><p align="left" class="paragraph-source"> ... <br />EXCEPTION <br />WHEN ... THEN <br />-- обработать ошибку <br />WHEN ... THEN <br />-- обработать ошибку <br />WHEN ... THEN <br />-- обработать ошибку <br />WHEN OTHERS THEN <br />-- обработать все прочие ошибки <br />END;      </p></div><span id="lnka3180cfdec864ac1be29ce33c176d9c1"> </span><table class="note"><tr><td><p align="justify" class="note-source">     В следующем примере, процедура заполняет таблицу статистикой о том, на сколько процентов загружены склады. Если исходный объем склада в таблице был определен как нулевой, возбуждается предопределенное исключение ZERO_DIVIDE. Это останавливает нормальное исполнение процедуры и передает управление на обработчик исключений. </p></td><th><img src="../../00/styles/files/note_problem.png" title="Проблемма" alt="Проблемма" /></th></tr></table><span id="lnka570c05a1507415296513a328f2d1300"> </span><div class="section"><p align="left" class="paragraph-source">CREATE OR REPLACE PROCEDURE statistic_ware IS <br />CURSOR c1 IS <br />SELECT ware_id, volume, volume_rest FROM warehouses; <br />vol NUMBER (6,2); -- переменная для подсчета процента занятости склада <br />BEGIN <br />FOR c1rec IN c1 LOOP <br />Vol:=(c1rec.volume- c1rec.volume_rest)/(c1rec.volume/100); -- может вызвать <br />-- ошибку " деление на 0" <br />INSERT INTO Stat_table VALUES (stat_CUR.NEXTVAL, c1rec.ware_id, vol, SYSDATE); <br />END LOOP ; <br />COMMIT; <br />EXCEPTION -- здесь начинаются обработчики исключений <br />WHEN ZERO _ DIVIDE THEN -- обрабатывает "деление на 0" <br />raise_application_error(-20010, Exists warehouse with volume=0'); <br />WHEN OTHERS THEN -- обрабатывает все прочие ошибки <br />ROLLBACK; <br />END statistic _ ware ; -- здесь заканчиваются обработчики исключений и вся процедура </p><p align="justify" class="paragraph-source">     На рисунке 10 приведен пример экранной формы, демонстрирующий вызов процедуры statistic _ ware с обработкой исключительной ситуации. </p><p align="justify" class="paragraph-source">     </p></div><span id="lnk89e0bf790fea456c8d7ae064b7f01925"> </span><div class="section"><p align="center" class="paragraph-source"><img src="../res/files/jpg1c8_0__0_.jpeg" height="340px" width="464px" alt="" /> </p><p align="center" class="paragraph-source">Рисунок  10 - Обработка исключительной ситации </p><p align="center" class="paragraph-source">     </p><p align="justify" class="paragraph-source">     Необязательный обработчик OTHERS перехватывает все исключения, персонально не перечисленные в блоке. </p></div><span id="lnk755940d3bac049c3bbe5a76ceb99f606"> </span><div class="section"><p align="justify" class="paragraph-source">     Если вы хотите выполнять одну и ту же последовательность предложений для двух или более исключений, перечислите имена этих исключений в фразе WHEN, разделяя их ключевым словом OR, как показано ниже: </p><p align="left" class="paragraph-source">... <br />EXCEPTION <br />WHEN over_volume OR under_volume OR VALUE_ERROR THEN <br />-- обработать ошибку <br />... <br />END; </p><p align="justify" class="paragraph-source">     Если будет возбуждено любое из перечисленных в фразе WHEN исключений, соответствующий обработчик получит управление. Включение ключевого слова OTHERS в список имен исключений фразы WHEN НЕ ДОПУСКАЕТСЯ. Слово OTHERS может появиться только само по себе. Вы можете иметь сколько угодно обработчиков исключений, а каждый обработчик может ассоциировать последовательность предложений с любым списком исключений. Однако любое имя исключения может появиться лишь один раз в части обработки исключений блока или подпрограммы PL/SQL. </p><p align="justify" class="paragraph-source">     В обработчике исключений действуют обычные правила сферы видимости идентификаторов, определенные для переменных PL/SQL, так что обработчик может обращаться лишь к локальным и глобальным переменным. Однако, когда исключение возбуждается внутри курсорного цикла FOR, соответствующий курсор неявно закрывается перед вызовом обработчика. Поэтому значения явных атрибутов курсора НЕДОСТУПНЫ в обработчике. </p></div><span id="lnk9aa4b48d161442299917832ab237339c"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Переходы в обработчик и из него </b></p></div><span id="lnk6a7aff9ee45e411687f08c3aa251914d"> </span><div class="section"><p align="justify" class="paragraph-source">     Предложение GOTO нельзя использовать для перехода в обработчик исключений либо для перехода из обработчика исключений в текущий блок. </p></div><span id="lnk440c48dbd9cc4ad0a42a132c5f1abdee"> </span><table class="note"><tr><td><p align="justify" class="note-source">     Например, следующее предложение GOTO НЕЗАКОННО </p></td><th><img src="../../00/styles/files/note_important.png" title="Важно" alt="Важно" /></th></tr></table><span id="lnk100d1997859243c89669d3a7fc1a131e"> </span><div class="section"><p align="left" class="paragraph-source">DECLARE <br />val NUMBER(6,2); <br />BEGIN <br />SELECT volume / volume_rest INTO val FROM warehouses WHERE ware_id=6; <br />-- может возникнуть ошибка деления на 0 <br />&lt;&lt;label1&gt;&gt; <br />INSERT INTO stat VALUES (6, val); <br />EXCEPTION <br />WHEN ZERO_DIVIDE THEN <br />per := 0; <br />GOTO my _ label ; -- незаконный переход в текущий блок <br />END ; </p><p align="justify" class="paragraph-source">     Однако предложение GOTO можно использовать для перехода из обработчика исключения в окружающий блок. </p></div><span id="lnk126d5fe9cc9546b994cf87fa37b7b9f7"> </span><h2 align="left" class="paragraph-headline-source">     Переобъявление предопределенных исключений</h2><span id="lnk7fc817ee5b9f4a7c878a1c05c589ef81"> </span><div class="section"><p align="justify" class="paragraph-source">     Вспомним, что PL/SQL объявляет свои предопределенные исключения глобально, в пакете STANDARD, так что вам не требуется объявлять их самим. Однако переобъявление предопределенного исключения не приведет к ошибке, так как ваше локальное объявление перекрывает глобальное внутреннее объявление. </p></div><span id="lnk14faa210233642d4958e173507a6d94f"> </span><table class="note"><tr><td><p align="justify" class="note-source">     Например, если вы объявите исключение с именем invalid_number, а затем PL/SQL внутренне возбудит предопределенное исключение INVALID_NUMBER, то обработчик, написанный вами для вашего invalid_number, не увидит внутреннего исключения. В таком случае вы должны обращаться к предопределенному исключению с помощью квалифицированной ссылки, как показывает следующий пример. </p></td><th><img src="../../00/styles/files/note_problem.png" title="Проблемма" alt="Проблемма" /></th></tr></table><span id="lnkb30b6348a6774fd3b8e8cce9b47db07c"> </span><div class="section"><p align="left" class="paragraph-source">... <br />EXCEPTION <br />WHEN invalid_number OR STANDARD.INVALID_NUMBER THEN <br />-- обработать ошибку <br />... <br />END; </p></div><span id="lnkd7ea1389884c4228b829f7c78a41fa00"> </span><h2 align="left" class="paragraph-headline-source">     Использование EXCEPTION_INIT</h2><span id="lnk82c76975d01f465b88a288ab61ca856b"> </span><div class="section"><p align="justify" class="paragraph-source">     Для обработки непоименованных внутренних исключений вы должны использовать обработчик OTHER либо прагму EXCEPTION_INIT. ПРАГМА - это директива (указание) компилятору. Прагмы (называемые также псевдоинструкциями) обрабатываются во время компиляции, а не во время выполнения. Они не изменяют смысла программы, а лишь поставляют информацию компилятору. </p><p align="justify" class="paragraph-source">     В PL/SQL, предопределенная прагма EXCEPTION_INIT сообщает компилятору имя исключения, которое вы ассоциируете с конкретным кодом ошибки ORACLE. Это позволяет вам обращаться к любому внутреннему исключению по имени, написав для него специальный обработчик. </p><p align="justify" class="paragraph-source">     Вы кодируете прагму EXCEPTION_INIT в декларативной части блока, подпрограммы или пакета PL/SQL, используя следующий синтаксис: </p><p align="left" class="paragraph-source">PRAGMA EXCEPTION_INIT(имя_исключения, код_ошибки_ORACLE); </p><p align="left" class="paragraph-source">     </p></div><span id="lnkd2ce432d8dc848dd92332420cb659f0b"> </span><table class="note"><tr><td><p align="justify" class="note-source">     Здесь имя_исключения - это имя исключения, ранее уже объявленного в этом блоке. Прагма должна появиться в той же декларативной части, что и соответствующее исключение, как показано в следующем примере: </p></td><th><img src="../../00/styles/files/note_important.png" title="Важно" alt="Важно" /></th></tr></table><span id="lnkb84babccfc9e4029bcd384fcfc22ba34"> </span><div class="section"><p align="left" class="paragraph-source">     </p><p align="left" class="paragraph-source">DECLARE <br />insufficient_privileges EXCEPTION; <br />PRAGMA EXCEPTION_INIT(insufficient_privileges, -1031); <br />-- ORACLE возвращает код ошибки -1031, если, например, <br />-- вы пытаетесь обновить таблицу, для которой имеете <br />-- лишь полномочия SELECT . <br />BEGIN <br />... <br />EXCEPTION <br />WHEN insufficient_privileges THEN <br />-- обработать ошибку <br />... <br />END; </p><p align="justify" class="paragraph-source">     Внутренние исключения возбуждаются неявно исполнительной системой, как и те пользовательские исключения, которые вы ассоциировали с кодами ошибок ORACLE с помощью прагмы EXCEPTION_INIT. Однако остальные пользовательские исключения должны возбуждаться явно, посредством предложений RAISE. </p></div><span id="lnk0a12fad418634b39b722267ac18e4d8c"> </span><h2 align="left" class="paragraph-headline-source">     Использование предложения RAISE </h2><span id="lnk53db4e17b23a471b8831776aebd01fbe"> </span><div class="section"><p align="justify" class="paragraph-source">     Блоки и подпрограммы PL/SQL должны явно возбуждать исключение лишь в том случае, когда ошибка делает невозможным или нежелательным продолжение обработки. Вы можете закодировать предложение RAISE для данного исключения в любом месте сферы этого исключения.</p></div><span id="lnk577438f635dc4e8a9b3a95f87b243452"> </span><table class="note"><tr><td><p align="left" class="note-source">     В следующем примере вы возбуждаете в вашем блоке PL/SQL пользовательское исключение с именем out_of_ volume. </p></td><th><img src="../../00/styles/files/note_problem.png" title="Проблемма" alt="Проблемма" /></th></tr></table><span id="lnk19c3b797f5c54de29ee70b6f8726e128"> </span><div class="section"><p align="justify" class="paragraph-source">      </p><p align="left" class="paragraph-source">DECLARE <br />out_of_volume EXCEPTION; <br />my_volume NUMBER(6,2); <br />BEGIN <br />... <br />IF my_volume &gt; 1000 THEN <br />RAISE out_of_volume; <br />END IF; <br />... <br />EXCEPTION <br />WHEN out_of_volume THEN <br />-- обработать ошибку <br />END; </p><p align="justify" class="paragraph-source">     Вы можете также явно возбуждать предопределенное исключение, как показывает следующий пример: </p><p align="left" class="paragraph-source">RAISE INVALID_NUMBER; </p><p align="justify" class="paragraph-source">     Это позволяет вам использовать обработчики, созданные для предопределенных исключений, для обработки других ошибок, как показывает следующий пример: </p><p align="left" class="paragraph-source">DECLARE <br />Ware_id_my NUMBER(4); <br />... <br />BEGIN <br />... <br />IF Ware_id_my NOT IN (1, 2, 3) THEN <br />RAISE INVALID_NUMBER; <br />END IF; <br />... <br />EXCEPTION <br />WHEN INVALID_NUMBER THEN <br />ROLLBACK; <br />... <br />END; </p></div><span id="lnkf12db465ec3e4cd6b703a2f2ba3b84b7"> </span><div class="section"><p align="left" class="paragraph-source">     Рассмотрим пример использования RAISE </p></div><span id="lnkbec28295c4bb4bc6a9cc6a18b3521995"> </span><table class="note"><tr><td><p align="left" class="note-source">     Доработаем процедуру buy _ goods  и определим в ней исключительную ситуацию, которая возбуждается при продаже товаров оптом, если количество продаваемого товара оказывается меньшим границы в 10 единиц. Такую продажу нужно запретить - это не опт, а пользователя, проводящего эту операцию, зафиксировать в таблице Retail _ buy ( Buy _ id , goods _ id , quantity , Date _ buy , Seller ). </p></td><th><img src="../../00/styles/files/note_problem.png" title="Проблемма" alt="Проблемма" /></th></tr></table><span id="lnkfb14c76538124fb2b317d633a9898e00"> </span><div class="section"><p align="left" class="paragraph-source">CREATE OR REPLACE PROCEDURE buy_goods (good_id1 NUMBER, quantity1 NUMBER) IS <br />Storage _ id 1 NUMBER (4); -- переменная для номера партии <br />ware _ id 1 NUMBER (4); -- переменная для номера склада <br />vol NUMBER (6,2); -- переменная для объема единицы товара <br />Small _ quantity EXCEPTION ; <br />BEGIN <br />-- проверка на исключительную ситуацию <br />IF (quantity1&lt;10) THEN <br />RAISE Small_quantity; <br />END IF; <br />SELECT storage_id, ware_id INTO storage_id1, ware_id1 FROM storages WHERE <br />begin_time IN (SELECT MIN(begin_time) FROM storages <br />WHERE Goods_id=Good_id1 AND quantity&gt;quantity1); <br />-- определяем объем единицы покупаемого товара <br />SELECT volume INTO vol FROM goods WHERE goods_id=good_id1; <br />-- фиксируем покупку части партии товара <br />UPDATE storages SET quantity = quantity - quantity1 WHERE storage_id = storage_id1; <br />--фиксируем освобождение соответствующего объема на складе <br />UPDATE warehouses SET volume_rest = volume_rest + quantity1* vol WHERE ware_id=ware_id1; <br />EXCEPTION <br />WHEN NO_DATA_FOUND THEN <br />INSERT INTO opt_audit VALUES (OPT_CUR.NEXTVAL, good_id1, 'No such goods'); <br />COMMIT; <br />WHEN Small_quantity THEN <br />INSERT INTO Retail_buy VALUES (buy_CUR.NEXTVAL, good_id1, quantity1, SYSDATE, USER); <br />COMMIT; <br />END buy_goods; </p></div><span id="lnkdfee0edb60e74344b0bf5da12929b5ec"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Как распространяются исключения</b></p></div><span id="lnkf106c567ae664ba4a04bb9a2c19b1b26"> </span><div class="section"><p align="justify" class="paragraph-source">     Что происходит, если в текущем блоке нет обработчика исключений для возбужденного исключения? В этом случае блок завершается, а исключение ПРОДВИГАЕТСЯ в окружающий блок. Теперь окружающий блок становится текущим, а исключение воспроизводит себя в нем. Если обработчик исключения не находится и в этом блоке, процесс поиска повторяется. Если текущий блок не имеет окружающего блока, PL/SQL возвращает ошибку "необрабатываемое исключение" в хост-окружение. </p></div><span id="lnkb80e604f609b4e77a0c9b90ab6bb6339"> </span><h2 align="left" class="paragraph-headline-source">     Использование процедуры raise_application_error</h2><span id="lnk94d5980d90584f99ba6b033ec00d011f"> </span><div class="section"><p align="justify" class="paragraph-source">      Пакет с именем DBMS_STANDARD, входящий в состав Процедурного расширения базы данных, предоставляет средства языка, которые помогают вашему приложению взаимодействовать с ORACLE. Этот пакет включает процедуру raise_application_error, которая позволяет вам выдавать определенные вами сообщения об ошибках из хранимой подпрограммы или триггера базы данных. Вызывающее приложение получает при этом исключение PL/SQL, которое оно может обработать с помощью функций сообщений об ошибках SQLCODE и SQLERRM. Более того, оно может использовать прагму EXCEPTION_INIT, чтобы сопоставить специфические номера ошибок, которые возвращает raise_application_error, своим собственным исключениям. </p></div><span id="lnk649e148bcae94103bc42cbb16b8c2319"> </span><h2 align="left" class="paragraph-headline-source">     Необработанные исключения </h2><span id="lnk87d04a6acf3446d1af5da42ca7ed0f08"> </span><div class="section"><p align="justify" class="paragraph-source">     Как объяснялось выше, при невозможности найти обработчик для возбужденного исключения PL/SQL возвращает ошибку "необработанное исключение" в хост-окружение, которое определяет, что делать дальше. </p><p align="justify" class="paragraph-source">     Например, в среде прекомпиляторов ORACLE выполняется откат всех изменений в базе данных, сделанных сбившимся предложением SQL или блоком PL/SQL. </p><p align="justify" class="paragraph-source">     Необработанные исключения могут влиять на транзакции. Перед выполнением блока PL/SQL или хранимой подпрограммы ORACLE устанавливает неявную точку сохранения. Если блок или подпрограмма сбивается в результате необработанного исключения, ORACLE осуществляет откат к этой точке сохранения. Тем самым отменяется вся работа, проделанная блоком или подпрограммой. </p><p align="justify" class="paragraph-source">     Необработанные исключения могут также влиять на подпрограммы. При успешном выходе из подпрограммы PL/SQL присваивает значения параметрам OUT. Однако, если вы выходите в результате необработанного исключения, значения параметрам OUT НЕ присваиваются. Кроме того, как уже сказано, если подпрограмма сбивается в результате необработанного исключения, ORACLE неявно отменяет ее работу. Однако, если подпрограмма выдала COMMIT до возбуждения необрабатываемого исключения, отменена будет лишь неподтвержденная часть работы. </p><p align="justify" class="paragraph-source">     Вы можете избежать необрабатываемых исключений, кодируя обработчик OTHERS на самом верхнем уровне каждого блока PL/SQL и подпрограммы. </p></div><span id="lnk43186c49803a41a9baa72960277d5912"> </span><h2 align="left" class="paragraph-headline-source">     Полезные приемы </h2><span id="lnkc61a1155486e46e99781bc56d7045637"> </span><table class="note"><tr><td><p align="left" class="note-source">     В этом разделе вы узнаете два полезных приема: как продолжить работу после исключения и как повторить транзакцию. </p></td><th><img src="../../00/styles/files/note_comment.png" title="" alt="" /></th></tr></table><span id="lnkee94318aeae14888af2c09a436d0b426"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Продолжение работы после возбуждения исключения</b></p></div><span id="lnkba87517d26624bae86a2a007904c0e63"> </span><div id="see-moreba87517d26624bae86a2a007904c0e63" class="additional"><table border="0"><tr><td><img src="../../00/styles/files/seecollapsed.gif" alt="Смотрите также:" title="Смотрите также:" class="collapse-img" style="width:16px; height:16px;" /></td><td><a href="javascript:seeMore('ba87517d26624bae86a2a007904c0e63');" class="paragraph-source">Смотрите также:</a></td></tr></table><div style="display:none;"><p align="justify" class="note-source">     Обработчик исключений позволяет вам исправить ошибку, которая иначе могла бы стать фатальной, до выхода из блока. Однако если завершить обработчик, то блок больше не получит управления. Вы не можете вернуться в текущий блок из обработчика исключений. Тем не менее, существует способ обработать исключение для предложения, а затем продолжить работу со следующего предложения. Для этого просто поместите предложение в его собственный подблок вместе с его собственными обработчиками исключений, как показано в следующем примере: </p><p align="left" class="note-source">DECLARE <br />val NUMBER(6,2); <br />BEGIN <br />val:=0; <br />---------------- начало подблока ------------------ <br />BEGIN <br />SELECT volume / volume_rest INTO val FROM warehouses WHERE ware_id=6; <br />-- может возникнуть ошибка деления на 0 <br />EXCEPTION <br />WHEN ZERO_DIVIDE THEN <br />val:= 0; <br />END; <br />--------------- конец подблока ------------------- <br />INSERT INTO stat VALUES (6, val); <br />EXCEPTION <br />END ; </p><p align="justify" class="note-source">     Если в подблоке произойдет ошибка, локальный обработчик сможет обработать это исключение. После завершения подблока окружающий блок продолжит выполнение с той точки, где завершился подблок. </p><p align="justify" class="note-source">     В последнем примере, если предложение SELECT INTO вызовет исключение ZERO_DIVIDE, локальный обработчик перехватит его и установит нулевое значение переменной val . После завершения обработчика подблок завершится, и выполнение продолжится с предложения INSERT. </p></div></div><span id="lnk9ac8799c0a6b4efcae58b5796b0eb1f5"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Повторение транзакции </b></p></div><span id="lnkca3b7b4880174f7ca5c39fc6c282ea95"> </span><div id="see-moreca3b7b4880174f7ca5c39fc6c282ea95" class="additional"><table border="0"><tr><td><img src="../../00/styles/files/seecollapsed.gif" alt="Смотрите также:" title="Смотрите также:" class="collapse-img" style="width:16px; height:16px;" /></td><td><a href="javascript:seeMore('ca3b7b4880174f7ca5c39fc6c282ea95');" class="paragraph-source">Смотрите также:</a></td></tr></table><div style="display:none;"><p align="justify" class="note-source">     Когда возникает исключение, вы можете захотеть повторить транзакцию, вместо того чтобы отказаться от нее. Для этого существует простой способ. Сначала заключите транзакцию в подблок. Затем поместите этот подблок в цикл, который повторяет транзакцию. </p><p align="justify" class="note-source">     Рассмотрим следующий пример. </p><p align="justify" class="note-source">     Прежде чем начать транзакцию, вы отмечаете точку сохранения. Если транзакция выполнится успешно, вы выполняете COMMIT и выходите из цикла. Если транзакция сбивается, управление передается обработчику исключений, в котором выполняете откат к точке сохранения, а затем пытаетесь исправить проблему. </p><p align="justify" class="note-source">     Когда обработчик исключений заканчивается, подблок завершается. После этого управление передается на предложение LOOP в окружающем блоке, подблок исполняется повторно, и транзакция повторяется. </p><p align="justify" class="note-source">     Используя цикл FOR или WHILE, вы можете лимитировать число попыток. </p><p align="left" class="note-source">DECLARE <br />name CHAR(20); <br />ans1 CHAR(3); <br />ans2 CHAR(3); <br />ans3 CHAR(3); <br />suffix NUMBER := 1; <br />BEGIN <br />... <br />LOOP <br />-- можно написать " FOR i IN 1..10 LOOP ", чтобы <br />-- ограничиться максимально десятью попытками <br />------------------- начало подблока ------------------- <br />BEGIN <br />... <br />SAVEPOINT start _ transaction ; -- точка сохранения <br />/* Удалить результаты опроса. */ <br />DELETE FROM results WHERE answer1 = 'NO'; <br />/* Добавить имя и ответы респондента. */ <br />INSERT INTO results VALUES (name, ans1, ans2, ans3); <br />/* Это может дать исключение DUP_VAL_ON_INDEX, * <br />* если два респондента имеют одинаковые имена,* <br />* так как индекс по столбцу name уникальный. */ <br />COMMIT; <br />EXIT; <br />EXCEPTION <br />WHEN DUP_VAL_ON_INDEX THEN <br />ROLLBACK TO start_transaction; -- откат <br />suffix := suffix + 1; -- попробуем исправить имя <br />name := name || TO_CHAR(suffix); <br />... <br />END; <br />------------------- конец подблока -------------------- <br />END LOOP; <br /></p><p align="justify" class="note-source">END; </p></div></div><span id="lnk4e28d4b3d0e74a4c9eef0cd1445027f9"> </span><h2 align="left" class="paragraph-headline-source">     Использование функций SQLCODE и SQLERRM</h2><span id="lnk45417667e8d94e9895d87b350f013e9b"> </span><div class="section"><p align="justify" class="paragraph-source">     В обработчике исключений можно использовать функции SQLCODE и SQLERRM, чтобы узнать, какая ошибка произошла и получить сообщение об ошибке. </p><p align="justify" class="paragraph-source">     Для внутренне определенных исключений, SQLCODE возвращает номер ошибки ORACLE, передавшей управление обработчику. Этот номер отрицателен, исключая случай ошибки ORACLE "no data found", когда SQLCODE возвращает +100. </p><p align="justify" class="paragraph-source">     SQLERRM возвращает сообщение, ассоциированное с возникшей ошибкой ORACLE. Это сообщение начинается с кода ошибки ORACLE. </p><p align="justify" class="paragraph-source">     Для пользовательских исключений, SQLCODE возвращает +1, а SQLERRM возвращает сообщение User-Defined Exception, если вы не использовали прагму EXCEPTION_INIT, чтобы ассоциировать ваше исключение с номером ошибки ORACLE; в этом случае SQLCODE возвращает этот номер ошибки, а SQLERRM возвращает соответствующее сообщение об ошибке. Заметим, что максимальная длина сообщения ORACLE об ошибке составляет 512 символов, включая код ошибки, вложенные сообщения и подстановки, такие как имена таблиц и столбцов. Если не возбуждено никакое исключение, то SQLCODE возвращает 0, а SQLERRM возвращает сообщение ORA-0000: normal, successful completion </p><p align="justify" class="paragraph-source">     Вы можете передать функции SQLERRM номер ошибки; в этом случае SQLERRM возвратит сообщение, ассоциированное с этим номером ошибки. </p><p align="justify" class="paragraph-source">     Номер ошибки, передаваемый SQLERRM, должен быть отрицателен. Нулевой код, передаваемый SQLERRM, всегда возвращает сообщение </p><p align="left" class="paragraph-source">ORA-0000: normal, successful completion </p><p align="justify" class="paragraph-source">     Передача SQLERRM положительного номера ошибки (за исключением +100) всегда возвратит сообщение </p><p align="left" class="paragraph-source">User-Defined Exception </p><p align="left" class="paragraph-source">а передача SQLERRM кода +100 возвратит сообщение </p><p align="left" class="paragraph-source">ORA -01403: no data found . </p><p align="justify" class="paragraph-source">     В следующем примере, SQLERRM возвратит не то, что ожидалось, потому что передается положительное значение вместо отрицательного: </p><p align="left" class="paragraph-source">DECLARE <br />msg CHAR(100); <br />BEGIN <br />FOR num IN 1..9999 LOOP <br />msg := SQLERRM(num); -- надо задавать SQLERRM(-num) <br />INSERT INTO errors VALUES (msg); <br />END LOOP; <br />END; </p><p align="left" class="paragraph-source">     </p></div><span id="lnk8edbc4b0909c47d6ac26f460157956a7"> </span><div class="section"><p align="justify" class="paragraph-source">     Вы не можете использовать функции SQLCODE и SQLERRM непосредственно в предложениях SQL. Например, следующее предложение незаконно: </p><p align="left" class="paragraph-source">INSERT INTO errors VALUES (SQLCODE, SQLERRM); </p><p align="justify" class="paragraph-source">     Вместо этого вы должны присвоить значения этих функций локальным переменным, а затем использовать эти переменные в ваших предложениях SQL, как показывает следующий пример: </p><p align="left" class="paragraph-source">DECLARE <br />err_num NUMBER; <br />err_msg CHAR(100); <br />BEGIN <br />... <br />EXCEPTION <br />... <br />WHEN OTHERS THEN err_num := SQLCODE; <br />err_msg := SUBSTR(SQLERRM, 1, 100); <br />INSERT INTO errors VALUES (err_num, err_msg); <br />END; </p><p align="justify" class="paragraph-source">     Строковая функция SUBSTR() гарантирует, что возможное усечение при присваивании переменной err_msg не возбудит исключения VALUE_ERROR. Функции SQLCODE и SQLERRM особенно полезны в исключении OTHERS, потому что они позволяют установить, какое внутреннее исключение было возбуждено. </p></div><span id="lnka18bb99831804ba7a6e4b297ab343720"> </span><h2 align="left" class="paragraph-headline-source">     Повторное возбуждение исключения </h2><span id="lnkb0c8255d0c1a4689a66a1edfd635f34a"> </span><div class="section"><p align="justify" class="paragraph-source">     Иногда вам требуется повторно возбудить исключение, т.е. сначала обработать его локально, а затем заставить его продвинуться в окружающий блок. Например, вы можете захотеть отменить транзакцию в текущем блоке, а потом зарегистрировать ошибку в окружающем блоке. </p><p align="justify" class="paragraph-source">     Чтобы повторно возбудить исключение, поместите предложение RAISE в локальный обработчик этого исключения, как показано в следующем примере: </p><p align="left" class="paragraph-source">DECLARE <br />out_of_volume EXCEPTION; <br />BEGIN <br />... ---------------- начало подблока ------------------------- <br />BEGIN <br />... <br />IF ... THEN RAISE out_of_volume; -- возбудить исключение <br />END IF; <br />... <br />EXCEPTION <br />WHEN out_of_volume THEN -- обработать ошибку RAISE; <br />-- повторно возбудить текущее исключение ... <br />END; ---------------- конец подблока -------------------------- <br />EXCEPTION <br />WHEN out_of_volume THEN -- обработать ошибку иным способом <br />END; </p><p align="justify" class="paragraph-source">     Если опустить имя исключения в предложении RAISE (что допускается только в обработчике исключений), то подразумевается текущее исключение </p><p align="justify" class="paragraph-source">     Исключения могут также возбуждаться некорректными выражениями инициализации в объявлениях. </p><p align="justify" class="paragraph-source">     Например, следующее объявление неявно возбуждает исключение VALUE_ERROR, потому что limit не может хранить числа, большие 999: </p><p align="left" class="paragraph-source">DECLARE <br />limit CONSTANT NUMBER(3):= 5000; -- возбуждает исключение VALUE_ERROR <br />BEGIN <br />... <br />EXCEPTION <br />WHEN VALUE _ ERROR THEN -- не перехватит это исключение <br />... <br />END; </p><p align="justify" class="paragraph-source">     Обработчики в текущем блоке не могут перехватывать исключений, возбужденных в объявлениях, потому что такое исключение НЕМЕДЛЕННО продвигается в окружающий блок. </p><p align="justify" class="paragraph-source">     Лишь одно исключение в каждый момент времени может быть активно в части обработки исключений блока или подпрограммы. Так, исключение, возбужденное внутри обработчика, немедленно продвигается в окружающий блок, который просматривается на предмет обнаружения обработчика для вновь возбужденного исключения. С этого момента исключение продвигается обычным образом. </p></div></div></td></tr></table></td></tr><tr><td id="bottomOuter"><table id="bottomInner"><tr><td class="cell1"><div> </div></td><td class="cell2"><div>© 2012 ХНУРЭ, ПИ, Широкопетлева М.С., <a href="mailto:mshirokopetleva@gmail.com">mshirokopetleva@gmail.com</a>;   ХНУРЭ, ПИ, Черепанова Ю.Ю.;   ХНУРЭ, ПИ, Мазурова О.А.<br /><a href="http://lersus.de/" title="Данный курс создан с помощью авторской системы LERSUS" target="_blank">Разработано с помощью LERSUS</a></div></td></tr></table></td></tr></table></body></html>