<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="LERSUS 3.3.0.0" /><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Корпоративные информационные системы — Теория — Триггеры объектов </title><script language="javascript" type="text/javascript" src="../../00/styles/files/apiwrapper.js"> </script><script language="javascript" type="text/javascript" src="../../00/styles/files/sco.js"> </script><link href="../../00/styles/files/style.css" rel="stylesheet" type="text/css" /></head><body><table id="mainOuter"><tr><td id="topOuter"><table id="topInner"><tr class="row1"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4" id="shortcuts"><div><ul class="level0"><li><a href="../../00/content/authors1.html">Авторы</a></li><li>|</li><li><a href="../../00/content/contacts1.html">Контакты</a></li><li>|</li><li><a href="../../00/content/instructions1.html">Методические указания</a></li><li>|</li><li><a href="../../00/content/annotation1.html">Аннотация</a></li><li>|</li><li><a href="#" onclick="history.back(); return false;">Назад</a></li></ul></div></td></tr><tr class="row2"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4"><div id="courseTitle">Корпоративные информационные системы</div><div id="courseSubTitle">Языки запросов к базам данных : Триггеры объектов </div></td></tr></table></td></tr><tr><td id="contentOuter"><table id="contentInner"><tr><td class="menuOuter"><table class="menuInner"><tr><td><ul class="level0"><li><a href="../../00/styles/courses.html">Содержание курса</a></li><li><span>Теория</span></li><ul class="level1"><li><a href="../../03/content/content1.html">Оптимизация запросов</a></li><li><a href="../../03/content/content2.html">Окружение 4-го поколения</a></li><li><a href="../../03/content/content3.html">Язык PL / SQL. Общие положения </a></li><li><a href="../../03/content/content4.html">Переменные и константы. Кодовое множество</a></li><li><a href="../../03/content/content5.html">Типы данных</a></li><li><a href="../../03/content/content6.html">Команды управления</a></li><li><a href="../../03/content/content7.html">Создание хранимых процедур и функций </a></li><li><a href="../../03/content/content8.html">Параметры подпрограмм</a></li><li><a href="../../03/content/content9.html">Встроенные функции PL / SQL</a></li><li><a href="../../03/content/content10.html">Курсоры</a></li><li><a href="../../03/content/content11.html">Исключительные ситуации</a></li><li><a href="../../03/content/content12.html">Обработчики исключений </a></li><li><a href="../../03/content/content13.html">Пакеты</a></li><li><a href="../../03/content/content14.html">Триггеры объектов </a></li></ul><li><span>Практика</span></li><ul class="level1"><li><a href="../../03/content/example1.html">Практика 2. Использование подпрограмм в языках  программирования 4-го поколения</a></li><li><a href="../../03/content/example2.html">Лабораторная работа 2 Подпрограммы как средство создания серверных частей информационных систем на примере СУБД Oracle </a></li><li><a href="../../03/content/example3.html">Практика 3. Создание  и работа с триггерами объектов и событий</a></li><li><a href="../../03/content/example4.html">Лабораторная работа 3. Триггеры объектов и событий базы данных </a></li></ul><li><span>Текущий контроль знаний</span></li><ul class="level1"><li><a href="../../03/content/multiply-choice-test25.html">Управляющие структуры</a></li><li><a href="../../03/content/multiply-answers-test7.html">Подпрограммы языка PL/SQL</a></li><li><a href="../../03/content/multiply-choice-test1.html">Курсоры</a></li><li><a href="../../03/content/multiply-answers-test12.html">Исключительные ситуации</a></li><li><a href="../../03/content/multiply-choice-test19.html">Пакеты</a></li><li><a href="../../03/content/multiply-answers-test3.html">Триггеры</a></li></ul><li><a href="../../03/styles/glossary.html">Словарь терминов</a></li><li><a href="../../03/03.pdf" target="_blank">Версия для печати</a></li></ul></td></tr></table></td><td class="content"><div id="content"><div id="topBlankStripe"> </div><span id="lnkbb2182d94a934d4e9cd78656c4adb6a5"> </span><h1 align="left" class="headline-source">     Триггеры объектов </h1><span id="lnkb1d677591042402b9a49e48c210825b4"> </span><div class="section"><p align="justify" class="paragraph-source">     ORACLE позволяет определять процедуры, которые неявно выполняются, когда для ассоциированной таблицы выдается предложение INSERT, UPDATE или DELETE. Такие процедуры называются <i><b>триггерами базы данных</b></i>. </p><p align="justify" class="paragraph-source">     Триггеры аналогичны хранимым процедурам. Триггер может состоять из предложений SQL и PL/SQL, исполняемым как единица, и может вызывать другие хранимые процедуры. Однако процедуры и триггеры различаются по способу их вызова. В то время как процедура явно вызывается пользователем или приложением, триггер неявно ВОЗБУЖДАЕТСЯ (исполняется) ORACLE, когда выдается предложение INSERT, UPDATE или DELETE, независимо от того, какой пользователь сейчас подключен или какое приложение используется. </p><p align="justify" class="paragraph-source">     Триггеры создаются с помощью команды CREATE TRIGGER. Эту команду можно использовать в любом интерактивном инструменте (таком как SQL*Plus или SQL*DBA); при использовании в таких инструментах, одиночная наклонная черта ("/"), вводимая как последняя строка, обозначает конец предложения CREATE TRIGGER. </p><p align="justify" class="paragraph-source">     Предложение CREATE собъется, если в блоке PL/SQL будут обнаружены ошибки. </p><p align="justify" class="paragraph-source">     Имена триггеров должны быть уникальными среди всех триггеров в той же схеме. Имена триггеров не обязаны быть уникальными по отношению к другим объектам схемы (таких как таблицы, обзоры, процедуры); например, таблица и триггер могут иметь одно и то же имя (хотя, во избежание путаницы, это не рекомендуется). </p><p align="justify" class="paragraph-source">     Например, рисунок 11 показывает приложение базы данных с некоторыми предложениями SQL, которые неявно возбуждают несколько триггеров, хранящихся в базе данных. </p><p align="justify" class="paragraph-source">     </p></div><span id="lnk46e191c9342f4893a8548b2802b6c87f"> </span><div class="section"><p align="center" class="paragraph-source"><img src="../res/files/jpg107_0__0_.jpeg" height="184px" width="603px" alt="" /><b> </b></p><p align="center" class="paragraph-source"></p><p align="center" class="paragraph-source">Рисунок 11 - Вызов триггеров из приложения базы данных </p><p align="center" class="paragraph-source">     </p></div><span id="lnke9a26942038e454e961604d6e339ef3f"> </span><div class="section"><p align="justify" class="paragraph-source">     Необходимо заметить, что триггеры хранятся в базе данных отдельно от таблиц, с которыми они ассоциированы. </p><p align="justify" class="paragraph-source">     Триггеры можно определять только на таблицах (до появления Oracle 9), но не на обзорах. Однако при выдаче предложения INSERT, UPDATE или DELETE для обзора будут возбуждены триггеры для базовых таблиц этого обзора, если они были определены. </p><p align="justify" class="paragraph-source">     В данном курсе рассмотрим триггеры объектов на прмиере триггеров таблиц. Триггеры, определенные на представлениях аналогичны триггерам таблиц, но при их создании используется опция INSTEAD OF, показывающая, что будут затронуты только данные обзора,  например:</p><p align="justify" class="paragraph-source">CREATE OR REPLACE TRIGGER T1 <b>INSTEAD OF </b>INSERT ON VIEW1 </p></div><span id="lnk3db32285f5134d4699a4de79dbcd0dd0"> </span><h2 align="left" class="paragraph-headline-source">     Синтаксис команды создания триггера</h2><span id="lnk92835818782e46c68fb9dcb8d0c162a5"> </span><div class="section"><p align="left" class="paragraph-source">     Синтаксис команды создания триггера следующий: </p><p align="left" class="paragraph-source">CREATE TRIGGER имя триггера <br />BEFORE/AFTER INSERT/UPDATE/DELETE ON имя таблицы -- предложение триггера <br />[ FOR EACH ROW ] --предложение триггера <br />[ WHEN условие ограничения триггера] -- ограничение триггера <br />BEGIN <br />-- действие триггера <br />END; </p><p align="left" class="paragraph-source">     Таким образом, триггер имеет три основные части: </p><p align="left" class="paragraph-source">     а) событие, или предложение, триггера; </p><p align="left" class="paragraph-source">     б) ограничение триггера; </p><p align="left" class="paragraph-source">     в) действие триггера. </p></div><span id="lnk24f8314947304306a7afc237bbd54c6d"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Опции BEFORE/AFTER </b></p></div><span id="lnkbfba3279706b4a649e2abdb05e00a5de"> </span><div class="section"><p align="justify" class="paragraph-source">     Либо опция BEFORE, либо опция AFTER должна быть указана в предложении CREATE TRIGGER, чтобы точно специфицировать, когда должно исполняться тело триггера по отношению к исполнению предложения триггера. В предложении CREATE TRIGGER опция BEFORE или AFTER задается непосредственно перед ключевым словом, обозначающим предложение триггера. Например, триггер DUMMY, который был определен в предыдущем примере, является триггером BEFORE. </p><p align="justify" class="paragraph-source">     Триггеры строк AFTER несколько более эффективны, чем триггеры строк BEFORE. При триггерах строк BEFORE, затрагиваемые блоки данных должны быть считаны (логической, а не физической, операцией чтения) один раз для триггера и еще один раз для предложения триггера. Альтернативно, при триггерах строк AFTER, затрагиваемые блоки данных должны быть считаны лишь один раз, сразу для предложения триггера и для самого триггера. </p></div><span id="lnk6c490c97b47542bfa4853ed0c93cc62d"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Событие, или предложение, триггера </b></p></div><span id="lnk2ace272849d048feaf4f681fcb669924"> </span><div class="section"><p align="left" class="paragraph-source">     Предложение триггера специфицирует: </p><p align="justify" class="paragraph-source">     - Тип предложения SQL, которое возбуждает тело триггера. Допустимыми возможностями являются DELETE, INSERT и UPDATE. В спецификацию предложения триггера могут быть включены одна, две или все три этих опции. </p><p align="justify" class="paragraph-source">     - Таблицу, ассоциированную с триггером. Заметьте, что в предложении триггера может быть специфицирована ровно одна таблица (но не обзор). </p><p align="justify" class="paragraph-source">     Событие триггера, или предложение триггера, - это предложение SQL, которое заставляет триггер выполниться. Событием триггера может быть предложение INSERT, UPDATE или DELETE для конкретной таблицы. </p><p align="left" class="paragraph-source">     Например, для триггера </p><p align="left" class="paragraph-source">TRIGGER update_stor </p><p align="left" class="paragraph-source">BEFORE UPDATE OF Quantity ON Storages </p><p align="left" class="paragraph-source">FOR EACH ROW </p><p align="left" class="paragraph-source">WHEN (new.quantity&lt;10) </p><p align="left" class="paragraph-source">предложением триггера является : </p><p align="left" class="paragraph-source">… UPDATE OF Quantity ON Storages … </p><p align="left" class="paragraph-source">которое означает, что триггер возбуждается при обновлении столбца Quantity в строке таблицы Storages . </p></div><span id="lnk86fd0a247c21408fb330a15e87a3711c"> </span><div class="section"><p align="justify" class="paragraph-source">     Заметьте , что , когда событием триггера является предложение UPDATE, вы можете включить список столбцов, чтобы указать, обновление каких столбцов возбуждает триггер; поскольку предложения INSERT и DELETE действуют на целые строки данных, то для таких предложений нельзя специфицировать список столбцов. </p><p align="justify" class="paragraph-source">     Если предложение триггера специфицирует UPDATE, то в эту спецификацию может быть включен необязательный список столбцов. Если включается список столбцов, то данный триггер возбуждается по предложению UPDATE лишь тогда, когда это предложение обновляет один из перечисленных столбцов. Если пользователь опускает список столбцов, то триггер возбуждается при обновлении любого столбца ассоциированной таблицы. Список столбцов не может быть специфицирован для предложений триггера INSERT или DELETE. </p><p align="justify" class="paragraph-source">     Событие триггера может специфицировать несколько предложений DML, например: </p><p align="left" class="paragraph-source">INSERT OR UPDATE OR DELETE OF Storages ... </p><p align="justify" class="paragraph-source">что означает, что триггер должен возбуждаться при выдаче предложения INSERT, UPDATE или DELETE для таблицы Storages . </p><p align="justify" class="paragraph-source">     Когда триггер может возбуждаться несколькими предложениями DML, внутри триггера можно использовать предикаты условий для определения типа предложения, возбудившего триггер; поэтому можно создать один триггер, который будет выполнять разные коды в зависимости от того, какой тип предложения возбудил триггер. </p></div><span id="lnka813108df8f54f8fb85416fe382770b4"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Опция FOR EACH ROW </b></p></div><span id="lnk3dfc44514cb94c5e84bbf7ed355757ae"> </span><div class="section"><p align="justify" class="paragraph-source">     Присутствие или отсутствие опции FOR EACH ROW определяет, является ли этот триггер триггером предложения или триггером строки. Если эта опция включена, она указывает, что тело триггера возбуждается отдельно для каждой строки таблицы, затрагиваемой предложением триггера. Отсутствие опции FOR EACH ROW указывает, что данный триггер должен возбуждаться лишь один раз для предложения триггера. </p></div><span id="lnkebd264c7c986438a9f6aadfe1cbaa02f"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Ограничение триггера </b></p></div><span id="lnk4dcde6a042eb4883bd2d871177697f36"> </span><div class="section"><p align="justify" class="paragraph-source">     Ограничение триггера задает булевское (логическое) выражение, которое должно быть истинным (TRUE) для того, чтобы триггер возбудился. Действие триггера не выполняется, если ограничение триггера дает ложь (FALSE). </p><p align="justify" class="paragraph-source">     Ограничение триггера - это необязательная возможность, которая используется в триггерах, возбуждаемых по каждой строке. Цель ограничения - наложить условие на выполнение триггера. Ограничение триггера задается с помощью фразы WHEN. </p><p align="justify" class="paragraph-source">     В определение триггера строки может быть включено необязательное ограничение триггера, путем специфицирования булевского выражения SQL в фразе WHEN (фраза WHEN не может быть включена в определение триггера предложения). Выражение в фразе WHEN, если эта фраза присутствует, вычисляется для каждой строки, затрагиваемой триггером. Если результат выражения дает TRUE для строки, то тело триггера исполняется для этой строки. Однако, если это выражение вычисляется для строки как FALSE или NULL, то тело триггера не исполняется для этой строки. Вычисление условия фразы WHEN не влияет на исполнение самого предложения триггера (т.е. предложение триггера НЕ откатывается, если выражение в фразе WHERE вычисляется как FALSE). </p><p align="justify" class="paragraph-source">     Например, триггер update _ stor имеет ограничение триггера. Этот триггер возбуждается предложением UPDATE, действующим на столбец quantity таблицы Storages , но выполнен этот триггер будет лишь при следующем условии: </p><p align="left" class="paragraph-source">new.quantity&lt;10) </p></div><span id="lnkaf8d9118ac20459fb6923597babd367f"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Действие триггера </b></p></div><span id="lnk535db71a8cdc4fadae3a765c239d0119"> </span><div class="section"><p align="justify" class="paragraph-source">     <i><b>Действие триггер</b></i>а - это процедура (блок PL/SQL), содержащая предложения SQL и PL/SQL, которые будут выполнены, если выдано предложение триггера, а ограничение триггера вычислено как TRUE. Для триггеров строк тело триггера имеет некоторые специальные конструкты, которые могут быть включены в код этого блока PL/SQL: </p><p align="justify" class="paragraph-source">     а) корреляционные имена ; </p><p align="justify" class="paragraph-source">     б) опцию REFERENCING ; </p><p align="justify" class="paragraph-source">     в) условные предикаты INSERTING, DELETING и UPDATING. </p><p align="justify" class="paragraph-source">     Эти предложения исполняются тогда, когда выдано предложение триггера, и ограничение триггера (если оно есть) вычислено как TRUE. </p><p align="justify" class="paragraph-source">     Аналогично хранимым процедурам, действие триггера может содержать предложения как SQL, так и PL/SQL; может определять языковые конструкты PL/SQL (переменные, константы, курсоры, исключения и т.п.); и может вызывать хранимые процедуры. Кроме того, для триггеров строки, предложения в действии триггера имеют доступ как к новым, так и к старым значениям столбцов текущей строки, обрабатываемой триггером (см. ниже). </p><p align="justify" class="paragraph-source">     Тело триггера может содержать любые предложения DML, включая предложения SELECT (только SELECT ... INTO или предложения SELECT в определениях курсоров), INSERT, UPDATE и DELETE; в теле триггера не допускаются предложения DDL. Нельзя также управлять транзакциями в контексте триггера. Поэтому внутри контекста тела триггера не допускаются следующие предложения: ROLLBACK, COMMIT и SAVEPOINT. </p><p align="justify" class="paragraph-source">     Процедура, вызываемая из триггера, также не может выполнять перечисленных выше предложений управления транзакциями, ибо такая процедура исполняется внутри контекста тела триггера. Предложения внутри триггера могут адресоваться к удаленным объектам. Требуется особое внимание при вызове удаленных процедур из локального триггера; если во время выполнения триггера будет обнаружено несовпадение отметок времени, то удаленная процедура не выполняется, а триггер станет недействительным. </p></div><span id="lnkc8c4556b6b7c4e0c96376d9a4192f26b"> </span><h2 align="left" class="paragraph-headline-source">     Типы триггеров </h2><span id="lnk778deeada6c54d0bb68eed697b6a2818"> </span><div class="section"><p align="left" class="paragraph-source">     Рассмотрим разные типы триггеров.</p></div><span id="lnkd477f8e923e44c10ae3440b1679b27e3"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Опция FOR EACH ROW </b></p></div><span id="lnkc53668c328f24b3e8e704f558f39d14f"> </span><div class="section"><p align="justify" class="paragraph-source">     При определении триггера, можно указать, сколько раз должно исполняться действие триггера: один раз для каждой строки, обрабатываемой предложением триггера (как, например, для предложения UPDATE, обновляющего несколько строк), или один раз на все предложение триггера, независимо от того, сколько строк оно обрабатывает. </p><p align="justify" class="paragraph-source">     Триггер строки возбуждается каждый раз, когда предложение триггера действует на таблицу. Например, если предложение UPDATE обновляет несколько строк таблицы, то триггер строки возбуждается один раз для каждой строки, обновляемой предложением UPDATE. Если предложение триггера не затрагивает ни одной строки, то триггер строки вообще не возбуждается. </p><p align="justify" class="paragraph-source">     Триггеры строки полезны, когда действие триггера зависит от данных, предоставляемых либо предложением триггера, либо строкой, на которую воздействует это предложение. </p><p align="justify" class="paragraph-source">     Триггер предложения возбуждается один раз на предложение триггера, независимо от того, сколько строк таблицы затрагивается этим предложением (даже если не затрагивается ни одной строки). Например, если предложение DELETE удаляет из таблицы несколько строк, то триггер DELETE на уровне предложения возбуждается лишь один раз. </p></div><span id="lnk053caea69d1f430c8e3c9a05501956cf"> </span><div class="section"><p align="justify" class="paragraph-source">     Триггеры предложения полезны, если действие триггера не зависит от данных, предоставляемых предложением триггера, или от данных строк, обрабатываемых этим предложением. Например, если триггер осуществляет комплексную проверку защиты для текущего момента времени или текущего пользователя, или если триггер генерирует одиночную запись аудитинга на основе типа предложения триггера, то используется триггер предложения. </p><p align="justify" class="paragraph-source">     При определении триггера вы можете указать МОМЕНТ ТРИГГЕРА, то есть специфицировать, когда должно выполняться действие триггера по отношению к предложению триггера: перед (BEFORE) или после (AFTER) выполнения предложения триггера. BEFORE и AFTER применимы как к триггерам предложения, так и к триггерам строки. </p><p align="justify" class="paragraph-source">     Триггеры BEFORE выполняют действие триггера перед предложением триггера. Этот тип триггера обычно используется в следующих ситуациях: </p><p align="justify" class="paragraph-source">      - если действие триггера должно определять, можно ли разрешать выполнение предложения триггера. Используя для этой цели триггер BEFORE, вы можете избежать ненужной обработки предложения триггера и его последующего отката в случаях, когда в действии триггера возбуждается исключение; </p><p align="justify" class="paragraph-source">      - для вычисления специфических значений столбцов перед выполнением предложений INSERT или UPDATE. </p><p align="justify" class="paragraph-source">     Триггеры AFTER выполняют действие триггера после предложения триггера. Этот тип триггера используется в следующих ситуациях: </p><p align="justify" class="paragraph-source">      - если вы хотите, чтобы предложение триггера было завершено до выполнения действия триггера; </p><p align="justify" class="paragraph-source">      - если триггер BEFORE тоже присутствует, то триггер AFTER может выполнять другие действия для того же самого предложения триггера. </p></div><span id="lnk7103a82abbd845158bdee1167e97bdce"> </span><div class="section"><p align="justify" class="paragraph-source">     Используя возможности, указанные выше, вы можете создавать четыре типа триггеров: </p><p align="justify" class="paragraph-source">     - триггер предложения BEFORE - действие триггера выполняется перед выполнением предложения триггера. </p><p align="justify" class="paragraph-source">     - триггер строки BEFORE - действие триггера выполняется перед модификацией каждой строки, затрагиваемой предложением триггера, и перед проверкой соответствующих ограничений целостности, если ограничение триггера вычисляется как TRUE или не включено.</p><p align="justify" class="paragraph-source">     - триггер предложения AFTER - действие триггера выполняется после выполнения предложения триггера и применения любых отложенных ограничений целостности.</p><p align="justify" class="paragraph-source">      - триггер строки AFTER - действие триггера выполняется после модификации каждой строки, затрагиваемой предложением триггера, и после проверки соответствующих ограничений целостности, если ограничение триггера вычисляется как TRUE или не включено. В отличие от триггеров строки BEFORE, триггеры строки AFTER выполняются в состоянии, когда строки таблицы заблокированы. </p><p align="justify" class="paragraph-source">     </p></div><span id="lnkc7edcd1042c14fc3a33d126fb71c3ebe"> </span><h2 align="left" class="paragraph-headline-source">     Доступ к значениям столбцов в триггерах строки </h2><span id="lnk364a91becda24a8a922aa6ebf8ca14a4"> </span><div class="section"><p align="justify" class="paragraph-source">     Внутри тела тригга строк, код PL/SQL и предложения SQL имеют доступ как к старым, так и к новым значениям столбцов текущей строки, затрагиваемой предложением триггера. Для каждого столбца модифицируемой таблицы определены два <i><b>корреляционных имени</b></i>: одно для старого (old), другое - для нового значения столбца (new). В зависимости от типа предложения триггера, то или иное корреляционное имя может быть лишено смысла: </p><p align="justify" class="paragraph-source">     - Триггер, возбужденный предложением INSERT, имеет осмысленный доступ лишь к новым значениям столбцов. Поскольку строка создается предложением INSERT, старые значения столбцов пусты (NULL). </p><p align="justify" class="paragraph-source">     - Триггер, возбужденный предложением UPDATE, имеет доступ как к старым, так и к новым значениям столбцов для обоих возможных типов триггера (BEFORE или AFTER). </p><p align="justify" class="paragraph-source">     - Триггер, возбужденный предложением DELETE, имеет осмысленный доступ лишь к старым значениям столбцов. Поскольку строка перестает существовать после ее удаления, новые значения столбцов пусты (NULL). </p><p align="justify" class="paragraph-source">     Например, если предложение триггера ассоциировано с таблицей Storages , содержащей столбцы Quantity , Ware _ id и т.д., то вы можете включить в тело триггера предложения, подобные следующим: </p><p align="left" class="paragraph-source">IF :new.ware_id =15 . . . </p><p align="left" class="paragraph-source">IF :new.quantity &lt; :old.quantity . . . </p></div><span id="lnk62010ca52c1b44e0b0e6f75ea116b5b3"> </span><div class="section"><p align="justify" class="paragraph-source">     Старые и новые значения доступны как в триггерах BEFORE, так и в триггерах AFTER. Назначать новое значение столбца можно в триггере строк BEFORE, но не в триггере строк AFTER (потому что предложение триггера уже выполнено, прежде чем триггер AFTER получает управление). Если триггер строк BEFORE изменяет значение NEW для столбца, то триггер AFTER, возбужденный тем же самым предложением, видит значение, которое было назначено триггером BEFORE. </p><p align="justify" class="paragraph-source">     Корреляционные имена могут также использоваться в булевском выражении фразы WHEN. Следует заметить, что перед квалификаторами OLD и NEW должно кодироваться двоеточие, когда они используются в теле триггера, но двоеточие не допускается, когда эти квалификаторы используются в фразе WHEN или опции REFERENCING. </p><p align="justify" class="paragraph-source">     Опция REFERENCING может специфицироваться в теле триггера строк для того, чтобы избежать конфликтов между корреляционными именами и именами таблиц, в случае, если таблица имеет имя "OLD" или "NEW". Поскольку такая ситуация редка, эта опция почти никогда не применяется. </p><p align="justify" class="paragraph-source">     Например, предположим, что у вас есть таблица с именем NEW, содержащая столбцы FIELD1 (числовой) и FIELD2 (символьный). Следующее предложение CREATE TRIGGER показывает триггер, ассоциированный с таблицей NEW, который использует опцию REFERENCING, чтобы избежать конфликтов между корреляционными именами и именем таблицы: </p><p align="left" class="paragraph-source">CREATE TRIGGER dummy <br />BEFORE UPDATE ON new REFERENCING new AS newest <br />FOR EACH ROW <br />BEGIN <br />:newest.field2 := TO_CHAR (:newest.field1); <br />END; </p><p align="left" class="paragraph-source">     Заметьте, как квалификатор NEW переименован в NEWEST с помощью опции REFERENCING, а затем использован в теле триггера. </p></div><span id="lnk869ecf19dc3848f1859d67964b65adbd"> </span><h2 align="left" class="paragraph-headline-source">     Условные предикаты </h2><span id="lnk727e4891841648aab04c14be7a36a721"> </span><div class="section"><p align="justify" class="paragraph-source">     Если триггер может быть возбужден более чем одним типом предложения DML (например, " INSERT OR DELETE OR UPDATE OF emp "), то в теле триггера можно использовать условные предикаты INSERTING, DELETING и UPDATING, для того чтобы выполнять различные участки кода в зависимости от типа предложения, возбудившего триггер. Предположим, что предложение триггера определено следующим образом: </p><p align="left" class="paragraph-source">INSERT OR UPDATE ON emp </p><p align="left" class="paragraph-source">     В коде внутри тела триггера вы можете использовать следующие условия: </p><p align="left" class="paragraph-source">IF INSERTING THEN <br />. . . <br />END IF; <br />IF UPDATING THEN <br />. . . <br />END IF ; </p><p align="justify" class="paragraph-source">     Первое условие будет вычисляться как TRUE лишь в тех случаях, когда триггер был возбужден предложением INSERT; второе условие будет вычисляться как TRUE лишь в тех случаях, когда триггер был возбужден предложением UPDATE. </p><p align="justify" class="paragraph-source">     Кроме того, в триггере UPDATE условный предикат UPDATING можно специфицировать перед именем столбца, чтобы определять, обновляется ли этот столбец текущим предложением, возбудившим триггер. </p><p align="left" class="paragraph-source">     Например, предположим, что триггер определен следующим образом: </p><p align="left" class="paragraph-source">CREATE TRIGGER . . . <br />. . . UPDATE OF quantity, ware_id ON storages . . . <br />BEGIN <br />. . . <br />IF UPDATING ('quantity') THEN <br />. . . <br />END IF; <br />END; </p><p align="justify" class="paragraph-source">     Код в фразе THEN выполняется лишь в том случае, если предложение UPDATE, возбудившее триггер, обновляет столбец Quantity . </p><p align="justify" class="paragraph-source">     Например, следующее предложение возбудит показанный выше триггер и заставит условный предикат вычислиться как TRUE: </p><p align="left" class="paragraph-source">UPDATE storages SET quantity = quantiti -20; </p></div><span id="lnk3c006f0189244015b693b84fab9e5b83"> </span><h2 align="left" class="paragraph-headline-source">     Дополнительные аспекты работы с триггерами</h2><span id="lnk1490c8619a03479b9a7af5ae2f347a39"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Доступ к данным для триггеров </b></p></div><span id="lnk0b73a1e009a148c99965d2db08a93e02"> </span><div id="see-more0b73a1e009a148c99965d2db08a93e02" class="additional"><table border="0"><tr><td><img src="../../00/styles/files/seecollapsed.gif" alt="Смотрите также:" title="Смотрите также:" class="collapse-img" style="width:16px; height:16px;" /></td><td><a href="javascript:seeMore('0b73a1e009a148c99965d2db08a93e02');" class="paragraph-source">Смотрите также:</a></td></tr></table><div style="display:none;"><p align="justify" class="note-source">     Когда триггер возбуждается, таблицы, к которым обращается его действие, могут в данный момент подвергаться изменениям со стороны предложений SQL в транзакциях других пользователей. Во всех случаях, предложения SQL, выполняемые внутри триггеров, следуют общим правилам, используемым для независимых предложений SQL. В частности, если неподтвержденная транзакция модифицировала те значения, которые необходимы возбужденному триггеру либо для чтения (запрос), либо для записи (обновление), то для предложений SQL в теле возбуждаемого триггера используются следующие правила: </p><p align="justify" class="note-source">     -  запросы видят текущий согласованный по чтению снимок всех необходимых данных с учетом изменений, осуществленных текущей транзакцией; </p><p align="justify" class="note-source">     -  обновления ожидают освобождения существующих блокировок данных, прежде чем могут продолжить выполнение. </p></div></div><span id="lnk856de814a9a244348b8120f5b90f5048"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Условия ошибок и исключения в теле триггера</b></p></div><span id="lnke23a16bb1f6f4d0f9a6cea0cfca4180b"> </span><div id="see-moree23a16bb1f6f4d0f9a6cea0cfca4180b" class="additional"><table border="0"><tr><td><img src="../../00/styles/files/seecollapsed.gif" alt="Смотрите также:" title="Смотрите также:" class="collapse-img" style="width:16px; height:16px;" /></td><td><a href="javascript:seeMore('e23a16bb1f6f4d0f9a6cea0cfca4180b');" class="paragraph-source">Смотрите также:</a></td></tr></table><div style="display:none;"><p align="justify" class="note-source">      Если во время исполнения тела триггера возникает условие предопределенной или определенной пользователем ошибки (исключение), то все действия как тела триггера, так и предложения, возбудившего триггер, откатываются (если это исключение не обрабатывается специально). Поэтому тело триггера может сознательно воспрепятствовать исполнению предложения триггера путем возбуждения исключения. Обычно в триггерах используются определяемые пользователем исключения, которые реализуют комплексные проверки полномочий или ограничения целостности. </p></div></div><span id="lnk37a21c6d7bd84f8c8c7abdfe3cd50d51"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Проектирование триггеров </b></p></div><span id="lnk2213a5d950ff495bab5c8d0016b864c9"> </span><div id="see-more2213a5d950ff495bab5c8d0016b864c9" class="additional"><table border="0"><tr><td><img src="../../00/styles/files/seecollapsed.gif" alt="Смотрите также:" title="Смотрите также:" class="collapse-img" style="width:16px; height:16px;" /></td><td><a href="javascript:seeMore('2213a5d950ff495bab5c8d0016b864c9');" class="paragraph-source">Смотрите также:</a></td></tr></table><div style="display:none;"><p align="justify" class="note-source">     Используйте следующие рекомендации при проектировании триггеров: </p><p align="justify" class="note-source">     - Используйте триггеры для того, чтобы гарантировать, что при выполнении определенной операции будут выполнены связанные с ней действия. </p><p align="justify" class="note-source">     - Используйте триггеры базы данных только для глобальных, централизованных операций, которые должны быть выполнены для соответствующего предложения (предложения триггера), независимо от того, какой пользователь или приложение базы данных выдает это предложение. </p><p align="justify" class="note-source">     - Не определяйте триггеров, дублирующих возможности, уже встроенные в ORACLE. Например, не определяйте триггеров для ввода в действие правил целостности данных, которые могут быть легко реализованы посредством декларативных ограничений целостности. </p></div></div><span id="lnk4eade8e01e9f4c16ac5d97ee22c8d528"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Каскады триггеров</b></p></div><span id="lnkbe4d70b9da3442c8a93f3c95888239f1"> </span><div id="see-morebe4d70b9da3442c8a93f3c95888239f1" class="additional"><table border="0"><tr><td><img src="../../00/styles/files/seecollapsed.gif" alt="Смотрите также:" title="Смотрите также:" class="collapse-img" style="width:16px; height:16px;" /></td><td><a href="javascript:seeMore('be4d70b9da3442c8a93f3c95888239f1');" class="paragraph-source">Смотрите также:</a></td></tr></table><div style="display:none;"><p align="justify" class="note-source">     Когда триггер возбуждается, предложение SQL внутри его действия потенциально может возбуждать другие триггеры, как показано на рисунке 12. Когда предложение в теле триггера возбуждает другой триггер, это называется каскадом. </p><p align="center" class="note-source"><img src="../res/files/jpg10b_0__0_.jpeg" height="368px" width="571px" alt="" /> </p><p align="center" class="note-source">Рисунок 12 - Каскад триггеров </p></div></div><span id="lnkcf19f0bb9a354a6b81d161b7c0541141"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Выполнение триггера </b></p></div><span id="lnk969ed9e68aa64f2fb59bd9880ffcef70"> </span><div id="see-more969ed9e68aa64f2fb59bd9880ffcef70" class="additional"><table border="0"><tr><td><img src="../../00/styles/files/seecollapsed.gif" alt="Смотрите также:" title="Смотрите также:" class="collapse-img" style="width:16px; height:16px;" /></td><td><a href="javascript:seeMore('969ed9e68aa64f2fb59bd9880ffcef70');" class="paragraph-source">Смотрите также:</a></td></tr></table><div style="display:none;"><p align="justify" class="note-source">     Триггер может находиться в одном из двух различных состояний (режимов): </p><p align="justify" class="note-source">     - включен. ВКЛЮЧЕННЫЙ триггер выполняет свое действие, если выдано предложение триггера, а ограничение триггера (если есть) вычисляется как TRUE; </p><p align="justify" class="note-source">     - выключен. ВЫКЛЮЧЕННЫЙ триггер не выполняет свое действие, даже если выдано предложение триггера, а ограничение триггера (если есть) вычисляется как TRUE. </p><p align="justify" class="note-source">     Для включенных триггеров ORACLE автоматически выполняет следующие действия: </p><p align="justify" class="note-source">     - выполняет триггеры в спланированной последовательности, если одно предложение SQL возбуждает более одного триггера; </p><p align="justify" class="note-source">     - выполняет проверку ограничений целостности в момент времени, предписанный для каждого типа триггера, и обеспечивает, чтобы триггеры не нарушали ограничений целостности;</p><p align="justify" class="note-source">     - предоставляет согласованные по чтению представления данных для запросов и ограничений; </p><p align="justify" class="note-source">     - управляет зависимостями между триггерами и объектами, к которым есть обращения в действии триггера; </p><p align="justify" class="note-source">     - использует двухфазное подтверждение, если триггер обновляет удаленные таблицы. </p></div></div><span id="lnkfdb4d80e93f347a883a60c858bab737d"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Модель исполнения для триггеров и проверок ограничений целостности </b></p></div><span id="lnk651f3a84257a444abe0a10872eccb6d6"> </span><div id="see-more651f3a84257a444abe0a10872eccb6d6" class="additional"><table border="0"><tr><td><img src="../../00/styles/files/seecollapsed.gif" alt="Смотрите также:" title="Смотрите также:" class="collapse-img" style="width:16px; height:16px;" /></td><td><a href="javascript:seeMore('651f3a84257a444abe0a10872eccb6d6');" class="paragraph-source">Смотрите также:</a></td></tr></table><div style="display:none;"><p align="justify" class="note-source">     Одно предложение SQL может потенциально возбудить до четырех триггеров: триггер строки BEFORE, триггер предложения BEFORE, триггер строки AFTER и триггер предложения AFTER. Как предложение триггера, так и любое предложение внутри действия триггера может вызвать проверку одного или нескольких ограничений целостности. Кроме того, триггеры могут содержать предложения, возбуждающие другие триггеры (каскад триггеров). ORACLE использует следующую модель, чтобы поддерживать должный порядок возбуждения множественных триггеров и проверки ограничений. </p><p align="justify" class="note-source">     а) выполнить триггер предложения BEFORE; </p><p align="justify" class="note-source">     б) цикл для каждой строки, на которую действует предложение SQL; </p><p align="justify" class="note-source">          1) выполнить триггер строки BEFORE; </p><p align="justify" class="note-source">          2) заблокировать и изменить строку, выполнить проверку ограничений целостности. (Эта блокировка не будет освобождена до конца транзакции); </p><p align="justify" class="note-source">          3) Выполнить триггер строки AFTER; </p><p align="justify" class="note-source">     в) выполнить проверку отложенных ограничений целостности; </p><p align="justify" class="note-source">     г) выполнить триггер предложения AFTER.</p><p align="justify" class="note-source">     Определение этой модели рекурсивно. Например, некоторое предложение SQL может возбудить триггер строки BEFORE и проверку ограничения целостности. Этот триггер строки BEFORE, в свою очередь, может выполнять обновление, которое вынудит проверку ограничения целостности и возбудит триггер предложения AFTER. Этот триггер предложения AFTER вызовет проверку ограничения целостности. В этом случае показанная модель будет выполнять шаги рекурсивно: </p><p align="justify" class="note-source">     а) Выдается первоначальное предложение SQL; </p><p align="justify" class="note-source">     б) Возбуждается триггер строки BEFORE; </p><p align="justify" class="note-source">          1) предложение UPDATE в триггере строки BEFORE возбуждает триггер предложения AFTER; </p><p align="justify" class="note-source">          2) выполняются предложения в действии триггера предложения AFTER; </p><p align="justify" class="note-source">          3) проверяются ограничения целостности по тем таблицам, которые изменены триггером предложения AFTER; </p><p align="justify" class="note-source">     в) Выполняются предложения в триггере строки BEFORE; </p><p align="justify" class="note-source">     г) Проверяются ограничения целостности по тем таблицам, которые изменены триггером строки BEFORE; </p><p align="justify" class="note-source">     д) Выполняется первоначальное предложение SQL; </p><p align="justify" class="note-source">     е) Проверяется ограничение целостности для предложения SQL.</p><p align="justify" class="note-source">     Важным свойством описанной модели исполнения является то, что все действия и проверки, осуществляемые как результат предложения SQL, должны быть выполнены успешно. Если внутри триггера возбуждается исключение, и это исключение явно не перехватывается, то все действия, выполненные как результат первоначального предложения SQL, включая те действия, которые были выполнены возбужденными триггерами, подвергаются откату. Поэтому ограничения целостности не могут быть нарушены триггерами. Модель исполнения принимает во внимание ограничения целостности и не позволяет выполняться триггерам, которые нарушили бы декларативные ограничения целостности.      Например, в описанном выше сценарии, предположим, что шаги с первого по восьмой выполнились успешно; однако в шаге (е) обнаружилось нарушение ограничения целостности. Как следствие этого нарушения, все изменения, которые были сделаны предложением SQL (шаг д), триггером строки BEFORE (шаг в) и триггером предложения AFTER (шаг 2), подвергаются откату. </p></div></div><span id="lnka98404d6cc8747ca95a5edfb93e2098a"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Ограничения целостности и триггеры </b></p></div><span id="lnk2a90896ecdf2469dbc0709e3fe6f20d8"> </span><div id="see-more2a90896ecdf2469dbc0709e3fe6f20d8" class="additional"><table border="0"><tr><td><img src="../../00/styles/files/seecollapsed.gif" alt="Смотрите также:" title="Смотрите также:" class="collapse-img" style="width:16px; height:16px;" /></td><td><a href="javascript:seeMore('2a90896ecdf2469dbc0709e3fe6f20d8');" class="paragraph-source">Смотрите также:</a></td></tr></table><div style="display:none;"><p align="justify" class="note-source">     Несмотря на то, что большинство аспектов целостности данных могут быть определены и задействованы через декларативные ограничения целостности, некоторые сложные организационные правила, не определяемые через декларативные ограничения целостности, могут быть реализованы посредством триггеров. Например, триггеры могут применяться в следующих случаях: </p><p align="justify" class="note-source">     - чтобы задействовать ссылочную целостность, когда нужное правило ссылочной целостности не может быть введено в действие через ограничения целостности: обновление CASCADE, обновление и удаление SET NULL, обновление и удаление SET DEFAULT 4</p><p align="justify" class="note-source">     - чтобы задействовать ссылочную целостность, когда зависимая и родительская таблицы находятся на разных узлах распределенной базы данных ;</p><p align="justify" class="note-source">     - чтобы задействовать комплексные организационные правила, которые не могут быть определены через выражения, допустимые в ограничениях CHECK .</p></div></div><span id="lnk5266901531e44845bfb4c6d7c07165ce"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Привилегии, требуемые для создания триггеров </b></p></div><span id="lnk84da54433cbc4b919595b79d0eff1962"> </span><div id="see-more84da54433cbc4b919595b79d0eff1962" class="additional"><table border="0"><tr><td><img src="../../00/styles/files/seecollapsed.gif" alt="Смотрите также:" title="Смотрите также:" class="collapse-img" style="width:16px; height:16px;" /></td><td><a href="javascript:seeMore('84da54433cbc4b919595b79d0eff1962');" class="paragraph-source">Смотрите также:</a></td></tr></table><div style="display:none;"><p align="justify" class="note-source">     Чтобы создать триггер в своей схеме, вы должны иметь системную привилегию CREATE TRIGGER, а также одно из: </p><p align="justify" class="note-source">     - владеть таблицей, специфицированной в предложении триггера, или </p><p align="justify" class="note-source">     - иметь привилегию ALTER для таблицы, специфицированной в предложении триггера, или </p><p align="justify" class="note-source">     - иметь системную привилегию ALTER ANY TABLE .</p><p align="justify" class="note-source">     Чтобы создать триггер в схеме другого пользователя, вы должны иметь системную привилегию CREATE ANY TRIGGER. Эта привилегия позволять создать триггер в любой схеме и ассоциировать его с таблицей любого пользователя. </p><p align="justify" class="note-source">     <b>Привилегии для объектов схем, адресуемых в теле триггера </b></p><p align="justify" class="note-source">     Как и для хранимых процедур, владелец триггера должен иметь объектные привилегии для объектов, адресуемых в теде триггера, причем эти привилегии должны быть получены им явно (не через роли). Предложения в теле триггера оперируют под доменом защиты владельца триггера, а не того пользователя, который выдает предложение, возбуждающее триггер. </p></div></div><span id="lnka73bc33271ac41398e3001094981e55a"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Изменение триггеров </b></p></div><span id="lnk5f248a0524ea452dbcde00cc1c9b65dc"> </span><div id="see-more5f248a0524ea452dbcde00cc1c9b65dc" class="additional"><table border="0"><tr><td><img src="../../00/styles/files/seecollapsed.gif" alt="Смотрите также:" title="Смотрите также:" class="collapse-img" style="width:16px; height:16px;" /></td><td><a href="javascript:seeMore('5f248a0524ea452dbcde00cc1c9b65dc');" class="paragraph-source">Смотрите также:</a></td></tr></table><div style="display:none;"><p align="justify" class="note-source">     Нельзя явно изменить триггер; его необходимо заменить новым определением триггера. Если вы используете текстовый редактор для создания ваших триггеров, вы можете просто отредактировать соответствующий текстовый файл и выполнить предложение CREATE TRIGGER, чтобы определить новую версию кода. </p><p align="justify" class="note-source">     Заменяя триггер, вы должны включить в предложение CREATE TRIGGER опцию OR REPLACE. Опция OR REPLACE позволяет заменить существующий триггер новой версией, не затрагивая никаких грантов, которые были выданы для первоначальной версии этого триггера. </p><p align="justify" class="note-source">     Альтернативно, триггер можно удалить и создать заново. Однако все гранты, которые были выданы для удаляемого триггера, также удаляются, и должны быть выданы заново после создания новой версии триггера. </p></div></div><span id="lnkef4ab224a34247da93aa7838f6c300b2"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Включение и выключение триггеров </b></p></div><span id="lnk8ad76201a0bd48968f5d47de8214a7b1"> </span><div id="see-more8ad76201a0bd48968f5d47de8214a7b1" class="additional"><table border="0"><tr><td><img src="../../00/styles/files/seecollapsed.gif" alt="Смотрите также:" title="Смотрите также:" class="collapse-img" style="width:16px; height:16px;" /></td><td><a href="javascript:seeMore('8ad76201a0bd48968f5d47de8214a7b1');" class="paragraph-source">Смотрите также:</a></td></tr></table><div style="display:none;"><p align="left" class="note-source">     Триггер может находиться в одном из двух различных режимов: </p><p align="justify" class="note-source">     - включен: Включенный триггер выполняет свое тело, если выдано предложение триггера, и ограничение триггера (если есть) вычисляется как TRUE. </p><p align="justify" class="note-source">     - выключен: Выключенный триггер не выполняет свое тело, даже если выдано предложение триггера, и ограничение триггера (если есть) вычисляется как TRUE. </p><p align="justify" class="note-source">     Вы можете временно выключить триггер, если имеет место одно из следующих условий: </p><p align="justify" class="note-source">     - Объект, к которому обращается триггер, недоступен. </p><p align="justify" class="note-source">     - Вы должны выполнить массовую загрузку данных, и хотите осуществить ее быстро, не возбуждая триггеров. </p><p align="justify" class="note-source">     - Вы загружаете данные в таблицу, к которой применяется триггер. </p><p align="justify" class="note-source">     По умолчанию, триггер включается в момент его создания. Чтобы отключить триггер, используйте команду ALTER TRIGGER с опцией DISABLE. Например, следующее предложение отключает триггер REORDER по таблице INVENTORY: </p><p align="justify" class="note-source">ALTER TRIGGER reorder DISABLE; </p><p align="justify" class="note-source">     Вы можете одновременно отключить все триггеры, ассоциированные с таблицей, с помощью команды ALTER TABLE с опциями DISABLE и ALL TRIGGERS. Например, следующее предложение отключает все триггеры, определенные для таблицы INVENTORY: </p><p align="justify" class="note-source">ALTER TABLE inventory DISABLE ALL TRIGGERS; </p><p align="justify" class="note-source">     По умолчанию, триггер автоматически включается в момент его создания; однако позже он может быть выключен. Закончив задачу, для которой потребовалось выключать триггер, вы можете снова включить его. </p><p align="justify" class="note-source">     Чтобы включить триггер, используйте команду ALTER TRIGGER с опцией ENABLE. Например, следующее предложение включает триггер REORDER по таблице INVENTORY : </p><p align="justify" class="note-source">ALTER TRIGGER reorder ENABLE;</p><p align="justify" class="note-source">     Вы можете одновременно включить все триггеры, ассоциированные с таблицей, с помощью команды ALTER TABLE с опциями ENABLE и ALL TRIGGERS. Например, следующее предложение включает все триггеры, определенные для таблицы INVENTORY: </p><p align="justify" class="note-source">ALTER TABLE inventory ENABLE ALL TRIGGERS;</p><p align="justify" class="note-source">     <b>Привилегии, требуемые для включения и выключения триггеров </b></p><p align="justify" class="note-source">     Для включения и выключения триггеров с помощью команды ALTER TABLE, вы должны либо владеть таблицей, либо иметь объектную привилегию ALTER TABLE для таблицы или системную привилегию ALTER ANY TABLE. Для включения или выключения индивидуального триггера с помощью команды ALTER TRIGGER, вы должны либо владеть триггером, либо иметь системную привилегию ALTER ANY TRIGGER. </p></div></div><span id="lnk353ddd8e48204d44b4ac72e14b91523c"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Вывод информации о триггерах </b></p></div><span id="lnkd33a1db317604c1da7f0a359250a4f32"> </span><div id="see-mored33a1db317604c1da7f0a359250a4f32" class="additional"><table border="0"><tr><td><img src="../../00/styles/files/seecollapsed.gif" alt="Смотрите также:" title="Смотрите также:" class="collapse-img" style="width:16px; height:16px;" /></td><td><a href="javascript:seeMore('d33a1db317604c1da7f0a359250a4f32');" class="paragraph-source">Смотрите также:</a></td></tr></table><div style="display:none;"><p align="justify" class="note-source">     Следующие обзоры словаря данных раскрывают информацию о триггерах: </p><p align="justify" class="note-source">     - USER_TRIGGERS ;</p><p align="justify" class="note-source">     - ALL_TRIGGERS ;</p><p align="justify" class="note-source">     - DBA_TRIGGERS .</p><p align="justify" class="note-source">     Например, следующие два запроса возвращают информацию о триггере REORDER: </p><p align="left" class="note-source">SELECT type, triggering_statement, table_name FROM user_triggers WHERE name = 'REORDER'; </p><p align="left" class="note-source">SELECT trigger_body FROM user_triggers WHERE name = 'REORDER'; </p></div></div><span id="lnke453efd3a130488b93c7690d3715ebc2"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Удаление триггеров </b></p></div><span id="lnk6519516ae8574912af261f5ea6b6f952"> </span><div id="see-more6519516ae8574912af261f5ea6b6f952" class="additional"><table border="0"><tr><td><img src="../../00/styles/files/seecollapsed.gif" alt="Смотрите также:" title="Смотрите также:" class="collapse-img" style="width:16px; height:16px;" /></td><td><a href="javascript:seeMore('6519516ae8574912af261f5ea6b6f952');" class="paragraph-source">Смотрите также:</a></td></tr></table><div style="display:none;"><p align="justify" class="note-source">     Для удаления триггера из базы данных используется команда DROP TRIGGER. </p><p align="justify" class="note-source">     Например, чтобы удалить триггер с именем REORDER, требуется ввести следующее предложение: </p><p align="left" class="note-source">DROP TRIGGER Trigger _ name ; </p><p align="justify" class="note-source">     Чтобы удалить триггер, пользователь должен иметь его в своей схеме, либо иметь системную привилегию DROP ANY TRIGGER. </p></div></div><span id="lnkcfabea49b81a4ab999aab4a4ad747fc1"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Сравнение триггеров и декларативных ограничений целостности </b></p></div><span id="lnk88b317de647f4e7183f5faa718108fa1"> </span><div id="see-more88b317de647f4e7183f5faa718108fa1" class="additional"><table border="0"><tr><td><img src="../../00/styles/files/seecollapsed.gif" alt="Смотрите также:" title="Смотрите также:" class="collapse-img" style="width:16px; height:16px;" /></td><td><a href="javascript:seeMore('88b317de647f4e7183f5faa718108fa1');" class="paragraph-source">Смотрите также:</a></td></tr></table><div style="display:none;"><p align="justify" class="note-source">     Как триггеры, так и декларативные ограничения целостности можно использовать для ограничений на входные данные. Однако триггеры и декларативные ограничения целостности имеют существенные различия. </p><p align="justify" class="note-source">     Декларативное ограничение целостности - это утверждение о базе данных, которое всегда истинно. Ограничение применяется к существующим данным в таблице и к любому предложению, которое манипулирует этой таблицей. </p><p align="justify" class="note-source">     Триггеры налагают ограничения на то, что могут делать транзакции. Триггер не применяется к данным, которые были загружены до того, как триггер был определен; поэтому триггер не гарантирует, что все данные в таблице удовлетворяют правилам, установленным ассоциированным триггером. </p><p align="justify" class="note-source">     Триггер вводит в действие переходные ограничения; иными словами, триггер вводит в действие ограничение, действующее на момент изменения данных. Поэтому такое ограничение, как "гарантировать, что дата доставки отстоит по меньшей мере на семь дней от сегодняшней даты", должно реализовываться через триггер, а не через декларативное ограничение целостности. </p><p align="justify" class="note-source">     При вычислении триггеров, которые содержат функции SQL, имеющие в качестве аргументов параметры средства поддержки национальных языков NLS (например, TO_CHAR, TO_DATE, TO_NUMBER), умалчиваемые значения таких параметров берутся из параметров NLS, действующих для сессии в текущий момент. Вы можете перекрывать умалчиваемые значения для параметров NLS, явно специфицируя параметры NLS в таких функциях при написании триггера. </p><p align="justify" class="note-source">     С помощью триггеров могут быть введены в действие многие варианты ссылочной целостности. Однако применяйте триггеры лишь тогда, когда вы хотите реализовать ссылочные действия UPDATE и DELETE SET NULL, UPDATE и DELETE SET DEFAULT, или если вы хотите задействовать ссылочную целостность, когда зависимая и родительская таблицы находятся на разных узлах распределенной базы данных. </p><p align="justify" class="note-source">     Применяя триггеры для поддержания ссылочной целостности, объявите ограничение PRIMARY KEY или UNIQUE по родительской таблице. Если ссылочная целостность должна поддерживаться между родительской и порожденной таблицами в одной и той же базе данных, то вы можете также объявить внешний ключ в порожденной таблице, но отключить его; это предотвратит возможность удаления соответствующего ограничения PRIMARY KEY (если только ограничение PRIMARY KEY не удаляется явно опцией CASCADE). </p><p align="justify" class="note-source">     <b>Чтобы поддерживать ссылочное ограничение с помощью триггеров: </b></p><p align="justify" class="note-source">     Для порожденной таблицы должен быть определен триггер, гарантирующий, что значения, вставляемые или обновляемые во внешнем ключе, соответствуют значениям родительского ключа. Один или несколько триггеров должны быть определены для родительской таблицы. Эти триггеры гарантируют выполнение нужного ссылочного действия (RESTRICT, CASCADE или SET NULL) при обновлении или удалении значения родительского ключа. При вставках в родительскую таблицу не требуется никаких ссылочных действий, ибо еще не существует зависимых внешних ключей. </p></div></div><span id="lnk9057f4c336d24a68bd0da171109f1614"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Мутирующие и ограничивающие таблицы </b></p></div><span id="lnk32ab47ef16034a0da1933ec2af023f98"> </span><div id="see-more32ab47ef16034a0da1933ec2af023f98" class="additional"><table border="0"><tr><td><img src="../../00/styles/files/seecollapsed.gif" alt="Смотрите также:" title="Смотрите также:" class="collapse-img" style="width:16px; height:16px;" /></td><td><a href="javascript:seeMore('32ab47ef16034a0da1933ec2af023f98');" class="paragraph-source">Смотрите также:</a></td></tr></table><div style="display:none;"><p align="justify" class="note-source">     Мутирующая таблица - это таблица, модифицируемая в данный момент предложением UPDATE, DELETE или INSERT, или таблица, которая может потребовать обновления в результате действия декларативного ссылочного ограничения целостности DELETE CASCADE. </p><p align="justify" class="note-source">     Ограничивающая таблица - это таблица, которую предложение, возбуждающее триггер или ограничение, должно читать, - либо явно (для предложения SQL), либо неявно (для декларативного ограничения ссылочной целостности). </p><p align="justify" class="note-source">     Мутирующая или ограничивающая таблица является таковой лишь для той сессии, которая выдает предложение, возбуждающее триггер или ограничение. </p><p align="justify" class="note-source">     Для триггеров предложений таблица не рассматривается как мутирующая или как ограничивающая; однако для триггеров строк имеют место два важных ограничения, касающихся мутирующих и ограничивающих таблиц: </p><p align="justify" class="note-source">     - Предложения в триггере строк не могут читать или модифицировать мутирующую таблицу предложения триггера. Это ограничение не позволяет триггеру строк иметь дело с несогласованным множеством данных. </p><p align="justify" class="note-source">     - Предложения в триггере строк не могут изменять столбцов первичного, внешнего или уникального ключа ограничивающей таблицы предложения триггера. Это ограничение введено с тем, чтобы успех предложения внутри триггера не зависел от порядка обработки строк или от индекса. </p><p align="justify" class="note-source">     Для этого правила существует одно исключение: триггер BEFORE ROW, возбужденный предложением INSERT, вставляющим одиночную строку в таблицу с внешним ключом, может модифицировать любые столбцы первичной таблицы, пока эта модификация не нарушает никаких ограничений целостности. </p><p align="justify" class="note-source">     Если вам необходимо обновить мутирующую или ограничивающую таблицу, вам следует использовать временную таблицу, таблицу PL/SQL или пакетированную переменную, чтобы обойти эти ограничения. </p></div></div><span id="lnk0a307fdd9cb2493d96b56e650a5175a1"> </span><div class="section"><p align="left" class="paragraph-source"><b> </b>     <b>Аудитинг с помощью триггеров </b></p></div><span id="lnk5d1557775dcd444c83102054a95ce1ef"> </span><div id="see-more5d1557775dcd444c83102054a95ce1ef" class="additional"><table border="0"><tr><td><img src="../../00/styles/files/seecollapsed.gif" alt="Смотрите также:" title="Смотрите также:" class="collapse-img" style="width:16px; height:16px;" /></td><td><a href="javascript:seeMore('5d1557775dcd444c83102054a95ce1ef');" class="paragraph-source">Смотрите также:</a></td></tr></table><div style="display:none;"><p align="justify" class="note-source">     Типичное применение триггеров - дополнять встроеннные средства аудитинга ORACLE. Хотя можно писать триггеры, которые будут записывать информацию, аналогичную той, что регистрируется командой AUDIT, триггеры следует применять лишь в том случае, если вам требуется более детальная аудиторская информация. Например с помощью триггеров можно реализовать отслеживание на уровне значений столбцов в строках таблиц. </p><p align="justify" class="note-source">     Иногда команда ORACLE AUDIT рассматривается как средство аудита ЗАЩИТЫ, тогда как триггеры могут обеспечить средства ФИНАНСОВОГО аудита. </p><p align="justify" class="note-source">     Принимая решение о создании триггера для отслеживания операций в базе данных, рассматривайте те возможности, которые могут предоставить средства аутитинга ORACLE, и сравнивайте их с аудитингом, который может быть реализован триггерами. </p><p align="justify" class="note-source">     Применяя триггеры для изощренного аудитинга, обычно используют триггеры AFTER. За счет использования триггеров AFTER, вы регистрируете аудиторскую информацию после того, как предложение триггера подверглось воздействию всех возможных ограничений целостности, и избегаете выполнения излишней аудиторской работы в тех случаях, когда предложения подвергаются откату из-за нарушения ограничений целостности. </p><p align="justify" class="note-source">     Использовать ли триггеры строк или триггеры предложений, зависит от того, какую информацию вы отслеживаете. Например, триггеры строк обеспечивают отслеживание значений по строкам таблицы. Триггеры могут также позволить пользователю предоставлять "код причины", по которой выдается отслеживаемое предложение, что может быть полезным при аудитинге как на уровне строк, так и на уровне предложений. </p></div></div><span id="lnk7008f58898634c4a993030d1188e0b43"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Триггеры и вычисляемые значения столбцов </b></p></div><span id="lnk1c3e2de6eb194d69a4084d06eef0fcf6"> </span><div id="see-more1c3e2de6eb194d69a4084d06eef0fcf6" class="additional"><table border="0"><tr><td><img src="../../00/styles/files/seecollapsed.gif" alt="Смотрите также:" title="Смотрите также:" class="collapse-img" style="width:16px; height:16px;" /></td><td><a href="javascript:seeMore('1c3e2de6eb194d69a4084d06eef0fcf6');" class="paragraph-source">Смотрите также:</a></td></tr></table><div style="display:none;"><p align="justify" class="note-source">     Триггеры могут автоматически вычислять значения столбцов, базируясь на значениях, которые поставляются предложением INSERT или UPDATE. Такой тип триггера полезен для принудительной установки значений определенных столбцов, зависящих от значений других столбцов в той же самой строке. Для такого типа операций необходимы триггеры строк BEFORE, ибо: </p><p align="justify" class="note-source">     - Зависимые значения должны быть вычислены перед тем, как произойдет вставка или обновление, так, чтобы предложение триггера могло использовать вычисленные значения. </p><p align="justify" class="note-source">     - Триггер должен возбуждаться для каждой строки, которую затрагивает возбуждающее триггер предложение INSERT или UPDATE. </p></div></div><span id="lnkba57bb8ee9844d4bb6137b611f05772a"> </span><div class="section"><p align="justify" class="paragraph-source">     Для закрепления на практике изученного теоретического материала рекомендуется выполнить <a title="" target="_self" href="../../03/content/example3.html#lnk146a1dd9470a44139e7f4cd1e544a433">практическое занятие</a>  3  и <a title="" target="_self" href="../../03/content/example4.html#lnk37b7250842564923933a2016ba5c0640">лабораторную работу 3</a>. </p></div></div></td></tr></table></td></tr><tr><td id="bottomOuter"><table id="bottomInner"><tr><td class="cell1"><div> </div></td><td class="cell2"><div>© 2012 ХНУРЭ, ПИ, Широкопетлева М.С., <a href="mailto:mshirokopetleva@gmail.com">mshirokopetleva@gmail.com</a>;   ХНУРЭ, ПИ, Черепанова Ю.Ю.;   ХНУРЭ, ПИ, Мазурова О.А.<br /><a href="http://lersus.de/" title="Данный курс создан с помощью авторской системы LERSUS" target="_blank">Разработано с помощью LERSUS</a></div></td></tr></table></td></tr></table></body></html>