<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="LERSUS 3.3.0.0" /><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Корпоративные информационные системы — Теория — Создание хранимых процедур и функций </title><script language="javascript" type="text/javascript" src="../../00/styles/files/apiwrapper.js"> </script><script language="javascript" type="text/javascript" src="../../00/styles/files/sco.js"> </script><link href="../../00/styles/files/style.css" rel="stylesheet" type="text/css" /></head><body><table id="mainOuter"><tr><td id="topOuter"><table id="topInner"><tr class="row1"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4" id="shortcuts"><div><ul class="level0"><li><a href="../../00/content/authors1.html">Авторы</a></li><li>|</li><li><a href="../../00/content/contacts1.html">Контакты</a></li><li>|</li><li><a href="../../00/content/instructions1.html">Методические указания</a></li><li>|</li><li><a href="../../00/content/annotation1.html">Аннотация</a></li><li>|</li><li><a href="#" onclick="history.back(); return false;">Назад</a></li></ul></div></td></tr><tr class="row2"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4"><div id="courseTitle">Корпоративные информационные системы</div><div id="courseSubTitle">Языки запросов к базам данных : Создание хранимых процедур и функций </div></td></tr></table></td></tr><tr><td id="contentOuter"><table id="contentInner"><tr><td class="menuOuter"><table class="menuInner"><tr><td><ul class="level0"><li><a href="../../00/styles/courses.html">Содержание курса</a></li><li><span>Теория</span></li><ul class="level1"><li><a href="../../03/content/content1.html">Оптимизация запросов</a></li><li><a href="../../03/content/content2.html">Окружение 4-го поколения</a></li><li><a href="../../03/content/content3.html">Язык PL / SQL. Общие положения </a></li><li><a href="../../03/content/content4.html">Переменные и константы. Кодовое множество</a></li><li><a href="../../03/content/content5.html">Типы данных</a></li><li><a href="../../03/content/content6.html">Команды управления</a></li><li><a href="../../03/content/content7.html">Создание хранимых процедур и функций </a></li><li><a href="../../03/content/content8.html">Параметры подпрограмм</a></li><li><a href="../../03/content/content9.html">Встроенные функции PL / SQL</a></li><li><a href="../../03/content/content10.html">Курсоры</a></li><li><a href="../../03/content/content11.html">Исключительные ситуации</a></li><li><a href="../../03/content/content12.html">Обработчики исключений </a></li><li><a href="../../03/content/content13.html">Пакеты</a></li><li><a href="../../03/content/content14.html">Триггеры объектов </a></li></ul><li><span>Практика</span></li><ul class="level1"><li><a href="../../03/content/example1.html">Практика 2. Использование подпрограмм в языках  программирования 4-го поколения</a></li><li><a href="../../03/content/example2.html">Лабораторная работа 2 Подпрограммы как средство создания серверных частей информационных систем на примере СУБД Oracle </a></li><li><a href="../../03/content/example3.html">Практика 3. Создание  и работа с триггерами объектов и событий</a></li><li><a href="../../03/content/example4.html">Лабораторная работа 3. Триггеры объектов и событий базы данных </a></li></ul><li><span>Текущий контроль знаний</span></li><ul class="level1"><li><a href="../../03/content/multiply-choice-test25.html">Управляющие структуры</a></li><li><a href="../../03/content/multiply-answers-test7.html">Подпрограммы языка PL/SQL</a></li><li><a href="../../03/content/multiply-choice-test1.html">Курсоры</a></li><li><a href="../../03/content/multiply-answers-test12.html">Исключительные ситуации</a></li><li><a href="../../03/content/multiply-choice-test19.html">Пакеты</a></li><li><a href="../../03/content/multiply-answers-test3.html">Триггеры</a></li></ul><li><a href="../../03/styles/glossary.html">Словарь терминов</a></li><li><a href="../../03/03.pdf" target="_blank">Версия для печати</a></li></ul></td></tr></table></td><td class="content"><div id="content"><div id="topBlankStripe"> </div><span id="lnk394c0df77df14e74a55d6615754ccfe7"> </span><h1 align="left" class="headline-source">     Создание хранимых процедур и функций </h1><span id="lnkcf0d7bfb89ff4271b07b4f6b12a0d068"> </span><div class="section"><p align="justify" class="paragraph-source">     <i><b>Подпрограмма </b></i>- это именованный блок PL/SQL, который принимает параметры и может быть вызван. PL/SQL имеет два типа подпрограмм, называемых ПРОЦЕДУРАМИ и ФУНКЦИЯМИ. </p><p align="justify" class="paragraph-source">     Обычно процедуру вызывают для того, чтобы выполнить некоторое действие, а функцию - для того, чтобы вычислить некоторое значение. Как и неименованные (АНОНИМНЫЕ) блоки PL/SQL, подпрограммы имеют декларативную часть, исполняемую часть и необязательную часть обработки исключений. </p><p align="justify" class="paragraph-source">     Декларативная часть содержит объявления типов, курсоров, констант, переменных, исключений и вложенных подпрограмм. Все эти объекты локальны, и перестают существовать после выхода из подпрограммы. </p><p align="justify" class="paragraph-source">     Исполняемая часть содержит предложения, которые присваивают значения, управляют выполнением и манипулируют данными ORACLE. </p><p align="justify" class="paragraph-source">     Часть обработки исключений содержит обработчики, которые имеют дело с исключениями, возбуждаемыми при исполнении. </p><p align="justify" class="paragraph-source">     Подпрограммы можно определять в любом инструменте ORACLE, который поддерживает PL/SQL. Их можно объявлять в блоках PL/SQL, процедурах, функциях и пакетах. Однако подпрограммы должны объявляться в конце декларативной секции, после всех других программных объектов. Например, следующее объявление процедуры не на месте: </p><p align="left" class="paragraph-source">DECLARE <br />PROCEDURE ysenka (...) IS -- не на месте <br />Goods_id1 NUMBER; <br />... <br />BEGIN <br />... <br />END; </p><p align="justify" class="paragraph-source">     Обычно инструменты ORACLE, такие как SQL* Plus , которые инкорпорируют в себя процессор PL/SQL, способны сохранять подпрограммы для последующего, строго локального, исполнения. Однако для того, чтобы быть общедоступными для всех инструментов ORACLE, такие подпрограммы должны быть сохранены в базе данных. </p></div><span id="lnk5cc1b4a8932d432caeb31f5200a59960"> </span><h2 align="left" class="paragraph-headline-source">     Преимущества подпрограмм </h2><span id="lnk05c3068c6a6a448c988289dec509017d"> </span><div class="section"><p align="justify" class="paragraph-source">     Хранимые подпрограммы предоставляют расширяемость, модульность, способствуют абстракции, предоставляют более высокую продуктивность разработки, лучшую производительность, экономию памяти, целостность приложений и более строгую защиту. </p></div><span id="lnkbcc695e08e1d4fb8aec7da3bc6ca0eb5"> </span><div class="section"><p align="justify" class="paragraph-source">     <b>Расширяемость</b>. Подпрограммы они позволяют вам приспосабливать средства PL/SQL для ваших потребностей. Например, если вам нужна процедура, которая добавляла бы новые склады, вы легко можете написать ее: </p><p align="left" class="paragraph-source">CREATE PROCEDURE insert_ware (new_address VARCHAR2, new_volume NUMBER, new_storage_have VARCHAR2) AS <br />BEGIN <br />INSERT INTO warehouses VALUES (ware_seq.NEXTVAL, new_address, new_volume, new_volume, new_storage_have); <br />END insert_ware; </p></div><span id="lnk2bbad3d9a2bb487c93017d9cc76439ee"> </span><div class="section"><p align="justify" class="paragraph-source">     <b>Модульность</b>. Подпрограммы позволяют вам разбивать ваши программы на управляемые, хорошо определенные логические модули. Это поддерживает методы проектирования сверху вниз и пошагового уточнения, характерные для структурного подхода к решению проблем, Помимо этого, подпрограммы способствуют используемости и сопровождаемости. Однажды проверенную подпрограмму можно с уверенностью использовать в любом количестве приложений. Более того, лишь одна подпрограмма затрагивается, если изменяется ее определение. Это упрощает сопровождение и развитие. </p></div><span id="lnkc3b31b66933544b9be4105e3108f9c20"> </span><div class="section"><p align="justify" class="paragraph-source">     <b>Абстракции</b>. Подпрограммы способствуют умственному отделению от частностей. Чтобы использовать подпрограммы, вам нужно знать, что они делают, а не как они это делают. Поэтому вы можете проектировать приложения сверху вниз, не заботясь о деталях реализации. С помощью фиктивных подпрограмм (затычек) вы можете отложить определение процедур и функций до тех пор, пока не протестируете и не отладите главную программу. </p></div><span id="lnk9ceaf18f919242a98ec467dbf87ae61d"> </span><div class="section"><p align="justify" class="paragraph-source">     <b>Повышение продуктивности</b>. Проектируя приложения вокруг библиотеки хранимых подпрограмм, вы можете избежать неоднократного кодирования повторяющихся операций, повышая продуктивность разработки. Предположим, например, что несколько различных приложений вызывают хранимую процедуру, которая управляет таблицей goods в базе данных. Если метод управления изменится, потребуется пересмотреть лишь одну процедуру, а не все приложения. </p></div><span id="lnk66c91a9d3a604c6581f9dcd5487bdb30"> </span><div class="section"><p align="justify" class="paragraph-source">     <b>Улучшение производительности. </b>Использование подпрограмм может сократить число обращений ваших приложений к ORACLE. Например, для исполнения десяти индивидуальных предложений SQL требуется десять обращений к ORACLE, но для исполнения подпрограммы, содержащей десять предложений SQL, необходим лишь один вызов. Уменьшение число обращений может резко увеличить производительность, особенно если ваше приложение взаимодействует с ORACLE через сеть. </p><p align="justify" class="paragraph-source">     Хранимые процедуры могут улучшить производительность базы данных. Использование процедур существенно сокращает объем информации, пересылаемой по сети, по сравнению с выдачей индивидуальных предложений SQL или пересылкой в ORACLE текста целого блока PL/SQL. Более того, так как откомпилированная форма процедуры хранится в базе данных готовой к выполнению, для исполнения ее кода не требуется шага компиляции. Кроме того, если процедура уже присутствует в разделяемом пуле в SGA, то не требуется ее извлечения с диска, и выполнение может начаться немедленно. </p></div><span id="lnk348d90819891448ab1f74ad389251482"> </span><div class="section"><p align="justify" class="paragraph-source">     <b>Экономия памяти.</b> Хранимые подпрограммы используют преимущества разделяемой памяти ORACLE. Так, лишь одна копия подпрограммы должна быть загружена в память, чтобы быть доступной всем пользователям. Использование одного и того же кода совместно многими пользователями приводит к существенной экономии памяти, требуемой приложениям. </p></div><span id="lnkba1a5dd90bc04f679d919afa66d73977"> </span><div class="section"><p align="justify" class="paragraph-source">     <b>Целостность приложений.</b> Хранимые подпрограммы улучшают целостность и согласованность ваших приложений. Создавая приложения вокруг библиотеки хранимых подпрограмм, вы снижаете вероятность ошибок кодирования. Например, процедуру или функцию требуется протестировать лишь однократно, чтобы гарантировать, что она возвращает точный результат. После проверки, процедура может использоваться в любом числе приложений, поставляя им гарантированно достоверные результаты. При любом изменении структур данных, к которым обращается процедура, перекомпилировать потребуется лишь эту процедуру; приложения, вызывающие эту процедуру, не потребуют никаких модификаций (даже перекомпиляции). </p></div><span id="lnk019b9088797d4c4c80f717d5cec7334e"> </span><div class="section"><p align="justify" class="paragraph-source">     <b>Повышенная безопасность. </b>Хранимые подпрограммы повышают безопасность данных. Ваш АБД может ограничить доступ пользователей к определенным операциям с базой данных, предоставляя доступ лишь через подпрограммы. Например, АБД может предоставить пользователям право выполнения хранимой процедуры, обновляющей таблицу goods , но не давать доступа к самой таблице goods . Когда пользователь вызывает процедуру, эта процедура выполняется с привилегиями владельца процедуры. Так как пользователи имеют лишь привилегию выполнять процедуру, но не имеют привилегий опрашивать, обновлять или удалять данные из соответствующих таблиц, возможности пользователей по манипулированию данными ограничиваются тем, что заложено в процедуру.</p></div><span id="lnkad7a969bae004051a5291b5f8e2f1bba"> </span><h2 align="left" class="paragraph-headline-source">     Процедуры </h2><span id="lnkb0e064cb716f4fcb9d872720dfa55207"> </span><div class="section"><p align="left" class="paragraph-source">     Процедура - это подпрограмма, которая выполняет специфическое действие. </p><p align="left" class="paragraph-source">     Вы пишете процедуры, используя синтаксис: </p><p align="left" class="paragraph-source">PROCEDURE имя [ (параметр [, параметр, ...]) ] IS <br />[локальные объявления] <br />BEGIN <br />исполняемые предложения <br />[EXCEPTION <br />обработчики исключений] <br />END [имя]; </p><p align="left" class="paragraph-source">где каждый "параметр" имеет следующий синтаксис: </p><p align="left" class="paragraph-source">имя_перем [IN | OUT | IN OUT] тип_данных [{:= | DEFAULT} знач] </p><p align="justify" class="paragraph-source">     Здесь моды IN | OUT | IN OUT, определяющие тип параметра, являются необязательными. Как необязательным является определение значений по умолчанию, которые могут быть заданы двумя способами: </p><p align="left" class="paragraph-source">:=значение либо DEFAULT значение. </p><p align="justify" class="paragraph-source">     В отличие от спецификатора типа данных в объявлении переменной, спецификатор типа данных для параметра не может иметь ограничений (см. тему 11). </p><p align="justify" class="paragraph-source">     Например, следующее объявление name1 незаконно (должно быть просто VARCHAR 2): </p><p align="left" class="paragraph-source">PROCEDURE ... (name1 VARCHAR2(20)) IS -- незаконно ; <br />BEGIN <br />... <br />END; </p></div><span id="lnk6988c13cbf2241bc9adad21e150eeae1"> </span><div class="section"><p align="justify" class="paragraph-source">     Процедура имеет две части: спецификацию и тело. Спецификация процедуры начинается с ключевого слова PROCEDURE и заканчивается именем процедуры или списком параметров. Объявления параметров необязательны. Если процедура не принимает параметров, скобки также не кодируются. </p><p align="justify" class="paragraph-source">     Тело процедуры начинается с ключевого слова IS и заканчивается ключевым словом END, за которым может следовать имя процедуры. Тело процедуры состоит из трех частей: декларативной части, исполняемой части и необязательной части обработки исключений. </p><p align="justify" class="paragraph-source">     Декларативная часть содержит локальные объявления, которые помещаются между ключевыми словами IS и BEGIN. Ключевое слово DECLARE, которое начинает декларативную часть в анонимном блоке PL/SQL, здесь не используется. </p><p align="justify" class="paragraph-source">     Исполняемая часть содержит предложения, которые помещаются между ключевыми словами BEGIN и EXCEPTION (или END). В исполняемой части процедуры должно быть хотя бы одно предложение. </p><p align="justify" class="paragraph-source">     Часть обработки исключений содержит обработчики исключений, которые помещаются между ключевыми словами EXCEPTION и END. </p></div><span id="lnk19230804a76242d7935a965e3e144341"> </span><div class="section"><p align="left" class="paragraph-source">     Рассмотрим процедуру buy _ goods , которая проводит в БД операцию покупки товара: </p><p align="left" class="paragraph-source">CREATE OR REPLACE PROCEDURE buy_goods (good_id1 NUMBER, quantity1 NUMBER) IS <br />Storage _ id 1 NUMBER (4); -- переменная для номера партии <br />ware _ id 1 NUMBER (4); -- переменная для номера склада <br />vol NUMBER (6,2); -- переменная для объема единицы товара <br />BEGIN <br />SELECT storage_id, ware_id INTO storage_id1, ware_id1 FROM storages WHERE <br />begin_time IN (SELECT MIN(begin_time) FROM storages <br />WHERE Goods_id=Good_id1 AND quantity&gt;quantity1); <br />-- определяем объем единицы покупаемого товара <br />SELECT volume INTO vol FROM goods WHERE goods_id=good_id1; <br />-- фиксируем покупку части партии товара <br />UPDATE storages SET quantity = quantity - quantity1 WHERE storage_id = storage_id1; <br />--фиксируем освобождение соответствующего объема на складе <br />UPDATE warehouses SET volume_rest = volume_rest + quantity1* vol WHERE ware_id=ware_id1; <br />EXCEPTION <br />WHEN NO_DATA_FOUND THEN <br />INSERT INTO opt_audit VALUES (OPT_CUR.NEXTVAL, good_id1, 'No such goods'); <br />END buy _ goods ; </p><p align="justify" class="paragraph-source">     При своем вызове эта процедура принимает номер товара и количество товара, которое хотят купить. Она использует номер, чтобы выбрать информацию о партии этого товара, завезенной раньше всего из таблицы базы данных storages . Если информации о партии искомого товара нет, возбуждается исключение. В противном случае количество товара на складе уменьшается. </p><p align="left" class="paragraph-source">     Процедура вызывается как предложение PL/SQL. Например, процедура buy _ goods может быть вызвана так: </p><p align="left" class="paragraph-source">buy_goods (goods_need, count_goods); </p></div><span id="lnk8909453ac48f4c4087f5fdfd692a893b"> </span><h2 align="left" class="paragraph-headline-source">     Функции</h2><span id="lnk6e0644ba3bd7402cab2e89ee2511bf4f"> </span><div class="section"><p align="justify" class="paragraph-source">     Функция - это подпрограмма, которая вычисляет значение. Функции структурируются так же, как и процедуры, с той разницей, что функции содержат фразу RETURN. Вы пишете функции, используя синтаксис </p><p align="left" class="paragraph-source">FUNCTION имя [ (аргумент [, аргумент, ...]) ] RETURN тип_данн IS <br />[локальные объявления] <br />BEGIN <br />исполняемые предложения <br />[EXCEPTION <br />обработчики исключений] <br />END [имя]; </p><p align="left" class="paragraph-source">где каждый "аргумент" имеет следующий синтаксис: </p><p align="left" class="paragraph-source">имя_перем [IN | OUT | IN OUT] тип_данных [{:= | DEFAULT} знач] </p><p align="justify" class="paragraph-source">     Здесь моды IN | OUT | IN OUT, определяющие тип параметра, являются необязательными. Как необязательным является определение значений по умолчанию, которые могут быть заданы двумя способами: </p><p align="left" class="paragraph-source">:=значение либо DEFAULT значение. </p></div><span id="lnk7afc5ad6af174cbe90e4477fbc0e9a93"> </span><div class="section"><p align="justify" class="paragraph-source">     В отличие от спецификатора типа данных в объявлении переменной, спецификатор типа данных для параметра не может иметь ограничений. Как и процедура, функция имеет две части: спецификацию и тело. Спецификация функции начинается с ключевого слова FUNCTION и заканчивается фразой RETURN, которая специфицирует тип результирующего значения. Объявления аргументов необязательны. Если функция не принимает аргументов, скобки также не кодируются. Тело функции начинается с ключевого слова IS и заканчивается ключевым словом END, за которым может следовать имя функции. Тело функции состоит из трех частей: декларативной части, исполняемой части и необязательной части обработки исключений. </p><p align="justify" class="paragraph-source">     Декларативная часть содержит локальные объявления, которые помещаются между ключевыми словами IS и BEGIN. Ключевое слово DECLARE, которое начинает декларативную часть в анонимном блоке PL/SQL, здесь не используется. </p><p align="justify" class="paragraph-source">     Исполняемая часть содержит предложения, которые помещаются между ключевыми словами BEGIN и EXCEPTION (или END). В исполняемой части процедуры должно встретиться хотя бы одно предложение RETURN. </p><p align="justify" class="paragraph-source">     Часть обработки исключений содержит обработчики исключений, которые помещаются между ключевыми словами EXCEPTION и END (будет рассмотрено позже).</p></div><span id="lnkcd1fe7a0bcd845d08a3b42ed2a607e2f"> </span><div class="section"><p align="justify" class="paragraph-source">     Рассмотрим процедуру quantity _ok, которая определяет, есть ли товар с заданным номером на складе в нужном объеме: </p><p align="left" class="paragraph-source">FUNCTION quantity_ok (goods_id1 NUMBER, quantity1 NUMBER) RETURN BOOLEAN IS </p><p align="left" class="paragraph-source">Sum_quantity NUMBER(6); <br />BEGIN <br />SELECT SUM(quantity) INTO Sum_quantity FROM storages WHERE goods_id = goods_id1; <br />RETURN (Sum_quantity &gt;= quantity1); <br />END quantity_ok; </p><p align="justify" class="paragraph-source">     При своем вызове эта функция принимает номер товара и требуемое количество товара. Она использует номер товара, чтобы посчитать суммарное количество товара на складах из таблицы базы данных storages . Если суммарное количество превышает требуемое, функция возвращает TRUE, в противном случае - FALSE . </p><p align="left" class="paragraph-source">     Функции вызываются как часть выражения. </p><p align="justify" class="paragraph-source">     Например, функция quantity _ ok может быть вызвана так: </p><p align="left" class="paragraph-source">IF quantity_ok (new_goods_id, need_quantity) THEN <br />... <br />END IF ; <br />... <br />done := quantity_ok (new_goods_id, need_quantity); </p><p align="left" class="paragraph-source">     Идентификатор функции является выражением, которое заменяется своим значением. </p></div><span id="lnk73446187f6864ed2b2c4a094467f2d25"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Предложение RETURN </b></p></div><span id="lnk8f6d63c9b567407f89ddbe507a714a1d"> </span><div class="section"><p align="justify" class="paragraph-source">     Предложение RETURN немедленно завершает выполнение подпрограммы и возвращает управление вызывающей программе. Выполнение продолжается с предложения, следующего за вызовом подпрограммы. Подпрограмма может содержать несколько предложений RETURN, ни одно из которых не обязано быть последним лексическим предложением в подпрограмме. Выполнение любого из них немедленно завершает подпрограмму. Однако наличие в подпрограмме нескольких точек выхода не является хорошей практикой программирования. В процедурах предложение RETURN не может содержать выражение. Это предложение просто возвращает управление вызывающей программе до достижения нормального конца процедуры. Однако в функциях предложение RETURN должно содержать выражение, которое вычисляется при выполнении предложения RETURN. Результирующее значение присваивается идентификатору функции. </p><p align="justify" class="paragraph-source">     Поэтому функция должна содержать хотя бы одно предложение RETURN. В противном случае PL/SQL возбуждает предопределенное исключение PROGRAM_ERROR во время выполнения. </p><p align="justify" class="paragraph-source">     Не путайте предложение RETURN с фразой RETURN, которая специфицирует тип данных результирующего значения в спецификации функции. </p></div><span id="lnkd70f5698de4f438ca1c4f5909cd5fe86"> </span><h2 align="left" class="paragraph-headline-source">     Вызов подпрограмм </h2><span id="lnk33a6a6ac65724c04ad84ee448de77a49"> </span><div class="section"><p align="justify" class="paragraph-source">     Итак, встроенные функции PL / SQL являются собственными функциями этого языка и они хранятся на сервере ORACLE. Если у вас есть Процедурное расширение базы данных, то вы можете компилировать собственные (пользовательские) подпрограммы отдельно и сохранять их в базе данных ORACLE, где они готовы к выполнению. </p><p align="justify" class="paragraph-source">     Вы можете вызывать хранимые встроенные и пользовательские подпрограммы из триггера базы данных, другой хранимой подпрограммы, приложения прекомпилятора ORACLE, приложения OCI или из инструмента ORACLE, такого как SQL*Plus. </p><p align="justify" class="paragraph-source">     Хранимая подпрограмма может вызывать другую хранимую подпрограмму. Например, в анонимном блоке в вызове процедуры может появиться вызов встроенной функции </p><p align="left" class="paragraph-source">BEGIN <br />… <br />insert_ware (CONCAT(country, Kharkov'), 2000); <br />… <br />END; </p><p align="justify" class="paragraph-source">     Вы можете вызывать хранимые подпрограммы интерактивно из инструментов ORACLE, таких как SQL*Plus, SQL*Forms или SQL*DBA. Например, из SQL*Plus вы могли бы вызвать независимую процедуру insert _ ware следующим образом: </p><p align="left" class="paragraph-source">SQL&gt; EXECUTE insert_ware (CONCAT(country, Kharkov'), 2000); </p><p align="left" class="paragraph-source">или </p><p align="left" class="paragraph-source">SQL&gt; EXEC insert_ware (CONCAT(country, Kharkov'), 2000); </p><p align="justify" class="paragraph-source">     Вызов функций из SQL*Plus происходит следующим образом: </p><p align="left" class="paragraph-source">SQL&gt; SELECT fac(5) FROM SYS.DUAL; </p><p align="left" class="paragraph-source">или </p><p align="left" class="paragraph-source">SQL&gt; SELECT fac(5) FROM DUAL; </p><p align="justify" class="paragraph-source">     Поскольку функция должна вернуть значение, SQL*Plus использует с этой целью системную таблицу DUAL , расположенную в схеме системного администратора SYS . </p><p align="justify" class="paragraph-source">     Рассмотрим пример вызова в SQL*Plus встроенной функции преобразования типов данных  TO _ CHAR  (рис. 7): </p><p align="left" class="paragraph-source">SQL&gt; SELECT TO_CHAR(SYSDATE, YEAR MONTH DAY DD') FROM DUAL; </p></div><span id="lnk7beec0f1e53247558c86d37cea584b63"> </span><div class="section"><p align="center" class="paragraph-source"><img src="../res/files/jpg1fa_0__0_.jpeg" height="157px" width="497px" alt="" /> </p><p align="center" class="paragraph-source"></p><p align="center" class="paragraph-source">Рисунок 7 - Пример вызова встроенной функции </p><p align="center" class="paragraph-source"></p><p align="justify" class="paragraph-source">     Функция первый параметр получает с помощью другой встроенной функции SYSDATE , а затем полученное значение приводит к формату  YEAR MONTH DAY DD '. Таким образом, показанные вызов функции позволяет вернуть текущую дату в формате: год прописью, название месяца, название дня недели и число. </p><p align="justify" class="paragraph-source">     Перед выполнением хранимой подпрограммы ORACLE устанавливает неявную точку сохранения. Если подпрограмма сбивается в результате необработанного исключения, ORACLE осуществляет откат к этой точке сохранения. Тем самым отменяется вся работа, проделанная подпрограммой. </p><p align="justify" class="paragraph-source">     Тело независимой или пакетированной хранимой подпрограммы может содержать любое предложение SQL или PL/SQL. Однако подпрограммы, участвующие в распределенной транзакции, триггерах базы данных и приложениях SQL*Forms, не могут вызывать хранимых подпрограмм, содержащих предложения COMMIT, ROLLBACK или SAVEPOINT. Обращения к хранимым функциям могут появляться в процедурных предложениях, но НЕ в предложениях SQL. </p></div></div></td></tr></table></td></tr><tr><td id="bottomOuter"><table id="bottomInner"><tr><td class="cell1"><div> </div></td><td class="cell2"><div>© 2012 ХНУРЭ, ПИ, Широкопетлева М.С., <a href="mailto:mshirokopetleva@gmail.com">mshirokopetleva@gmail.com</a>;   ХНУРЭ, ПИ, Черепанова Ю.Ю.;   ХНУРЭ, ПИ, Мазурова О.А.<br /><a href="http://lersus.de/" title="Данный курс создан с помощью авторской системы LERSUS" target="_blank">Разработано с помощью LERSUS</a></div></td></tr></table></td></tr></table></body></html>