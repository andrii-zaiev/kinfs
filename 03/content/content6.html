<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="LERSUS 3.3.0.0" /><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Корпоративные информационные системы — Теория — Команды управления</title><script language="javascript" type="text/javascript" src="../../00/styles/files/apiwrapper.js"> </script><script language="javascript" type="text/javascript" src="../../00/styles/files/sco.js"> </script><link href="../../00/styles/files/style.css" rel="stylesheet" type="text/css" /></head><body><table id="mainOuter"><tr><td id="topOuter"><table id="topInner"><tr class="row1"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4" id="shortcuts"><div><ul class="level0"><li><a href="../../00/content/authors1.html">Авторы</a></li><li>|</li><li><a href="../../00/content/contacts1.html">Контакты</a></li><li>|</li><li><a href="../../00/content/instructions1.html">Методические указания</a></li><li>|</li><li><a href="../../00/content/annotation1.html">Аннотация</a></li><li>|</li><li><a href="#" onclick="history.back(); return false;">Назад</a></li></ul></div></td></tr><tr class="row2"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4"><div id="courseTitle">Корпоративные информационные системы</div><div id="courseSubTitle">Языки запросов к базам данных : Команды управления</div></td></tr></table></td></tr><tr><td id="contentOuter"><table id="contentInner"><tr><td class="menuOuter"><table class="menuInner"><tr><td><ul class="level0"><li><a href="../../00/styles/courses.html">Содержание курса</a></li><li><span>Теория</span></li><ul class="level1"><li><a href="../../03/content/content1.html">Оптимизация запросов</a></li><li><a href="../../03/content/content2.html">Окружение 4-го поколения</a></li><li><a href="../../03/content/content3.html">Язык PL / SQL. Общие положения </a></li><li><a href="../../03/content/content4.html">Переменные и константы. Кодовое множество</a></li><li><a href="../../03/content/content5.html">Типы данных</a></li><li><a href="../../03/content/content6.html">Команды управления</a></li><li><a href="../../03/content/content7.html">Создание хранимых процедур и функций </a></li><li><a href="../../03/content/content8.html">Параметры подпрограмм</a></li><li><a href="../../03/content/content9.html">Встроенные функции PL / SQL</a></li><li><a href="../../03/content/content10.html">Курсоры</a></li><li><a href="../../03/content/content11.html">Исключительные ситуации</a></li><li><a href="../../03/content/content12.html">Обработчики исключений </a></li><li><a href="../../03/content/content13.html">Пакеты</a></li><li><a href="../../03/content/content14.html">Триггеры объектов </a></li></ul><li><span>Практика</span></li><ul class="level1"><li><a href="../../03/content/example1.html">Практика 2. Использование подпрограмм в языках  программирования 4-го поколения</a></li><li><a href="../../03/content/example2.html">Лабораторная работа 2 Подпрограммы как средство создания серверных частей информационных систем на примере СУБД Oracle </a></li><li><a href="../../03/content/example3.html">Практика 3. Создание  и работа с триггерами объектов и событий</a></li><li><a href="../../03/content/example4.html">Лабораторная работа 3. Триггеры объектов и событий базы данных </a></li></ul><li><span>Текущий контроль знаний</span></li><ul class="level1"><li><a href="../../03/content/multiply-choice-test25.html">Управляющие структуры</a></li><li><a href="../../03/content/multiply-answers-test7.html">Подпрограммы языка PL/SQL</a></li><li><a href="../../03/content/multiply-choice-test1.html">Курсоры</a></li><li><a href="../../03/content/multiply-answers-test12.html">Исключительные ситуации</a></li><li><a href="../../03/content/multiply-choice-test19.html">Пакеты</a></li><li><a href="../../03/content/multiply-answers-test3.html">Триггеры</a></li></ul><li><a href="../../03/styles/glossary.html">Словарь терминов</a></li><li><a href="../../03/03.pdf" target="_blank">Версия для печати</a></li></ul></td></tr></table></td><td class="content"><div id="content"><div id="topBlankStripe"> </div><span id="lnk1f40b436525f4ddc883c23cea34ba069"> </span><h1 align="left" class="headline-source">     Команды управления</h1><span id="lnk8cc93d2696c1451481e949589214bdab"> </span><h2 align="left" class="paragraph-headline-source">     Условное управление: предложения IF </h2><span id="lnk660631c5f0194e3aa2f2af6de6aae0a4"> </span><div class="section"><p align="justify" class="paragraph-source">     Часто бывает необходимо предпринять альтернативные действия в зависимости от обстоятельств. Предложение IF позволяет вам выполнить последовательность предложений условно. Это значит, что, будет выполнена эта последовательность или нет, зависит от значения условия. Есть три формы предложений IF: IF-THEN, IF-THEN-ELSE и IF-THEN-ELSIF. </p></div><span id="lnk98f648e441c94c9d8b4350a78e3c752b"> </span><div class="section"><p align="left" class="paragraph-source">     <b>IF-THEN </b></p></div><span id="lnk5c9330da7e5e447098a0a132e489fdc9"> </span><div class="section"><p align="justify" class="paragraph-source">     Простейшая форма предложения IF ассоциирует условие с последовательностью предложений, окружаемой ключевыми словами THEN и END IF (не ENDIF), как показано ниже: </p><p align="justify" class="paragraph-source">IF условие THEN <br />ряд_предложений; <br /></p><p align="left" class="paragraph-source">END IF; </p></div><span id="lnka7e59b5454f8483e979c64059613b106"> </span><div class="section"><p align="justify" class="paragraph-source">     Последовательность предложений выполняется, только если условие дает TRUE. Если условие дает FALSE или NULL, то предложение IF ничего не делает. В любом случае, управление передается на следующее предложение. </p><p align="justify" class="paragraph-source">     Пример : </p><p align="justify" class="paragraph-source">IF price &gt; max_price THEN <br />Skidka:=ycenka(goods_id_1); <br />UPDATE goods SET price = price - skidka WHERE goods_id = goods_id_1; <br />END IF; </p><p align="justify" class="paragraph-source">     Вы можете, если хотите, записывать короткие предложения IF в одну строку, например: </p><p align="justify" class="paragraph-source">IF x &gt; y THEN z:= x; END IF; </p></div><span id="lnkf7f39c92051145be9e1c5ff86c865a37"> </span><div class="section"><p align="left" class="paragraph-source">     <b>IF-THEN-ELSE </b></p></div><span id="lnk16f9fdde9a8c4264902be1dee7a761c0"> </span><div class="section"><p align="justify" class="paragraph-source">     Вторая форма предложения IF добавляет ключевое слово ELSE, за которым следует альтернативная последовательность предложений: </p><p align="justify" class="paragraph-source">IF условие THEN <br />ряд_предложений1; <br />ELSE <br />ряд_предложений2; <br />END IF; </p><p align="justify" class="paragraph-source">     Последовательность предложений в фразе ELSE выполняется, только если условие дает FALSE или NULL. Таким образом, фраза ELSE гарантирует, что одна из последовательностей предложений будет выполнена. В следующем примере, первое или второе предложение UPDATE будет выполнено, когда условие соответственно истинно или ложно: </p><p align="left" class="paragraph-source">IF storage_need1 = 'refregirator' THEN <br />INSERT INTO storages VALUES (5, ref1, 3, ….); <br />ELSE <br />INSERT INTO storages VALUES (5, ref2, 3, ….); <br />END IF; </p><p align="justify" class="paragraph-source">     Последовательности предложений, включаемые в фразы IF и ELSE, сами могут содержать предложения IF. Следовательно, предложения IF могут вкладываться друг в друга, как показывает следующий пример: </p><p align="left" class="paragraph-source">IF storage_need1 = 'refregirator' THEN <br />INSERT INTO storages VALUES (5, ref1, 3, ….); <br />ELSE <br />IF (volume_goods&lt;volume_ref2) THEN <br />INSERT INTO storages VALUES (5, ref2, 3, ….); <br />ELSE <br />INSERT INTO storages VALUES (5, ref3, 3, ….); <br />END IF; <br />END IF; </p></div><span id="lnk3f3ec1b23c004735bad1d8ec2c500d3e"> </span><div class="section"><p align="left" class="paragraph-source">     <b>IF-THEN-ELSIF </b></p></div><span id="lnkdad91d8a26d9406fbdddbbcbaf7c2c12"> </span><div class="section"><p align="justify" class="paragraph-source">     Иногда вы хотите выбрать действие из нескольких взаимно исключающих альтернатив. Третья форма предложения IF использует ключевое слово ELSIF (не ELSE IF), чтобы ввести дополнительные условия: </p><p align="justify" class="paragraph-source">IF условие1 THEN <br />ряд_предложений1; <br />ELSIF условие2 THEN <br />ряд_предложений2; <br />ELSE ряд_предложений3; <br />END IF; </p><p align="justify" class="paragraph-source">     Если первое условие дает FALSE или NULL, фраза ELSIF проверяет следующее условие. В предложении IF может быть сколько угодно фраз ELSIF; последняя фраза ELSE необязательна. Условия вычисляются по одному сверху вниз. Если любое условие даст TRUE, выполняется соответствующая последовательность предложений, и управление передается на следующее за IF предложение (без вычисления оставшихся условий). Если все условия дадут FALSE или NULL, выполняется последовательность предложений в фразе ELSE, если она есть. </p><p align="left" class="paragraph-source">     Рассмотрим следующий пример: </p><p align="left" class="paragraph-source">IF quantity1 &gt; 10000 THEN <br />payment:= 100; <br />ELSIF quantity1 &gt; 5000 THEN <br />payment:= 70; ELSE payment := 50; <br />END IF; <br />INSERT INTO payment_book VALUES (storage_id, payment, ...); </p><p align="justify" class="paragraph-source">     Если значение quantity 1 превышает 10000, истинны как первое, так и второе условия. Тем не менее, переменной payment присваивается правильное значение 100, потому что второе условие проверяться не будет, а управление сразу будет передано на предложение INSERT. </p><p align="justify" class="paragraph-source">     Избегайте неуклюжих предложений IF, подобных следующему примеру: </p><p align="left" class="paragraph-source">DECLARE <br />... <br />over BOOLEAN; <br />BEGIN <br />... <br />IF price1&gt; max_price THEN <br />over:= TRUE; <br />ELSE over:= FALSE; <br />END IF; <br />... <br />IF over = TRUE THEN <br />Ycenka(goods_id1,price1); <br />END IF; <br />END; </p><p align="justify" class="paragraph-source">     Этот код игнорирует два полезных факта. Во-первых, значение булевского выражения можно непосредственно присваивать булевской переменной. Так, первое предложение IF можно заменить простым присваиванием: </p><p align="justify" class="paragraph-source">over:= price&gt; max_price; </p><p align="justify" class="paragraph-source">     Во-вторых, булевская переменная сама имеет значение TRUE либо FALSE. Поэтому условие во втором предложении IF можно упростить: </p><p align="justify" class="paragraph-source">IF over THEN ... </p><p align="justify" class="paragraph-source">     По мере возможности, используйте фразу ELSIF вместо вложенных предложений IF. При этом ваш код будет легче читать и понимать. </p></div><span id="lnkfb83af2d6432474f97555180c30f0564"> </span><h2 align="left" class="paragraph-headline-source">     Итеративное управление</h2><span id="lnk1323cfbe26b7443692095e98016cdd0b"> </span><h2 align="left" class="paragraph-headline-source">     Предложения LOOP и EXIT </h2><span id="lnkca168eba000644bdafc0502939681b44"> </span><div class="section"><p align="justify" class="paragraph-source">     Предложения LOOP позволяют выполнить последовательность предложений несколько раз. Есть три формы предложения LOOP: LOOP , WHILE - LOOP и FOR - LOOP . </p></div><span id="lnk1fee42a1682045c9bfd79bd5f2087c51"> </span><div class="section"><p align="left" class="paragraph-source">     <b>LOOP </b></p></div><span id="lnkacd18f7f06b347b6b38f6611f627f467"> </span><div class="section"><p align="left" class="paragraph-source"></p><p align="justify" class="paragraph-source">     Простейшую форму предложения LOOP представляет основной (или бесконечный) цикл, который окружает последовательность предложений между ключевыми словами LOOP и END LOOP: </p><p align="justify" class="paragraph-source">LOOP <br />ряд_предложений <br />END LOOP; </p><p align="justify" class="paragraph-source">     При каждой итерации цикла последовательность предложений выполняется, а затем управление передается на начало цикла. Если дальнейшее повторение нежелательно или невозможно, вы можете использовать предложение EXIT, чтобы закончить цикл. Вы можете поместить сколько угодно предложений EXIT внутри цикла, но только не вне цикла. Есть две формы предложения EXIT: EXIT и EXIT WHEN. </p></div><span id="lnk08d19eefce7d445285919e377899ea0d"> </span><div class="section"><p align="left" class="paragraph-source">     <b>EXIT </b></p></div><span id="lnk85e0202b8e314e1fade9c7d57ba68d6b"> </span><div class="section"><p align="justify" class="paragraph-source">     Предложение EXIT форсирует безусловное завершение цикла. Когда встречается предложение EXIT, цикл немедленно заканчивается, и управление передается на следующее (за END LOOP) предложение. </p><p align="justify" class="paragraph-source">     Пример: </p><p align="justify" class="paragraph-source">LOOP <br />... <br />IF ... THEN <br />... <br />EXIT; -- немедленно выходит из цикла <br />END IF; <br />END LOOP; -- управление передается сюда </p><p align="justify" class="paragraph-source">     Как показывает следующий пример, вы не можете использовать предложение EXIT, чтобы завершить блок PL/SQL: </p><p align="justify" class="paragraph-source">BEGIN <br />... <br />IF ... THEN <br />... <br />EXIT; -- незаконно <br />END IF; <br />END; </p><p align="justify" class="paragraph-source">     Не забывайте, что предложение EXIT можно применять только внутри цикла. Чтобы выйти из блока PL/SQL до достижения его нормального конца, можно использовать предложение RETURN. </p></div><span id="lnk7275138becc344c089d26f971ea2178a"> </span><div class="section"><p align="left" class="paragraph-source">     <b>EXIT-WHEN </b></p></div><span id="lnk2a60c78e16954de18eb6cf2ec5f0ff1f"> </span><div class="section"><p align="justify" class="paragraph-source">     Предложение EXIT-WHEN позволяет завершить цикл условно. Когда встречается это предложение, вычисляется условие в фразе WHERE. Если это условие дает TRUE, цикл завершается, и управление передается на предложение, следующее за циклом. </p><p align="left" class="paragraph-source">     Пример : </p><p align="left" class="paragraph-source">LOOP <br />SELECT quantity INTO quantity1 FROM storages WHERE storage_id=45; <br />EXIT WHEN SQL %NOTFOUND; -- выйти из цикла при условии <br />... <br />END LOOP; </p><p align="justify" class="paragraph-source">     Пока условие не станет истинным, цикл не может завершиться. Поэтому, предложения внутри цикла должны изменять значение условия. В последнем примере, если предложение SELECT извлекает строку, условие дает FALSE. Когда предложение SELECT не сможет возвратить строку, условие даст TRUE, цикл завершится, и управление будет передано на предложение CLOSE. Предложение EXIT-WHEN заменяет простое предложение IF. </p><p align="justify" class="paragraph-source">     Например, сравните следующие предложения: </p><p align="left" class="paragraph-source">IF price1 &gt; 100 THEN <br />EXIT; <br />EXIT WHEN price1&gt; 100; <br />END IF; </p><p align="justify" class="paragraph-source">     Эти предложения логически эквивалентны, но предложение EXIT-WHEN легче читается и понимается. </p></div><span id="lnk00bc106ecf254a3fbfef9424a6eeb188"> </span><h2 align="left" class="paragraph-headline-source">     Метки циклов </h2><span id="lnkf67f9dac1d484cedb050afa4b846b961"> </span><div class="section"><p align="justify" class="paragraph-source">     Как и блоки PL/SQL, циклы могут иметь метки. Метка, необъявляемый идентификатор в двойных угловых скобках, должна появиться в начале предложения LOOP: </p><p align="justify" class="paragraph-source">&lt;&lt;имя_метки&gt;&gt; <br />LOOP <br />ряд_предложений <br />END LOOP; </p><p align="justify" class="paragraph-source">     Имя метки цикла может также (необязательно) появиться в конце цикла в предложении END LOOP, как показывает следующий пример: </p><p align="justify" class="paragraph-source">&lt;&lt; my _ loop &gt;&gt; <br />LOOP <br />... <br />END LOOP my _ loop ; </p><p align="justify" class="paragraph-source">     Когда вы используете вложенные циклы, конечные метки циклов улучшают читабельность программы. </p><p align="justify" class="paragraph-source">     Обе формы предложения EXIT позволяют выйти не только из текущего цикла, но из любого окружающего цикла. Просто дайте метку тому циклу, который вы хотите завершить, а затем укажите эту метку в предложении EXIT : </p><p align="left" class="paragraph-source">&lt;&lt; outer &gt;&gt; <br />LOOP <br />... <br />LOOP <br />... <br />EXIT outer WHEN ... -- выйти из обоих циклов <br />END LOOP; <br />... <br />END LOOP outer; </p><p align="justify" class="paragraph-source">     Выход осуществляется из всех окружающих циклов, вплоть до того, чья метка специфицирована в предложении EXIT. </p></div><span id="lnk3c5d87d9144c44db8a56a004073b9a7f"> </span><div class="section"><p align="left" class="paragraph-source">     <b>WHILE-LOOP </b></p></div><span id="lnk3f64333297cb4b9096e720a835f6c096"> </span><div class="section"><p align="justify" class="paragraph-source">     Предложение WHILE-LOOP ассоциирует условие с последовательностью предложений, окруженной ключевыми словами LOOP и END LOOP: </p><p align="justify" class="paragraph-source">WHEN условие LOOP <br />ряд_предложений; <br />END LOOP; </p><p align="justify" class="paragraph-source">     Перед каждой итерацией цикла условие проверяется. Если оно дает TRUE, то последовательность предложений выполняется, и управление возвращается на начало цикла. Если условие дает FALSE или NULL, то цикл обходится, и управление передается на следующее предложение. </p><p align="left" class="paragraph-source">     Пример: </p><p align="left" class="paragraph-source">WHILE summa &lt;= 50000 LOOP <br />... </p><p align="left" class="paragraph-source">SELECT price*quantity INTO sum1 FROM goods, storages WHERE goods.goods_id=storages.goods_id AND ... <br />summa := summa + sum1; <br />END LOOP; </p><p align="justify" class="paragraph-source">     Число повторений цикла зависит от условия и неизвестно до тех пор, пока цикл не завершится. Поскольку условие проверяется в начале цикла, последовательность предложений может не выполниться ни разу. В последнем примере, если начальное значение переменной summa окажется больше 50000, условие даст FALSE, и цикл будет обойден. </p><p align="justify" class="paragraph-source">     В некоторых языках имеется структура LOOP UNTIL или REPEAT UNTIL, которая проверяет условие не в начале, а в конце итерации цикла. Поэтому гарантируется хотя бы однократное выполнение тела цикла. В PL/SQL такой структуры нет, но вы легко можете ее смоделировать: </p><p align="left" class="paragraph-source">LOOP <br />ряд_предложений; <br />EXIT WHEN булевское_выражение; <br />END LOOP; </p><p align="justify" class="paragraph-source">     Чтобы гарантировать хотя бы однократное выполнение цикла WHILE, используйте в условии инициализированную булевскую переменную: </p><p align="left" class="paragraph-source">done := FALSE; <br />WHILE NOT done LOOP <br />ряд_предложений; <br />done := булевское_выражение; <br />END LOOP; </p><p align="justify" class="paragraph-source">     Какое-то предложение внутри цикла должно присвоить булевской переменной новое значение. В противном случае вы получите бесконечный цикл. Например, следующие предложения LOOP логически эквивалентны: </p><p align="left" class="paragraph-source">WHILE TRUE LOOP <br />… <br />END LOOP; <br />LOOP <br />... <br />END LOOP ;      </p></div><span id="lnk8fc15c0495624f51a04e19d879e828c5"> </span><div class="section"><p align="left" class="paragraph-source">     <b>FOR - LOOP </b></p></div><span id="lnk5997a954da74461da2b1da1d11e85450"> </span><div class="section"><p align="justify" class="paragraph-source">     В то время как число итераций цикла WHILE неизвестно до тех пор, пока цикл не завершится, для цикла FOR число итераций известно до того, как войти в цикл. Циклы FOR осуществляют свои итерации по заданному интервалу целых чисел. (Курсорные циклы FOR, которые повторяются по активному множеству курсора, обсуждаются в теме 9) </p><p align="justify" class="paragraph-source">     Этот интервал является частью СХЕМЫ ИТЕРАЦИЙ, которая окружается ключевыми словами FOR и LOOP. Синтаксис имеет следующий вид: </p><p align="left" class="paragraph-source">FOR счетчик IN [REVERSE] нижняя_граница..верхняя_граница LOOP <br />ряд_предложений; <br />END LOOP; </p><p align="justify" class="paragraph-source">     Интервал вычисляется один раз, при первом входе в цикл, и больше не перевычисляется. Как показывает следующий пример, последовательность предложений выполняется один раз для каждого целого в заданном интервале. После каждой итерации выполняется приращение индекса цикла. </p><p align="left" class="paragraph-source">FOR i IN 2..5 LOOP -- присваивает переменной i значения 2, 3, 4, 5 <br />ряд_предложений; -- будет выполнен 4 раза <br />END LOOP; </p></div><span id="lnka3d6e86fb38a48e8998fdd8d068f6fff"> </span><div class="section"><p align="left" class="paragraph-source">     Как показывает следующий пример, если нижняя граница интервала совпадает с верхней, цикл выполняется один раз: </p><p align="left" class="paragraph-source">FOR i IN 3..3 LOOP -- присваивает переменной i значение 3 <br />ряд_предложений; -- будет выполнен один раз <br />END LOOP; </p><p align="justify" class="paragraph-source">     По умолчанию индекс наращивается на 1 от нижней до верхней границы. Однако, если вы используете ключевое слово REVERSE, индекс будет изменяться в обратном направлении, от верхней границы к нижней, как показывает следующий пример. После каждой итерации индекс уменьшается на 1. </p><p align="left" class="paragraph-source">FOR i IN REVERSE 1..3 LOOP -- присваивает переменной i 3, 2, 1 <br />ряд_предложений; -- будет выполнен три раза <br />END LOOP; </p></div><span id="lnkde282393396048fbae35adeefe955d67"> </span><div class="section"><p align="justify" class="paragraph-source">     Тем не менее, и в этом случае вы записываете границы интервала в возрастающем (а не убывающем) порядке. Внутри цикла FOR к индексу цикла можно обращаться как к константе. Поэтому индекс может встречаться в выражениях, но ему нельзя присваивать значений, как показывает следующий пример: </p><p align="left" class="paragraph-source">FOR goods_id1 IN 1..10 LOOP <br />... <br />IF NOT finished THEN <br />INSERT INTO ... VALUES (goods_id1, ...); -- законно <br />goods_id1 := goods_id1 +1; -- не законно <br />END IF; </p><p align="left" class="paragraph-source">END LOOP; </p></div><span id="lnk0ffdabfb149a4d868ca8354ee6c1b210"> </span><h2 align="left" class="paragraph-headline-source">     Схемы итераций</h2><span id="lnk96f72d36e7a942b88b5f484b0fb6b2ec"> </span><div class="section"><p align="justify" class="paragraph-source">      Границами интервала цикла могут быть литералы , переменные или выражения, но их значения должны быть целочисленными. Например, следующие схемы итераций законны: </p><p align="justify" class="paragraph-source">j IN -5..5 <br />k IN REVERSE first .. last <br />step IN 0..TRUNC(high/low) * 2 <br />code IN ASCII('A')..ASCII('J') </p><p align="justify" class="paragraph-source">     Как видите, нижняя граница не обязана быть равна 1. Однако приращение (или отрицательное приращение) счетчика цикла всегда равно 1. В некоторых языках существует фраза, с помощью которой можно задать другую величину приращения. В PL/SQL такой структуры не существует, но вы можете легко смоделировать ее.      </p></div><span id="lnk46276fadf0244db6a6fa6b171655a87d"> </span><div class="section"><p align="justify" class="paragraph-source">     Рассмотрим следующий пример: </p><p align="left" class="paragraph-source">FOR j IN 5..15 LOOP -- присваивает j значения 5,6,7,... <br />IF MOD(j, 5) = 0 THEN -- выбирает кратные 5 <br />ряд_предложений; -- j имеет значения 5,10,15 <br />END IF; <br />END LOOP; </p><p align="justify" class="paragraph-source">     Внутри поседовательности предложений счетчик цикла будет иметь лишь значения 5, 10 и 15. Вы можете предпочесть не столь элегантный, но более эффективный способ, показанный в следующем примере. Внутри последовательности предложений при каждом обращении к счетчику цикла его значение умножается на 5. </p><p align="left" class="paragraph-source">FOR j IN 1..3 LOOP -- присваивает j значения 1,2,3 <br />ряд_предложений; -- вместо j обращаться к j*5 <br />END LOOP; </p></div><span id="lnk80248a33c94f4c62bd95c3bd82a63486"> </span><div class="section"><p align="justify" class="paragraph-source">     Динамические интервалы PL/SQL позволяет определять интервал цикла динамически во время выполнения, как показывает следующий пример: </p><p align="left" class="paragraph-source">SELECT COUNT(goods_id) INTO goods_count FROM goods; <br />FOR i IN 1..goods_count LOOP <br />... <br />END LOOP; </p><p align="justify" class="paragraph-source">     Значение goods _count неизвестно во время компиляции; предложение SELECT возвращает это значение во время выполнения. </p><p align="justify" class="paragraph-source">     Если вычисленная нижняя граница интервала окажется больше верхней (как показывает следующий пример), последовательность предложений внутри цикла не будет выполняться, и управление будет передано на следующее за циклом предложение: </p><p align="left" class="paragraph-source">-- limit получает значение 1 <br />FOR i IN 2..limit LOOP <br />ряд_предложений; -- не выполнится ни разу <br />END LOOP; -- управление будет передано сюда </p></div><span id="lnk2db7370d8ad04c3a8b6a31d9905de9a5"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Правила сферы </b></p></div><span id="lnkcdec0aa2272a40d5b13075773c3c856d"> </span><div class="section"><p align="justify" class="paragraph-source">     Счетчик цикла определен только внутри цикла. Вы не можете обратиться к нему вне цикла. После выхода из цикла значение счетчика цикла не определено, как показывает следующий пример: </p><p align="left" class="paragraph-source">FOR goods_id1 IN 1..10 LOOP <br />... <br />END LOOP; <br />Next_goods:= goods_id1 +1; -- незаконно </p><p align="justify" class="paragraph-source">     Вы не обязаны явно объявлять счетчик цикла, потому что он неявно объявляется как локальная переменная типа INTEGER. Как показывает следующий пример, это локальное объявление перекрывает любое глобальное объявление: </p><p align="left" class="paragraph-source">DECLARE goods_id1 INTEGER; <br />BEGIN <br />... <br />FOR goods_id1 IN 1..15 LOOP <br />... <br />IF goods _ id 1 &gt; 10 THEN ... -- обращается к счетчику цикла <br />END LOOP; <br />END; </p><p align="justify" class="paragraph-source">     Чтобы в этом примере обратиться к глобальной переменной goods _ id 1, вы должны использовать метку и квалифицированную ссылку: </p><p align="left" class="paragraph-source">&lt;&lt;main&gt;&gt; <br />DECLARE goods_id1 INTEGER; <br />BEGIN <br />... <br />FOR goods_id1 IN 1..15 LOOP <br />... <br />IF main . goods _ id 1 &gt; 10 THEN ... --обращается к глоб.переменной <br />END LOOP ; <br />END main ; </p><p align="justify" class="paragraph-source">     Такие же правила сферы применимы к вложенным циклам FOR. Рассмотрим следующий пример. Оба счетчика циклов имеют одно и то же имя. Поэтому для того, чтобы обратиться из внутреннего цикла к счетчику внешнего цикла, вы должны использовать метку и квалифицированную ссылку: </p><p align="left" class="paragraph-source">&lt;&lt;outer&gt;&gt; <br />FOR step IN 1..25 LOOP <br />FOR step IN 1..10 LOOP <br />... <br />IF outer . step &gt; 15 THEN <br />... <br />END LOOP; <br />END LOOP outer; </p><p align="left" class="paragraph-source">     </p></div><span id="lnk17e50eedaf4240a7928294516b38f9ad"> </span><h2 align="left" class="paragraph-headline-source">     Использование предложения EXIT </h2><span id="lnke29c63a829ae4d45be2bd4978d7b8aa3"> </span><div class="section"><p align="justify" class="paragraph-source">     Предложение EXIT позволяет завершить цикл FOR прежде времени. Предложение EXIT позволяет выйти не только из текущего цикла FOR, но из любого окружающего цикла. Просто дайте метку тому циклу, который вы хотите завершить, а затем укажите эту метку в предложении EXIT : </p><p align="left" class="paragraph-source">&lt;&lt;outer&gt;&gt; <br />FOR i IN 1..5 LOOP <br />... <br />FOR j IN 1..10 LOOP <br />SELECT price INTO price1 FROM goods WHERE goods_id=2; <br />EXIT outer WHEN price1&gt;max+price; -- выход из обоих циклов <br />... <br />END LOOP ; <br />END LOOP outer; -- управление будет передано сюда </p></div><span id="lnk6d69ca651c7c4ff29e3d032aa8d8f7f1"> </span><h2 align="left" class="paragraph-headline-source">     Последовательное управление: предложения GOTO и NULL </h2><span id="lnke3189a527008407bbc0123a3d239618a"> </span><div class="section"><p align="justify" class="paragraph-source">     В отличие от предложений IF и LOOP, предложения GOTO и NULL не являются ключевыми в программировании на языке PL/SQL. Структура языка такова, что предложение GOTO требуется редко. Иногда его применение может быть оправдано некоторым упрощением логики. Предложение NULL может прояснить смысл условных предложений в программе и улучшить читабельность. </p></div><span id="lnk1edd1ded418f49b5a836967335b44ac9"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Предложение GOTO </b></p></div><span id="lnk320a014f1b6740dd86388e7a631214da"> </span><div class="section"><p align="justify" class="paragraph-source">     Предложение GOTO выполняет безусловный переход к указанной метке. Метка должна быть уникальной в своей сфере, и должна предшествовать выполнимому предложению или блоку PL/SQL. Предложение GOTO передает управление на помеченное предложение или блок. В следующем примере управление передается на выполнимое предложение, находящееся дальше в последовательности предложений: </p><p align="left" class="paragraph-source">BEGIN <br />... <br />GOTO insert _ row ; <br />... <br />&lt;&lt;insert_row&gt;&gt; <br />INSERT INTO goods VALUES ... <br />END; </p><p align="left" class="paragraph-source">     </p></div><span id="lnkf0947316ab0643a49dfa370adf8a5ce1"> </span><div class="section"><p align="justify" class="paragraph-source">     В следующем примере управление передается на блок PL/SQL, расположенный выше в последовательности предложений: </p><p align="left" class="paragraph-source">BEGIN <br />... <br />&lt;&lt;update_row&gt;&gt; <br />BEGIN <br />UPDATE goods SET ... ... END; <br />... <br />GOTO update_row; <br />... <br />END ; </p></div><span id="lnkc518bdf6a1134e40908304a984e1b2f4"> </span><div class="section"><p align="justify" class="paragraph-source">     В следующем примере метка &lt;&lt;end_loop&gt;&gt; незаконна, потому что она стоит не перед выполнимым предложением: </p><p align="left" class="paragraph-source">DECLARE <br />done BOOLEAN ; <br />BEGIN <br />... <br />FOR i IN 1..10 LOOP <br />IF done THEN <br />GOTO end_loop; <br />END IF; <br />... <br />&lt;&lt;end_loop&gt;&gt; -- незаконно <br />END LOOP; -- это не выполняемое предложение END; </p><p align="justify" class="paragraph-source">     Чтобы исправить последний пример, просто добавьте за меткой предложение NULL : </p><p align="left" class="paragraph-source">DECLARE <br /><br />BEGIN <br />... <br />FOR i IN 1..10 LOOP <br />IF done THEN <br />GOTO end_loop; <br />END IF; <br />... <br />&lt;&lt;end_loop&gt;&gt; <br />NULL; -- выполняемое предложение <br />END LOOP; <br />END; </p></div><span id="lnkcb9f79fdcba243a59434f9c0bbc0a5e4"> </span><div class="section"><p align="justify" class="paragraph-source">     Как показывает следующий пример, предложение GOTO может передать управление в окружающий блок из текущего блока: </p><p align="left" class="paragraph-source">DECLARE <br />New_name CHAR(20); <br />BEGIN <br />... <br />&lt;&lt;get_name&gt;&gt; <br />SELECT name INTO new_ename FROM goods WHERE ... <br />... <br />BEGIN <br />... <br />GOTO get_name; -- переход в окружающий блок <br />END; <br />END; </p><p align="left" class="paragraph-source">     Предложение GOTO передает управление в первый из окружающих блоков, в котором встретится указанная метка. </p></div><span id="lnk6768296e75054c1196cd8ec32153aedb"> </span><div class="section"><p align="justify" class="paragraph-source">     Некоторые возможные назначения предложения GOTO незаконны. В частности, предложение GOTO не может передавать управление в предложение IF, в предложение LOOP или в подблок. Например, следующее предложение GOTO незаконно: </p><p align="left" class="paragraph-source">BEGIN <br />... <br />GOTO update_row; -- незаконный переход в предложение IF <br />... <br />IF done THEN <br />... <br />&lt;&lt;update_row&gt;&gt; <br />UPDATE goods SET ... <br />END IF ; <br />END; </p></div><span id="lnk4950a9fd2e3749c294e570f8e2c08edc"> </span><div class="section"><p align="justify" class="paragraph-source">     Далее, предложение GOTO не может передавать управление из одной фразы предложения IF в другую, как показывает следующий пример: </p><p align="left" class="paragraph-source">BEGIN <br />... <br />IF done THEN ... <br />GOTO update _ row ; -- незаконный переход в фразу ELSE <br />ELSE <br />... <br />&lt;&lt;update_row&gt;&gt; <br />UPDATE goods SET ... <br />END IF; <br />END; </p></div><span id="lnkb0bf9a61f8f94982b7f02a1298d17b29"> </span><div class="section"><p align="justify" class="paragraph-source">     Следующий пример показывает, что предложение IF не может передавать управление из окружающего блока в подблок: </p><p align="left" class="paragraph-source">BEGIN <br />... <br />IF storage_need = 'refregirator' THEN <br />GOTO insert_ref; -- незаконный переход в подблок <br />END IF; <br />... <br />BEGIN <br />... <br />&lt;&lt;insert_ref&gt;&gt; <br />INSERT INTO storages VALUES ... <br />END ; <br />END ; </p><p align="justify" class="paragraph-source">     Чрезмерное применение предложений GOTO может привести к сложному, неструктурированному коду, который трудно понимать и сопровождать. Поэтому старайтесь использовать предложения GOTO пореже. </p></div><span id="lnk7201e6a01eb5429898bae5a817e6696d"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Предложение NULL </b></p></div><span id="lnk44cfe62bf416406eb724a7e5883f91c5"> </span><div class="section"><p align="justify" class="paragraph-source">     Предложение NULL явно специфицирует отсутствие действия; оно ничего не делает, и управление передается на следующее предложение. Оно, однако, может улучшить читабельность программы. В конструкте, допускающем альтернативные действия, предложение NULL используется для обозначения места действия. Оно напоминает читателю программы о том, что соответствующая альтернатива не была пропущена нечаянно, а просто не требует никакого действия. </p><p align="justify" class="paragraph-source">     Каждая фраза в предложении IF должны содержать хотя бы одно выполнимое предложение. Предложение NULL помогает удовлетворить этому требованию. Поэтому вы можете использовать предложение NULL в фразах, соответствующих тем обстоятельствам, в которых никакий действий не требуется. </p><p align="justify" class="paragraph-source">     В следующем примере предложение NULL подчеркивает, что премии получат лишь сотрудники с высоким рейтингом: </p><p align="left" class="paragraph-source">IF price1 &gt; max_price THEN <br />ycenka(goods_id1, price1); <br />ELSE <br />NULL; <br />END IF; </p><p align="justify" class="paragraph-source">     Предложение NULL предоставляет также удобный способ создания "затычек" при разработке приложения сверху вниз. Затычки - это фиктивные подпрограммы, с помощью которых вы откладываете определения процедур и функций до тех пор, пока не проверите и не отладите главную программу. </p><p align="justify" class="paragraph-source">     В следующем примере предложение NULL помогает удовлетворить тому требованию языка, что выполнимая часть подпрограммы должна содержать хотя бы одно предложение: </p><p align="left" class="paragraph-source">PROCEDURE ycenka (goods_id_ INTEGER, price_ REAL) IS <br />BEGIN <br />NULL; <br />END ycenka; </p></div></div></td></tr></table></td></tr><tr><td id="bottomOuter"><table id="bottomInner"><tr><td class="cell1"><div> </div></td><td class="cell2"><div>© 2012 ХНУРЭ, ПИ, Широкопетлева М.С., <a href="mailto:mshirokopetleva@gmail.com">mshirokopetleva@gmail.com</a>;   ХНУРЭ, ПИ, Черепанова Ю.Ю.;   ХНУРЭ, ПИ, Мазурова О.А.<br /><a href="http://lersus.de/" title="Данный курс создан с помощью авторской системы LERSUS" target="_blank">Разработано с помощью LERSUS</a></div></td></tr></table></td></tr></table></body></html>