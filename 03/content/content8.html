<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="LERSUS 3.3.0.0" /><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Корпоративные информационные системы — Теория — Параметры подпрограмм</title><script language="javascript" type="text/javascript" src="../../00/styles/files/apiwrapper.js"> </script><script language="javascript" type="text/javascript" src="../../00/styles/files/sco.js"> </script><link href="../../00/styles/files/style.css" rel="stylesheet" type="text/css" /></head><body><table id="mainOuter"><tr><td id="topOuter"><table id="topInner"><tr class="row1"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4" id="shortcuts"><div><ul class="level0"><li><a href="../../00/content/authors1.html">Авторы</a></li><li>|</li><li><a href="../../00/content/contacts1.html">Контакты</a></li><li>|</li><li><a href="../../00/content/instructions1.html">Методические указания</a></li><li>|</li><li><a href="../../00/content/annotation1.html">Аннотация</a></li><li>|</li><li><a href="#" onclick="history.back(); return false;">Назад</a></li></ul></div></td></tr><tr class="row2"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4"><div id="courseTitle">Корпоративные информационные системы</div><div id="courseSubTitle">Языки запросов к базам данных : Параметры подпрограмм</div></td></tr></table></td></tr><tr><td id="contentOuter"><table id="contentInner"><tr><td class="menuOuter"><table class="menuInner"><tr><td><ul class="level0"><li><a href="../../00/styles/courses.html">Содержание курса</a></li><li><span>Теория</span></li><ul class="level1"><li><a href="../../03/content/content1.html">Оптимизация запросов</a></li><li><a href="../../03/content/content2.html">Окружение 4-го поколения</a></li><li><a href="../../03/content/content3.html">Язык PL / SQL. Общие положения </a></li><li><a href="../../03/content/content4.html">Переменные и константы. Кодовое множество</a></li><li><a href="../../03/content/content5.html">Типы данных</a></li><li><a href="../../03/content/content6.html">Команды управления</a></li><li><a href="../../03/content/content7.html">Создание хранимых процедур и функций </a></li><li><a href="../../03/content/content8.html">Параметры подпрограмм</a></li><li><a href="../../03/content/content9.html">Встроенные функции PL / SQL</a></li><li><a href="../../03/content/content10.html">Курсоры</a></li><li><a href="../../03/content/content11.html">Исключительные ситуации</a></li><li><a href="../../03/content/content12.html">Обработчики исключений </a></li><li><a href="../../03/content/content13.html">Пакеты</a></li><li><a href="../../03/content/content14.html">Триггеры объектов </a></li></ul><li><span>Практика</span></li><ul class="level1"><li><a href="../../03/content/example1.html">Практика 2. Использование подпрограмм в языках  программирования 4-го поколения</a></li><li><a href="../../03/content/example2.html">Лабораторная работа 2 Подпрограммы как средство создания серверных частей информационных систем на примере СУБД Oracle </a></li><li><a href="../../03/content/example3.html">Практика 3. Создание  и работа с триггерами объектов и событий</a></li><li><a href="../../03/content/example4.html">Лабораторная работа 3. Триггеры объектов и событий базы данных </a></li></ul><li><span>Текущий контроль знаний</span></li><ul class="level1"><li><a href="../../03/content/multiply-choice-test25.html">Управляющие структуры</a></li><li><a href="../../03/content/multiply-answers-test7.html">Подпрограммы языка PL/SQL</a></li><li><a href="../../03/content/multiply-choice-test1.html">Курсоры</a></li><li><a href="../../03/content/multiply-answers-test12.html">Исключительные ситуации</a></li><li><a href="../../03/content/multiply-choice-test19.html">Пакеты</a></li><li><a href="../../03/content/multiply-answers-test3.html">Триггеры</a></li></ul><li><a href="../../03/styles/glossary.html">Словарь терминов</a></li><li><a href="../../03/03.pdf" target="_blank">Версия для печати</a></li></ul></td></tr></table></td><td class="content"><div id="content"><div id="topBlankStripe"> </div><span id="lnkc1016de48b814139a4a4aabde1534427"> </span><h1 align="left" class="headline-source">     Параметры подпрограмм</h1><span id="lnk6e2e2478bf9f4b46aadfe53a323ccd7f"> </span><h2 align="left" class="paragraph-headline-source">     Фактические и формальные параметры </h2><span id="lnk39e4bc9e246745f48b4bc7d0fadb8c31"> </span><div class="section"><p align="justify" class="paragraph-source">     Подпрограммы принимают и передают информацию через ПАРАМЕТРЫ. Переменные или выражения, которые специфицированы в списке параметров в вызове подпрограммы, называются ФАКТИЧЕСКИМИ параметрами. </p><p align="justify" class="paragraph-source">     Например, следующий вызов функции передает два фактических параметра, new _ goods _ id и need _ quantity : </p><p align="left" class="paragraph-source">done := quantity_ok (new_goods_id, need_quantity); </p><p align="justify" class="paragraph-source">     Как показывает следующий вызов функции, в некоторых случаях в качестве фактических параметров можно использовать выражения: </p><p align="left" class="paragraph-source">done := quantity_ok (new_goods_id, quan_1+ quan_2); </p></div><span id="lnkec0ea46c000042b19bbcf92d25a72c86"> </span><div class="section"><p align="justify" class="paragraph-source">     Переменные, объявленные в спецификации подпрограммы и используемые в теле подпрограммы, называются ФОРМАЛЬНЫМИ параметрами. </p><p align="justify" class="paragraph-source">     Например, следующая процедура объявляет два формальных параметра с именами goods _ id 1 и price 1: </p><p align="left" class="paragraph-source">PROCEDURE change_price (goods_id1 NUMBER, price1 NUMBER) IS <br />BEGIN <br />UPDATE goods SET price = price1 WHERE goods_id = goods_id1; <br />END change_price; </p><p align="left" class="paragraph-source">     Вызов процедуры показан на рисунке 8.</p><p align="left" class="paragraph-source">     </p></div><span id="lnkf69ff2c3895d4824801586f1fd599bed"> </span><div class="section"><p align="center" class="paragraph-source"><img src="../res/files/jpg190_0__0_.jpeg" height="355px" width="453px" alt="" /> </p><p align="center" class="paragraph-source">Рисунок 8 - Пример создания и вызова процедуры в утилите SQL * Plus </p><p align="center" class="paragraph-source">     </p></div><span id="lnk23af44366c5140cc8c54bdf189826365"> </span><div class="section"><p align="justify" class="paragraph-source">     Хотя это и не обязательно, хорошая практика программирования рекомендует использовать разные имена для фактических и формальных параметров. Когда вы вызываете процедуру change _ price , фактические параметры вычисляются, и их значения присваиваются соответствующим формальным параметрам. При этом PL/SQL преобразует значение из одного типа данных в другой, если необходимо. </p><p align="justify" class="paragraph-source">     Например, следующий вызов процедуры change _ price законен: </p><p align="left" class="paragraph-source">change_price (change_goods, 2500); </p><p align="justify" class="paragraph-source">     Фактический параметр и соответствующий ему формальный параметр должны иметь совместимые типы данных. Например, PL/SQL не может преобразовать друг в друга типы данных DATE и REAL. Кроме того, значение результата также должно быть совместимо с новым типом данных. Следующий вызов процедуры возбудит предопределенное исключение VALUE_ERROR, потому что PL/SQL не может преобразовать второй фактический параметр в число: </p><p align="left" class="paragraph-source">change _ price ( change _ goods , $2500'); -- из-за использования строкового значения </p></div><span id="lnk8c02b27b4c394ae6933154415788cfaa"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Позиционная и именная нотация </b></p></div><span id="lnk45d276bd952f48eaa14381c1caefb49e"> </span><div class="section"><p align="justify" class="paragraph-source">     При вызове подпрограммы можно записывать фактические параметры, используя позиционную или именную нотацию. Иными словами, вы можете указывать соответствие между фактическими и формальными параметрами через позиции этих параметров или через их имена. </p><p align="left" class="paragraph-source">     Например, при объявлениях </p><p align="left" class="paragraph-source">DECLARE <br />change_goods NUMBER(4); <br />new_price NUMBER(8,2); <br />PROCEDURE change_price (goods_id1 NUMBER, price1 NUMBER) IS ... </p><p align="left" class="paragraph-source">     Вы можете вызвать процедуру change _ price четырьмя логически эквивалентными способами: </p><p align="left" class="paragraph-source">BEGIN <br />change_price(change_goods, new_price); -- позиционная нотация <br />change_price(change_goods=&gt; goods_id1, new_price=&gt; price1); -- именная нотация <br />change_price(new_price=&gt; price1, change_goods=&gt; goods_id1); -- именная нотация <br />change_price(change_goods, new_price=&gt; price1); -- смешанная нотация <br />... <br />END; </p><p align="justify" class="paragraph-source">     Первый вызов процедуры использует позиционную нотацию. Компилятор PL/SQL ассоциирует первый фактический параметр, change _ goods , с первым формальным параметром, goods _ id 1, а второй фактический параметр, new _ price , - со вторым формальным параметром, price 1. </p><p align="justify" class="paragraph-source">     Второй вызов процедуры использует именную нотацию. Стрелка ассоциирует формальный параметр слева от стрелки с фактическим параметром справа от стрелки. </p><p align="justify" class="paragraph-source">     Третий вызов процедуры также использует именную нотацию и показывает, что вы можете задавать пары параметров в любом порядке. Поэтому вы не обязаны знать порядок, в котором перечислены формальные параметры. </p><p align="justify" class="paragraph-source">     Четвертый вызов процедуры показывает, что вы можете смешивать позиционную и именную нотации. В данном случае первый параметр задан в позиционной, а второй - в именной нотации. Позиционная нотация в этом варианте должна предшествовать именной. Обратное не допускается. Например, следующий вызов процедуры незаконен: </p><p align="left" class="paragraph-source">change_price(new_price=&gt; price1, change_goods); -- незаконно </p></div><span id="lnk71c0fd7dbf0b473f9e1c82d689e214ca"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Моды параметров </b></p></div><span id="lnk502bd3c2061b43f49c711c5d10410df5"> </span><div class="section"><p align="justify" class="paragraph-source">     Вы используете моды параметров, чтобы определить поведение формальных параметров подпрограммы. Все три возможные моды: IN (умалчиваемая), OUT и IN OUT, могут использоваться в любой процедуре. Что касается функций, то избегайте использования моды OUT или IN OUT в функциях. Назначение функции - принять нуль или более аргументов и возвратить единственное значение. Возврат функцией нескольких результирующих значений является плохой практикой программирования. Кроме того, функции должны быть свободны от ПОБОЧНЫХ ЭФФЕКТОВ, то есть не должны изменять значений переменных, не локальных для данной функции. </p></div><span id="lnk91ab3ee0ac8d4af289feab99ccde5ebc"> </span><div class="section"><p align="left" class="paragraph-source">     <b>IN </b></p></div><span id="lnk6d113a667a604a7da4f9c8a346b068d3"> </span><div class="section"><p align="justify" class="paragraph-source">     Параметр с модой IN передает значение вызываемой подпрограмме. Внутри подпрограммы такой параметр выступает как константа. Поэтому ему нельзя присвоить значение. Например , следующее предложение присваивания вызовет ошибку компиляции : </p><p align="left" class="paragraph-source">PROCEDURE insert_storage (ware_id1 IN NUMBER, goods_id1 IN NUMBER, quantity1 IN NUMBER) IS <br />Storage_id1 NUMBER(4); <br />Volume_goods NUMBER(6,2); <br />Volume_goods_sum NUMBER(6,2); <br />Volume_ware NUMBER(6,2); <br />Over_goods NUMBER(6,2); <br />BEGIN <br />SELECT volume INTO Volume_goods FROM goods WHERE goods_id= goods_id1; <br />Volume_goods_sum:= Volume_goods*quantity1; <br />SELECT volume_rest INTO Volume_ware FROM warehouses WHERE ware_id= ware_id1; <br />IF (Volume_ware&lt; Volume_goods_sum) THEN <br />Over_goods:=(Volume_goods_sum-Volume_ware)/Volume_goods; <br />quantity1:= quantity1- Over_goods; -- незаконно <br />END IF; <br />INSERT INTO storages VALUES (stor_seq.nextval, ware_id1, goods_id1, quantity1, SYSDATE, NULL); <br />UPDATE Warehouses SET Volume_rest= Volume_rest- Volume_goods_sum WHERE <br />ware_id= ware_id1; <br />END insert_storage; </p><p align="justify" class="paragraph-source">     Фактический параметр, соответствующий формальному параметру с модой IN, может быть константой, литералом, инициализированной переменной или выражением. В отличие от параметров OUT и IN OUT, параметры IN могут инициализироваться умалчиваемыми значениями. </p></div><span id="lnk1bb7135402f54359aebcf22adaf8be55"> </span><div class="section"><p align="left" class="paragraph-source">     <b>OUT </b></p></div><span id="lnk8487aa17023c4c7799ade71a83fc25ac"> </span><div class="section"><p align="justify" class="paragraph-source">     Параметр с модой OUT позволяет возвращать значение вызывающей программе. Внутри подпрограммы такой параметр выступает как неинициализированная переменная. Поэтому его значение нельзя присваивать другим переменным или переприсвоить самому себе. Например, следующее определив параметр quantity 1 с модой OUT мы получим неверное его использование в следующих местах: </p><p align="left" class="paragraph-source">PROCEDURE insert_storage (ware_id1 IN NUMBER, goods_id1 IN NUMBER, quantity1 OUT NUMBER) IS <br />… <br />BEGIN <br />SELECT volume INTO Volume_goods FROM goods WHERE goods_id= goods_id1; <br />Volume_goods_sum:= Volume_goods*quantity1; -- незаконно <br />… <br />quantity1:= quantity1- Over_goods; -- незаконно <br />… <br /></p><p align="left" class="paragraph-source">END insert _ storage ; </p><p align="justify" class="paragraph-source">     Фактический параметр, соответствующий формальному параметру с модой OUT, должен быть переменной; он не может быть константой или выражением. Например, следующий вызов процедуры незаконен: </p><p align="left" class="paragraph-source">insert_storage (15, 34, quan1+ quan2); -- синтаксическая ошибка </p><p align="justify" class="paragraph-source">     PL/SQL проверяет на такие синтаксические ошибки во время компиляции, не допуская возможного перекрытия констант и выражений. Формальный параметр OUT может (но не обязан) иметь значение в момент вызова подпрограммы. Однако это значение теряется, когда вы вызываете подпрограмму. Внутри подпрограммы формальный параметр OUT нельзя использовать в выражении; единственная операция, допустимая на таком параметре - это присваивание ему значения. Перед выходом из подпрограммы не забывайте явно присвоить значения параметрам OUT. В противном случае значения соответствующих фактических параметров будут не определены. При успешном выходе из подпрограммы PL/SQL присваивает значения фактическим параметрам. Однако, если вы выходите с необработанным исключением, PL/SQL НЕ присваивает значений фактическим параметрам. </p></div><span id="lnk5e3c41a3db984b8e8580788ef568f3ae"> </span><div class="section"><p align="left" class="paragraph-source">     <b>IN OUT </b></p></div><span id="lnkfeae448c4f78406ea2512e8ab470f5cc"> </span><div class="section"><p align="justify" class="paragraph-source">     Параметр IN OUT позволяет вам передавать в подпрограмму начальные значения и возвращать обновленные значения вызывающей программе. Внутри подпрограммы такой параметр выступает как инициализированная переменная. Поэтому ему можно присвоить значение, а его значение можно присваивать другим переменным. Иными словами, параметр IN OUT можно рассматривать как обычную переменную. Вы можете изменять его значение или обращаться к этому значению любыми способами, как показывает следующий пример с переписанной процедурой insert _ storage : </p><p align="left" class="paragraph-source">PROCEDURE insert_storage (ware_id1 IN NUMBER, goods_id1 IN NUMBER, quantity1 IN OUT NUMBER) IS <br />Storage_id1 NUMBER(4); <br />Volume_goods NUMBER(6,2); <br />Volume_goods_sum NUMBER(6,2); <br />Volume_ware NUMBER(6,2); <br />Over_goods NUMBER(6,2); <br />BEGIN <br />SELECT volume INTO Volume_goods FROM goods WHERE goods_id= goods_id1; <br />Volume_goods_sum:= Volume_goods*quantity1; <br />SELECT volume_rest INTO Volume_ware FROM warehouses WHERE ware_id= ware_id1; <br />IF (Volume_ware&lt; Volume_goods_sum) THEN <br />Over_goods:=(Volume_goods_sum-Volume_ware)/Volume_goods; <br />quantity1:= quantity1- Over_goods; <br />END IF; <br />INSERT INTO storages VALUES (stor_seq.nextval, ware_id1, goods_id1, quantity1, SYSDATE, NULL); <br />UPDATE Warehouses SET Volume_rest= Volume_rest- Volume_goods_sum WHERE <br />ware_id= ware_id1; <br />quantity1:=Over_goods; <br />COMMIT; <br />END insert_storage; </p><p align="justify" class="paragraph-source">     Теперь процедура получает номер склада, куда нужно определить товар, номер товара и его количество. Используя информацию о свободном объеме склада и подсчитав объем, необходимый для хранения товара, процедура определяет остаток товара, который необходимо поместить на другой склад. Информацию об остатке процедура возвращает через переменную quantity 1. </p><p align="justify" class="paragraph-source">     Фактический параметр, соответствующий формальному параметру IN OUT, должен быть переменной; он не может быть константой или выражением. </p></div><span id="lnk06ffc3c964b645f0b699e6a4d5a6e3ea"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Умалчиваемые значения параметров </b></p></div><span id="lnkc6fcf7d37ff4430eb564297219a35b67"> </span><div class="section"><p align="justify" class="paragraph-source">     Как показывает следующий пример, вы можете инициализировать параметры с модой IN умалчиваемыми значениями. Это позволяет передавать подпрограмме различное число параметров, принимая или перекрывая умалчиваемые значения по вашему желанию. Более того, можно добавлять новые формальные параметры, не требуя каждый раз изменять все существующие вызовы данной подпрограммы. </p><p align="left" class="paragraph-source">PROCEDURE insert_ware (new_address VARCHAR2 DEFAULT 'KHARKOV', <br />new_volume NUMBER DEFAULT 1000, <br />new_volume_rest NUMBER DEFAULT 1000, <br />new_storage_have VARCHAR2 DEFAULT HANGAR') IS <br />BEGIN <br />IF (new_volume&lt;&gt;1000) THEN <br />INSERT INTO warehouses VALUES (ware_seq.NEXTVAL, new_address, new_volume, new_volume, new_storage_have); <br />ELSE <br />INSERT INTO warehouses VALUES (ware_seq.NEXTVAL, new_address, new_volume, new_volume_rest, new_storage_have); <br />END IF; <br />END insert_ware; </p><p align="left" class="paragraph-source">     Если фактический параметр не передан, используется умалчиваемое значение соответствующего формального параметра. </p><p align="left" class="paragraph-source">     Рассмотрим следующие вызовы процедуры insert _ ware : </p><p align="left" class="paragraph-source">BEGIN <br />... <br />insert_ware; <br />insert_ware ('KIEV'); <br />insert_ware ('KIEV', 2000); <br />... <br />END; </p><p align="justify" class="paragraph-source">     Первый вызов не передает никаких фактических параметров, так что используются все умолчания. Второй вызов передает один фактический параметр, так что умолчание используется для new _ volume , new _ volume _ rest , new _ storage _ have (т.е. мы создаем новый стандартный склад в Киеве). Третий вызов передает 2 параметра, так что умалчиваемые значения используется для new _ volume _ rest и new _ storage _ have . В большинстве случаев вы можете использовать позиционную нотацию для перекрытия умалчиваемых значений формальных параметров. Однако вы не можете пропустить формальный параметр, опустив для него соответствующий фактический параметр. </p><p align="justify" class="paragraph-source">     Например, следующий вызов логически некорректен, так как он ассоциирует фактический параметр ' refregirator ' с формальным параметром new _ volume _ rest , а не с формальным параметром new _ storage _ have : </p><p align="left" class="paragraph-source">insert_ware ('KIEV', 2000, 'refregirator');-- некорректно </p><p align="justify" class="paragraph-source">     Нельзя обойти эту проблему, указав запятую вместо отсутствующего позиционного параметра. Например, следующий вызов незаконен: </p><p align="left" class="paragraph-source">insert _ ware (' KIEV ', 2000, , ' refregirator '); -- синтаксическая ошибка </p><p align="justify" class="paragraph-source">     В таких случаях вы должны использовать именную нотацию, например: </p><p align="left" class="paragraph-source">insert _ ware (' KIEV ', 2000, new _ storage _ have =&gt;' refregirator '); </p><p align="left" class="paragraph-source">     Не забывайте, что позиционную нотацию нельзя применять после именной. </p></div><span id="lnke35859b5f4f7404c9212140bb93d5ac9"> </span><h2 align="left" class="paragraph-headline-source">     Перекрытие имен</h2><span id="lnk9a8106b9550e4779ba464a72f4f1014a"> </span><div class="section"><p align="justify" class="paragraph-source">     PL/SQL позволяет вам ПЕРЕКРЫВАТЬ имена подпрограмм. Иными словами, вы можете использовать одно и то же имя для нескольких различных подпрограмм, если только их формальные параметры различаются по количеству, порядку или семействам типов данных. </p><p align="justify" class="paragraph-source">     Перекрывающиеся имена подпрограмм могут появляться только в блоке, подпрограмме или пакете. Иными словами, нельзя перекрывать имен независимых подпрограмм. Нельзя перекрывать две подпрограммы, если их формальные параметры различаются лишь именами или модами параметров. Например , следующее перекрытие незаконно : </p><p align="left" class="paragraph-source">PROCEDURE delete_my (goods_id1 IN NUMBER) IS BEGIN ... END delete_my; <br />PROCEDURE delete_my (ware_id1 IN NUMBER) IS BEGIN ... END delete_my; </p><p align="justify" class="paragraph-source">     Более того, нельзя перекрывать две подпрограммы, если их формальные параметры различаются лишь типами данных, причем эти типы данных относятся к одному и тому же семейству. Например, следующее перекрытие незаконно, потому что типы данных INTEGER и NUMBER входят в одно и то же семейство: </p><p align="left" class="paragraph-source">PROCEDURE delete_my (goods_id1 IN NUMBER) IS <br />BEGIN <br />... <br />END delete_my; <br />PROCEDURE delete_my (ware_id1 IN INTEGER) IS <br />BEGIN <br />... <br />END delete_my; </p><p align="justify" class="paragraph-source">     Наконец, нельзя перекрывать две функции, если они различаются лишь типами данных результирующего значения, даже если эти типы данных относятся к разным семействам. Например, следующее перекрытие незаконно: </p><p align="left" class="paragraph-source">FUNCTION count_my (goods_id1 NUMBER) RETURN BOOLEAN IS <br />BEGIN <br />... <br />END count_my; <br />FUNCTION count_my (goods_id1 NUMBER) RETURN NUMBER IS <br />BEGIN <br />... <br />END count_my; </p></div><span id="lnke47a5ca6e1284f7e8dcaf98b35ea7e97"> </span><h2 align="left" class="paragraph-headline-source">     Рекурсия</h2><span id="lnk1d25fb4870af40c19bd0fc08ddead6c7"> </span><div class="section"><p align="justify" class="paragraph-source">     Рекурсия является мощным способом упрощения разработки алгоритмов. По существу, РЕКУРСИЯ означает обращение к самому себе. В рекурсивной математической последовательности каждый член выводится путем применения формулы к предыдущим членам. </p><p align="justify" class="paragraph-source">     Рассматривайте рекурсивный вызов как вызов некоторой другой подпрограммы, которая выполняет ту же задачу, что и ваша подпрограмма. Каждый рекурсивный вызов создает новые экземпляры всех объектов, объявленных в подпрограмме, включая параметры, переменные, курсоры и исключения. Аналогично, на каждом уровне рекурсивного спуска создаются новые экземпляры предложений SQL. </p><p align="justify" class="paragraph-source">     В рекурсивной подпрограмме должно быть по меньшей мере два пути логики: тот, который ведет к рекурсивному вызову, и тот, который не ведет к такому вызову. Иными словами, хотя бы один путь должен приводить к УСЛОВИЮ ЗАВЕРШЕНИЯ. В противном случае рекурсия (теоретически) продолжалась бы бесконечно. На практике, если рекурсивная подпрограмма начинает бесконечно вызывать саму себя, PL/SQL в конце концов переполняет свою память и возбуждает предопределенное исключение STORAGE_ERROR. </p><p align="justify" class="paragraph-source">     При решении некоторых задач программирования вы должны повторять последовательность предложений, пока не будет выполнено некоторое условие. Для этого можно использовать либо итерацию, либо рекурсию. Рекурсия применима там, где задача может быть разбита на более простые версии этой же задачи. Например, вы можете вычислить 3! следующим способом: 0! = 1 1! = 1 * 0! = 1 * 1 = 1 2! = 2 * 1! = 2 * 1 = 2 3! = 3 * 2! = 3 * 2 = 6 </p><p align="justify" class="paragraph-source">     Чтобы реализовать этот алгоритм, вы могли бы написать следующую рекурсивную функцию, которая вычисляет факториал положительного целого числа: </p><p align="left" class="paragraph-source">FUNCTION fac (n POSITIVE) RETURN INTEGER IS -- возвращает n! <br />BEGIN <br />IF n = 1 THEN -- условие завершения <br />RETURN 1; <br />ELSE RETURN n * fac(n - 1); -- рекурсивный вызов <br />END IF; <br />END fac; </p><p align="left" class="paragraph-source"></p><p align="left" class="paragraph-source">     Вызов функции показн на рисунке 9.</p><p align="left" class="paragraph-source">     </p></div><span id="lnk435108189f2e47f9b97107e406130f10"> </span><div class="section"><p align="center" class="paragraph-source"><img src="../res/files/jpg1ba_0__0_.jpeg" height="267px" width="463px" alt="" /> </p><p align="center" class="paragraph-source">Рисунок 9 - Пример создания и вызова функции из утилиты SQL * Plus </p><p align="center" class="paragraph-source">     </p></div><span id="lnkdde8afbc9ad743829b71bbf9dfff3235"> </span><div class="section"><p align="justify" class="paragraph-source">     При каждом рекурсивном вызове n уменьшается. В конце концов, n станет равным 1, и рекурсия остановится. </p><p align="justify" class="paragraph-source">     Будьте внимательны в выборе места, в которое вы помещаете рекурсивный вызов. Если вы помещаете его в курсорный цикл FOR или между предложениями OPEN и CLOSE, то при каждом вызове открывается очередной курсор. Как следствие, ваша программа может превысить лимит, устанавливаемый параметром инициализации ORACLE OPEN_CURSORS. </p><p align="justify" class="paragraph-source">     В отличие от итерации, рекурсия не является существенной для программирования на PL/SQL. Любая проблема, которая может быть решена рекурсией, может быть решена и итерацией. Концепцию итерации легче усвоить, поскольку примеры рекурсии не столь часты в повседневной жизни. Как следствие, итеративную версию подпрограммы обычно легче спроектировать, чем рекурсивную версию той же программы. Однако рекурсивная версия обычно проще, меньше, и потому ее легче отладить. </p></div></div></td></tr></table></td></tr><tr><td id="bottomOuter"><table id="bottomInner"><tr><td class="cell1"><div> </div></td><td class="cell2"><div>© 2012 ХНУРЭ, ПИ, Широкопетлева М.С., <a href="mailto:mshirokopetleva@gmail.com">mshirokopetleva@gmail.com</a>;   ХНУРЭ, ПИ, Черепанова Ю.Ю.;   ХНУРЭ, ПИ, Мазурова О.А.<br /><a href="http://lersus.de/" title="Данный курс создан с помощью авторской системы LERSUS" target="_blank">Разработано с помощью LERSUS</a></div></td></tr></table></td></tr></table></body></html>