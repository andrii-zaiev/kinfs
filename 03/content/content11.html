<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="LERSUS 3.3.0.0" /><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Корпоративные информационные системы — Теория — Исключительные ситуации</title><script language="javascript" type="text/javascript" src="../../00/styles/files/apiwrapper.js"> </script><script language="javascript" type="text/javascript" src="../../00/styles/files/sco.js"> </script><link href="../../00/styles/files/style.css" rel="stylesheet" type="text/css" /></head><body><table id="mainOuter"><tr><td id="topOuter"><table id="topInner"><tr class="row1"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4" id="shortcuts"><div><ul class="level0"><li><a href="../../00/content/authors1.html">Авторы</a></li><li>|</li><li><a href="../../00/content/contacts1.html">Контакты</a></li><li>|</li><li><a href="../../00/content/instructions1.html">Методические указания</a></li><li>|</li><li><a href="../../00/content/annotation1.html">Аннотация</a></li><li>|</li><li><a href="#" onclick="history.back(); return false;">Назад</a></li></ul></div></td></tr><tr class="row2"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4"><div id="courseTitle">Корпоративные информационные системы</div><div id="courseSubTitle">Языки запросов к базам данных : Исключительные ситуации</div></td></tr></table></td></tr><tr><td id="contentOuter"><table id="contentInner"><tr><td class="menuOuter"><table class="menuInner"><tr><td><ul class="level0"><li><a href="../../00/styles/courses.html">Содержание курса</a></li><li><span>Теория</span></li><ul class="level1"><li><a href="../../03/content/content1.html">Оптимизация запросов</a></li><li><a href="../../03/content/content2.html">Окружение 4-го поколения</a></li><li><a href="../../03/content/content3.html">Язык PL / SQL. Общие положения </a></li><li><a href="../../03/content/content4.html">Переменные и константы. Кодовое множество</a></li><li><a href="../../03/content/content5.html">Типы данных</a></li><li><a href="../../03/content/content6.html">Команды управления</a></li><li><a href="../../03/content/content7.html">Создание хранимых процедур и функций </a></li><li><a href="../../03/content/content8.html">Параметры подпрограмм</a></li><li><a href="../../03/content/content9.html">Встроенные функции PL / SQL</a></li><li><a href="../../03/content/content10.html">Курсоры</a></li><li><a href="../../03/content/content11.html">Исключительные ситуации</a></li><li><a href="../../03/content/content12.html">Обработчики исключений </a></li><li><a href="../../03/content/content13.html">Пакеты</a></li><li><a href="../../03/content/content14.html">Триггеры объектов </a></li></ul><li><span>Практика</span></li><ul class="level1"><li><a href="../../03/content/example1.html">Практика 2. Использование подпрограмм в языках  программирования 4-го поколения</a></li><li><a href="../../03/content/example2.html">Лабораторная работа 2 Подпрограммы как средство создания серверных частей информационных систем на примере СУБД Oracle </a></li><li><a href="../../03/content/example3.html">Практика 3. Создание  и работа с триггерами объектов и событий</a></li><li><a href="../../03/content/example4.html">Лабораторная работа 3. Триггеры объектов и событий базы данных </a></li></ul><li><span>Текущий контроль знаний</span></li><ul class="level1"><li><a href="../../03/content/multiply-choice-test25.html">Управляющие структуры</a></li><li><a href="../../03/content/multiply-answers-test7.html">Подпрограммы языка PL/SQL</a></li><li><a href="../../03/content/multiply-choice-test1.html">Курсоры</a></li><li><a href="../../03/content/multiply-answers-test12.html">Исключительные ситуации</a></li><li><a href="../../03/content/multiply-choice-test19.html">Пакеты</a></li><li><a href="../../03/content/multiply-answers-test3.html">Триггеры</a></li></ul><li><a href="../../03/styles/glossary.html">Словарь терминов</a></li><li><a href="../../03/03.pdf" target="_blank">Версия для печати</a></li></ul></td></tr></table></td><td class="content"><div id="content"><div id="topBlankStripe"> </div><span id="lnk3be635f54fce4b7c99d29d6a0e9005e6"> </span><h1 align="left" class="headline-source">     Исключительные ситуации</h1><span id="lnkba8561b0706042778527aa2f45ac01e9"> </span><div class="section"><p align="justify" class="paragraph-source">     В PL/SQL условие ошибки называется «исключением». Исключения могут быть внутренне определены (исполнителем PL/SQL) или определены пользователем. В общем ситуация с исключительными ситуациями следующая: </p><p align="justify" class="paragraph-source">     - некоторые общие внутренне определенные исключения имеют предопределенные имена, такие как ZERO_DIVIDE и STORAGE_ERROR; </p><p align="justify" class="paragraph-source">     - другим внутренне определенным исключениям имена могут быть присвоены; </p><p align="justify" class="paragraph-source">     - вы можете определить ваши собственные исключения в декларативной части любого блока, подпрограммы или пакета PL/SQL. Например, вы можете определить исключение с именем Not_successful_storage для обработки приема на хранение партии товара, которая не может быть целиком помещена на предлагаемый склад. Итак, внутренние исключения имеют имена либо им имена могут быть присвоены. В отличие от внутренних исключений, пользовательские исключения должны иметь имена. </p><p align="justify" class="paragraph-source">     Когда возникает ошибка, соответствующее исключение возбуждается. Это значит, что нормальное выполнение останавливается, и управление передается на часть обработки исключений вашего блока или подпрограммы PL/SQL. </p><p align="justify" class="paragraph-source">     Внутренние исключения возбуждаются неявно (автоматически) системой исполнения; пользовательские исключения возбуждаются явно, посредством предложений RAISE, которые могут также возбуждать предопределенные исключения. </p><p align="justify" class="paragraph-source">     Для обработки возбуждаемых исключений вы пишете отдельные программы, называемые обработчиками исключений. После выполнения обработчика исключений исполнение текущего блока заканчивается, и окружающий блок продолжает свое выполнение со следующего предложения. Если окружающего блока нет (т.е. текущий блок не вложен в другой блок), то управление возвращается в хост-окружение. </p></div><span id="lnk72f9dfba48a1407e9394596241fcdddb"> </span><h2 align="left" class="paragraph-headline-source">     Предопределенные исключения </h2><span id="lnk4986052bca7b4cb59efb468baa5ff2b2"> </span><div class="section"><p align="justify" class="paragraph-source">     Внутреннее исключение возбуждается неявно всякий раз, когда ваша программа PL/SQL нарушает правило ORACLE или превышает установленный системой лимит. Каждая ошибка ORACLE имеет номер, однако исключения должны обрабатываться по их именам. Поэтому PL/SQL внутренне определяет некоторые распространенные ошибки ORACLE как исключения. Например, предопределенное исключение NO_DATA_FOUND возбуждается, когда предложение SELECT INTO не возвращает ни одной строки. </p><p align="justify" class="paragraph-source">     PL/SQL объявляет предопределенные исключения глобально, в пакете STANDARD, который определяет окружение PL/SQL. Поэтому вы не обязаны объявлять их сами. Вы можете писать обработчики для предопределенных исключений, используя имена, приведенные в таблице 6. Эта таблица показывает также  и значения возврата функции SQLCODE. </p></div><span id="lnke6e3960c7b1d4f16a4e9bd4bfd82d373"> </span><div align="center"><div class="inline-table-container"><p align="left" class="unit-title">Таблица 6 - Коды ошибок ORACLE</p><table class="inline-table"><col width="188" /><col width="188" /><col width="189" /><tbody><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">Имя исключения  </p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Ошибка ORACLE</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Код SQLCODE</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">CURSOR_ALREADY_OPEN </p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">ORA-06511</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table"> -6511 </p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">DUP_VAL_ON_INDEX   </p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">ORA-00001</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table"> -1</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">INVALID_CURSOR </p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">ORA-01001</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table"> -1001 </p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">INVALID_NUMBER </p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">ORA-01722</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">-1722 </p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">LOGIN_DENIED </p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">ORA-01017</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table"> -1017</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">NO_DATA_FOUND  </p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">ORA-01403</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">-100 </p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">NOT_LOGGED_ON  </p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">ORA-01012</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">-1012 </p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">PROGRAM_ERROR </p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">ORA-06501</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table"> -6501 </p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">STORAGE_ERROR </p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">ORA-06500 </p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">-6500 </p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">TIMEOUT_ON_RESOURCE </p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">ORA-00051 </p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">-51 </p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">TOO_MANY_ROWS </p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">ORA-01422 </p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">-1422 </p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">TRANSACTION_BACKED_OUT </p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">ORA-00061  </p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">-61</p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">ZERO_DIVIDE</p></td><td style="background-color:#ffffff"><p align="left" class="inline-table"> ORA-01476 </p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">-1476 </p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">VALUE_ERROR </p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">ORA-06502 </p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">-6502 </p></td></tr></tbody></table></div></div><span id="lnk768a367138e449cd8f3ae5b3f6d9b4d9"> </span><div class="section"><p align="justify" class="paragraph-source">     Ниже приведены краткие описания предопределенных исключений: </p></div><span id="lnk3c51cad4119e4477a02d62d8f5d8af8a"> </span><div class="section"><p align="left" class="paragraph-source"><b>CURSOR_ALREADY_OPEN </b></p><p align="justify" class="paragraph-source">     Возбуждается при попытке открыть уже открытый курсор. Вы должны закрыть (CLOSE) курсор, прежде чем открывать его повторно. Курсорный цикл FOR автоматически открывает свой курсор. Поэтому вы не можете войти в такой цикл, если данный курсор уже открыт. Нельзя также явно открывать курсор внутри цикла FOR. </p><p align="left" class="paragraph-source"><b>DUP_VAL_ON_INDEX </b></p><p align="justify" class="paragraph-source">     Возбуждается, когда операция INSERT или UPDATE пытается создать повторяющееся значение в столбце, ограниченном опцией UNIQUE. </p><p align="left" class="paragraph-source"><b>INVALID_CURSOR</b> </p><p align="justify" class="paragraph-source">     Возбуждается, когда вызов PL/SQL специфицирует некорректный курсор (например, при попытке закрыть неоткрытый курсор). </p><p align="left" class="paragraph-source"><b>INVALID_NUMBER </b></p><p align="justify" class="paragraph-source">     Возбуждается в предложении SQL, когда преобразование символьной строки в число сбивается из-за того, что строка не содержит правильного представления числа. Например, следующее предложение INSERT возбудит исключение INVALID_NUMBER, когда ORACLE попытается преобразовать 'HALL' в число: </p><p align="left" class="paragraph-source">INSERT INTO emp (empno, ename, deptno) VALUES ('HALL', 7888, 20); </p><p align="justify" class="paragraph-source">     В процедурных предложениях вместо этого исключения возбуждается VALUE_ERROR. </p><p align="left" class="paragraph-source"><b>LOGIN_DENIED </b></p><p align="justify" class="paragraph-source">     Возбуждается при некорректном имени пользователя или пароле при попытке подключения к ORACLE. </p></div><span id="lnk9b07c3767e344b46a99adfda70fe1250"> </span><div class="section"><p align="left" class="paragraph-source"><b>NO_DATA_FOUND </b></p><p align="justify" class="paragraph-source">     Возбуждается, когда предложение SELECT INTO не возвращает ни одной строки, или при обращении к неинициализированной строке таблицы PL/SQL. Групповые функции SQL, такие как AVG или SUM, ВСЕГДА возвращают значение, даже если это значение есть NULL. Поэтому предложение SELECT INTO, вызывающее групповую функцию, никогда не возбудит исключение NO_DATA_FOUND. Поскольку NO_DATA_FOUND возбуждается, когда предложение SELECT INTO не возвращает строк, вы можете проверять значение SQL%NOTFOUND только в обработчике исключений. Однако, значение атрибута имя_курсора%NOTFOUND можно проверять после каждой операции FETCH. От операции FETCH ожидается, что в конце концов она не сможет возвратить очередную строку, так что, когда это происходит, никакого исключения не возбуждается. </p><p align="justify" class="paragraph-source"><b>NOT_LOGGED_ON </b></p><p align="justify" class="paragraph-source">     Возбуждается, когда ваша программа PL/SQL выдает вызов ORACLE, не будучи подключена к ORACLE. </p><p align="left" class="paragraph-source"><b>PROGRAM_ERROR </b></p><p align="justify" class="paragraph-source">     Возбуждается, когда PL/SQL встретился с внутренней проблемой. </p><p align="left" class="paragraph-source"><b>STORAGE_ERROR </b></p><p align="justify" class="paragraph-source">     Возбуждается, когда PL/SQL исчерпал доступную память, или когда память запорчена. </p><p align="left" class="paragraph-source"><b>TIMEOUT_ON_RESOURCE </b></p><p align="left" class="paragraph-source">     Возбуждается при возникновении таймаута, когда ORACLE ожидает ресурса. </p><p align="left" class="paragraph-source"><b>TOO_MANY_ROWS </b></p><p align="left" class="paragraph-source">     Возбуждается, когда предложение SELECT INTO возвращает больше одной строки. </p><p align="justify" class="paragraph-source"><b>TRANSACTION_BACKED_OUT </b></p><p align="justify" class="paragraph-source">     Обычно возбуждается, если удаленная часть транзакции была подвергнута неявному или явному откату. Причиной может быть несогласованность данных ORACLE в каких-нибудь узлах. В таких случаях выдайте ROLLBACK, а затем повторите транзакцию. </p></div><span id="lnk1b7ef1562f7547dd914635626a8a91aa"> </span><div class="section"><p align="left" class="paragraph-source"><b>VALUE_ERROR </b></p><p align="justify" class="paragraph-source">     Возбуждается при возникновении арифметической ошибки, ошибки преобразования, ошибки усечения или ошибки ограничения. Например, VALUE_ERROR возбуждается при усечении строкового значения, присваиваемого переменной PL/SQL. (Однако при усечении строкового значения, присваиваемого хост-переменной, никакого исключения не возбуждается.) В процедурных предложениях VALUE_ERROR возбуждается при ошибке преобразования символьной строки в число. Например, следующее предложение присваивания вызовет RAISE_ERROR, когда PL/SQL попытается преобразовать 'HALL' в числовое значение: </p><p align="left" class="paragraph-source">DECLARE <br />my_volume NUMBER(6,2); <br />my_address VARCHAR2(20); <br />BEGIN <br />my_volume := 'KHARKOV'; <br />... </p><p align="left" class="paragraph-source">     В предложениях SQL в таких случаях возбуждается INVALID_NUMBER. </p><p align="left" class="paragraph-source"><b>ZERO_DIVIDE </b></p><p align="justify" class="paragraph-source">     Возбуждается при попытке деления числа на 0. </p></div><span id="lnkb0459a1648a24165a867886af84c28e5"> </span><h2 align="left" class="paragraph-headline-source">     Пользовательские исключения </h2><span id="lnke4faed3badf3444a8850099aac6259cb"> </span><div class="section"><p align="justify" class="paragraph-source">     Пользовательские исключения PL/SQL позволяют вам определять ваши собственные исключения. В отличие от внутренних исключений, пользовательские исключения должны быть объявлены и должны явно возбуждаться предложениями RAISE. </p><p align="justify" class="paragraph-source">     Вы можете объявлять исключения только в декларативной части блока, подпрограммы или пакета PL/SQL. Вы объявляете исключение, вводя его имя, за которым следует ключевое слово EXCEPTION. </p></div><span id="lnk84faff410118412493c58eeff0ac9912"> </span><table class="note"><tr><td><p align="left" class="note-source">     В примере объявляется исключение с именем not _ type _ storage </p></td><th><img src="../../00/styles/files/note_problem.png" title="Проблемма" alt="Проблемма" /></th></tr></table><span id="lnk070d30f1bc234b1b8934c9cee6c73c46"> </span><div class="section"><p align="left" class="paragraph-source">     </p><p align="left" class="paragraph-source">DECLARE <br />not_type_storage EXCEPTION; <br />num _ stor NUMBER(5); <br />BEGIN <br />... </p><p align="justify" class="paragraph-source">     Объявления исключений выглядят так же, как и объявления переменных. Однако не забывайте, что исключение - это условие ошибки, но не объект. В отличие от переменных, исключениям нельзя присваивать значений, и они не могут использоваться в предложениях SQL. Однако к исключениям применимы те же правила сферы, что и к переменным. </p><p align="justify" class="paragraph-source">     Нельзя объявлять исключение дважды в одном и том же блоке. Однако вы можете объявить то же самое исключение в двух различных блоках. Исключения, объявленные в блоке, считаются локальными в этом блоке и глобальными во всех его подблоках. Поскольку блок может обращаться лишь к локальным или глобальным исключениям, окружающие блоки не могут ссылаться на исключения, объявленные в подблоках. Вы можете переобъявить глобальное исключение в подблоке. В таком случае локальное объявление имеет преимущество, и подблок не может обращаться к глобальному исключению (если только оно не было объявлено в помеченном блоке; в этом случае можно использовать синтаксис метка_блока.имя_исключения). </p></div><span id="lnk57c36f011a224cb4b63ea90e9347f869"> </span><table class="note"><tr><td><p align="left" class="note-source">     Следующий пример иллюстрирует правила сферы для исключений</p></td><th><img src="../../00/styles/files/note_problem.png" title="Проблемма" alt="Проблемма" /></th></tr></table><span id="lnkecc031385f4f4fc09f026fc57160022d"> </span><div class="section"><p align="left" class="paragraph-source">     </p><p align="left" class="paragraph-source">DECLARE <br />not_type_storage EXCEPTION; <br />num_stor NUMBER; <br />BEGIN <br />… -- начало подблока <br />DECLARE <br />not_type_storage EXCEPTION; -- имеет преимущество в подблоке <br />num_stor NUMBER; <br />BEGIN <br />... <br />IF ... THEN RAISE not_type_storage; -- это не обрабатывается <br />END IF; <br />... <br />END; -- конец подблока <br />... <br />EXCEPTION WHEN past_due THEN -- это не относится к исключению, <br />... -- возбуждаемому в подблоке END; </p><p align="justify" class="paragraph-source">     Здесь окружающий блок не обрабатывает исключение, возбуждаемое в подблоке, потому что объявление not _ type _ storage в подблоке имеет преимущество. Два исключения not _ type _ storage , хотя их имена одинаковы, являются разными, точно так же, как различны две объявленные в этом примере переменные num_ stor . Поэтому предложение RAISE в подблоке и фраза WHEN в окружающем блоке относятся к РАЗНЫМ исключениям. Чтобы заставить окружающий блок обрабатывать исключение, вы должны определить в нем обработчик OTHERS, либо удалить объявление исключения из подблока. </p></div><span id="lnk8dfafa1ad48b4f35bec9075a78c32ad0"> </span><div class="section"><p align="justify" class="paragraph-source">     Для обработки непоименованных внутренних исключений вы должны использовать обработчик OTHER либо прагму EXCEPTION_INIT. </p><p align="justify" class="paragraph-source">     ПРАГМА - это директива (указание) компилятору. Прагмы (называемые также псевдоинструкциями) обрабатываются во время компиляции, а не во время выполнения. Они не изменяют смысла программы, а лишь поставляют информацию компилятору. </p><p align="justify" class="paragraph-source">     В PL/SQL, предопределенная прагма EXCEPTION_INIT сообщает компилятору имя исключения, которое вы ассоциируете с конкретным кодом ошибки ORACLE. Это позволяет вам обращаться к любому внутреннему исключению по имени, написав для него специальный обработчик. Вы кодируете прагму EXCEPTION_INIT в декларативной части блока, подпрограммы или пакета PL/SQL, используя следующий синтаксис: </p><p align="left" class="paragraph-source">PRAGMA EXCEPTION_INIT(имя_исключения, код_ошибки_ORACLE); </p><p align="justify" class="paragraph-source">     Здесь имя_исключения - это имя исключения, ранее уже объявленного в этом блоке. </p><p align="justify" class="paragraph-source">     Прагма должна появиться в той же декларативной части, что и соответствующее исключение, как показано в следующем примере: </p><p align="left" class="paragraph-source">DECLARE <br />insufficient_privileges EXCEPTION; <br />PRAGMA EXCEPTION_INIT(insufficient_privileges, -1031); <br />-- ORACLE возвращает код ошибки -1031, если, например, <br />-- вы пытаетесь обновить таблицу, для которой имеете <br />-- лишь полномочия SELECT. <br />BEGIN <br />... <br />EXCEPTION <br />WHEN insufficient_privileges THEN -- обработать ошибку <br />... <br />END; </p></div><span id="lnk87843ffd51114378b8d9fe1783e8c29d"> </span><div class="section"><p align="justify" class="paragraph-source">     Использование исключений для обработки ошибок имеет несколько преимуществ. Не имея таких средств, вы должны были бы проверять на ошибки выполнения при каждом выполнении команды, как показывает следующий пример: </p><p align="left" class="paragraph-source">BEGIN <br />SELECT ... -- проверить на ошибку 'no data found' <br />SELECT ... -- проверить на ошибку 'no data found' <br />SELECT ... -- проверить на ошибку 'no data found' <br />END ; </p><p align="justify" class="paragraph-source">     Обработка ошибок при этом не является ни четко отделенной от нормальной обработки, ни концептуально осмысленной. Если вы пренебрежете проверкой в одном месте, ошибка пройдет необнаруженной и может вызвать другие, внешне не связанные ошибки. </p><p align="justify" class="paragraph-source">     При помощи исключений вы можете обрабатывать ошибки, не кодируя многочисленных проверок, как показывает следующий пример: </p><p align="left" class="paragraph-source">BEGIN <br />SELECT ... <br />SELECT ... <br />SELECT ... <br />EXCEPTION <br />WHEN NO_DATA_FOUND THEN -- этот обработчик перехватывает <br />-- все ошибки 'no data found' <br />END; </p><p align="justify" class="paragraph-source">     Заметьте, как исключения улучшают читабельность, позволяя вам изолировать программы обработки ошибок. Основной алгоритм не затемняется алгоритмами восстановления от ошибок. </p><p align="justify" class="paragraph-source">     Исключения также повышают надежность. Вам нет необходимости беспокоиться о проверке ошибки в любой точке, где она может возникнуть. Просто добавьте соответствующий обработчик исключений в ваш блок PL/SQL. Если данное исключение когда-либо будет возбуждено в этом блоке (или любом его подблоке), у вас есть гарантия, что оно будет обработано. </p></div></div></td></tr></table></td></tr><tr><td id="bottomOuter"><table id="bottomInner"><tr><td class="cell1"><div> </div></td><td class="cell2"><div>© 2012 ХНУРЭ, ПИ, Широкопетлева М.С., <a href="mailto:mshirokopetleva@gmail.com">mshirokopetleva@gmail.com</a>;   ХНУРЭ, ПИ, Черепанова Ю.Ю.;   ХНУРЭ, ПИ, Мазурова О.А.<br /><a href="http://lersus.de/" title="Данный курс создан с помощью авторской системы LERSUS" target="_blank">Разработано с помощью LERSUS</a></div></td></tr></table></td></tr></table></body></html>