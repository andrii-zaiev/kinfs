<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="LERSUS 3.3.0.0" /><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Корпоративные информационные системы — Теория — Переменные и константы. Кодовое множество</title><script language="javascript" type="text/javascript" src="../../00/styles/files/apiwrapper.js"> </script><script language="javascript" type="text/javascript" src="../../00/styles/files/sco.js"> </script><link href="../../00/styles/files/style.css" rel="stylesheet" type="text/css" /></head><body><table id="mainOuter"><tr><td id="topOuter"><table id="topInner"><tr class="row1"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4" id="shortcuts"><div><ul class="level0"><li><a href="../../00/content/authors1.html">Авторы</a></li><li>|</li><li><a href="../../00/content/contacts1.html">Контакты</a></li><li>|</li><li><a href="../../00/content/instructions1.html">Методические указания</a></li><li>|</li><li><a href="../../00/content/annotation1.html">Аннотация</a></li><li>|</li><li><a href="#" onclick="history.back(); return false;">Назад</a></li></ul></div></td></tr><tr class="row2"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4"><div id="courseTitle">Корпоративные информационные системы</div><div id="courseSubTitle">Языки запросов к базам данных : Переменные и константы. Кодовое множество</div></td></tr></table></td></tr><tr><td id="contentOuter"><table id="contentInner"><tr><td class="menuOuter"><table class="menuInner"><tr><td><ul class="level0"><li><a href="../../00/styles/courses.html">Содержание курса</a></li><li><span>Теория</span></li><ul class="level1"><li><a href="../../03/content/content1.html">Оптимизация запросов</a></li><li><a href="../../03/content/content2.html">Окружение 4-го поколения</a></li><li><a href="../../03/content/content3.html">Язык PL / SQL. Общие положения </a></li><li><a href="../../03/content/content4.html">Переменные и константы. Кодовое множество</a></li><li><a href="../../03/content/content5.html">Типы данных</a></li><li><a href="../../03/content/content6.html">Команды управления</a></li><li><a href="../../03/content/content7.html">Создание хранимых процедур и функций </a></li><li><a href="../../03/content/content8.html">Параметры подпрограмм</a></li><li><a href="../../03/content/content9.html">Встроенные функции PL / SQL</a></li><li><a href="../../03/content/content10.html">Курсоры</a></li><li><a href="../../03/content/content11.html">Исключительные ситуации</a></li><li><a href="../../03/content/content12.html">Обработчики исключений </a></li><li><a href="../../03/content/content13.html">Пакеты</a></li><li><a href="../../03/content/content14.html">Триггеры объектов </a></li></ul><li><span>Практика</span></li><ul class="level1"><li><a href="../../03/content/example1.html">Практика 2. Использование подпрограмм в языках  программирования 4-го поколения</a></li><li><a href="../../03/content/example2.html">Лабораторная работа 2 Подпрограммы как средство создания серверных частей информационных систем на примере СУБД Oracle </a></li><li><a href="../../03/content/example3.html">Практика 3. Создание  и работа с триггерами объектов и событий</a></li><li><a href="../../03/content/example4.html">Лабораторная работа 3. Триггеры объектов и событий базы данных </a></li></ul><li><span>Текущий контроль знаний</span></li><ul class="level1"><li><a href="../../03/content/multiply-choice-test25.html">Управляющие структуры</a></li><li><a href="../../03/content/multiply-answers-test7.html">Подпрограммы языка PL/SQL</a></li><li><a href="../../03/content/multiply-choice-test1.html">Курсоры</a></li><li><a href="../../03/content/multiply-answers-test12.html">Исключительные ситуации</a></li><li><a href="../../03/content/multiply-choice-test19.html">Пакеты</a></li><li><a href="../../03/content/multiply-answers-test3.html">Триггеры</a></li></ul><li><a href="../../03/styles/glossary.html">Словарь терминов</a></li><li><a href="../../03/03.pdf" target="_blank">Версия для печати</a></li></ul></td></tr></table></td><td class="content"><div id="content"><div id="topBlankStripe"> </div><span id="lnk626b9d5ef5244b92a50309d8cc2e2d37"> </span><h1 align="left" class="headline-source">     Переменные и константы. Кодовое множество</h1><span id="lnk99955e441adc4183be31c447b12efdaa"> </span><h2 align="left" class="paragraph-headline-source">     Общие положения </h2><span id="lnk24de511e26a444d38f1f4e18d355dd95"> </span><div class="section"><p align="justify" class="paragraph-source">     PL/SQL - это язык, структурированный блоками. Это значит, что основные единицы (процедуры, функции и анонимные блоки), составляющие программу PL/SQL, являются логическими БЛОКАМИ, которые могут содержать любое число вложенных в них подблоков. Обычно каждый логический блок соответствует некоторой проблеме или подпроблеме, которую он решает. </p><p align="justify" class="paragraph-source">     Блок (или подблок) позволяет вам группировать логически связанные объявления и предложения. Благодаря этому вы можете размещать объявления близко к тем местам, где они используются. Объявления локальны в блоке, и перестают существовать, когда блок завершается. </p><p align="justify" class="paragraph-source">     Как показывает рисунок 5, блок PL/SQL имеет три части: декларативную часть, исполняемую часть и часть обработки исключений. (ИСКЛЮЧЕНИЕМ в PL/SQL называется условие, вызывающее предупреждение или ошибку.) Исполняемая часть обязательна; две остальные части блока могут отсутствовать. </p><p align="justify" class="paragraph-source">     </p></div><span id="lnk21cd12762c1745d8b3c3286ad4f29ed9"> </span><div class="section"><p align="center" class="paragraph-source"><img src="../res/files/jpgb8_0__0_.jpeg" height="309px" width="298px" alt="" /> </p><p align="center" class="paragraph-source">Рисунок 5 - Структура блока PL/SQL </p><p align="center" class="paragraph-source">     </p></div><span id="lnk090327589d3a4371994d2a5ae9498de7"> </span><div class="section"><p align="justify" class="paragraph-source">     Порядок частей блока логичен. Блок начинается с декларативной части, в которой объявляются объекты. С объявленными объектами осуществляются манипуляции в исполнительной части. Исключения, возбуждаемые во время исполнения, могут быть обработаны в части обработки исключений. </p><p align="justify" class="paragraph-source">     Каждый блок может содержать другие блоки; иными словами, блоки могут быть вложены друг в друга. Вложенный блок называется подблоком; он вложен в окружающий блок. Вы можете вкладывать блоки в исполнительной части или части обработки исключений блока PL/SQL, но не в декларативной части. Кроме того, вы можете определять локальные подпрограммы в декларативной части любого блока. Однако вызывать локальные подпрограммы можно только из того блока, в котором они определены. </p></div><span id="lnk18bb13b9e4b84502a5f597880302b7d8"> </span><h2 align="left" class="paragraph-headline-source">     Переменные и константы </h2><span id="lnk16b0ac1a9c834c9ab576b6c4aaee913c"> </span><div class="section"><p align="justify" class="paragraph-source">     PL/SQL позволяет вам объявить переменные и константы, а затем использовать их в SQL и процедурных предложениях в любом месте, где допускается использование выражения. Однако ссылки вперед не допускаются. Таким образом, вы должны объявить переменную или константу прежде, чем сможете ссылаться на нее в других предложениях, в том числе в других объявлениях. </p></div><span id="lnk12ea5058ae1c4398b0fbaa9452b15135"> </span><h2 align="left" class="paragraph-headline-source">     Объявления переменных</h2><span id="lnkd86e053a1fad45aa842186b5b37c2b66"> </span><div class="section"><p align="justify" class="paragraph-source">     Ваша программа хранит значения в переменных и константах. Во время выполнения программы значения переменных могут изменяться, а значения констант не могут. </p><p align="justify" class="paragraph-source">     Вы можете объявлять переменные и константы в декларативной части любого блока PL/SQL, подпрограммы или пакета. Объявление распределяет место для значения, специфицирует его тип данных и задает имя, по которому можно обращаться к этому значению. Объявление может также присвоить начальное значение и специфицировать ограничение NOT NULL. </p><p align="left" class="paragraph-source">     Примеры : </p><p align="left" class="paragraph-source">Begin_time DATE; <br />Storage_id SMALLINT := 0; <br />name VARCHAR2(20) NOT NULL := 'picture'; </p><p align="justify" class="paragraph-source">     Первое объявление именует переменную типа DATE. Второе объявление именует переменную типа SMALLINT и использует оператор присваивания (:=), чтобы присвоить этой переменной нулевое начальное значение. Третье объявление именует переменную типа VARCHAR2, специфицирует для нее ограничение NOT NULL и присваивает ей начальное значение 'AP001'. </p><p align="justify" class="paragraph-source">     Нельзя присваивать значения NULL переменным или константам, объявленным как NOT NULL. Если вы попытаетесь это сделать, будет возбуждено предопределенное исключение VALUE_ERROR. За ограничением NOT NULL должна следовать фраза инициализации; в противном случае вы получите ошибку компиляции. </p><p align="justify" class="paragraph-source">     Например, следующее объявление незаконно: </p><p align="justify" class="paragraph-source">name VARCHAR2(20) NOT NULL; -- нет начального значения </p><p align="justify" class="paragraph-source">     Как показывают следующие примеры, инициализирующее выражение может быть сколь угодно сложным и может ссылаться на ранее инициализированные переменные и константы: </p><p align="justify" class="paragraph-source">pi CONSTANT REAL := 3.14159; <br />radius REAL := 1; <br />area REAL := pi * radius**2; </p><p align="justify" class="paragraph-source">     В объявлениях констант зарезервированное слово CONSTANT должно предшествовать спецификатору типа, как показывает следующий пример: </p><p align="justify" class="paragraph-source">Price_max CONSTANT REAL := 5000.00; </p></div><span id="lnkfc48529c53cb43528353e95a75a5badb"> </span><h2 align="left" class="paragraph-headline-source">     Использование DEFAULT</h2><span id="lnk8cb0b774627242d793510594b357c836"> </span><div class="section"><p align="justify" class="paragraph-source">     Если хотите, вы можете использовать зарезервированное слово DEFAULT вместо оператора присваивания, чтобы инициализировать переменную или константу: </p><p align="justify" class="paragraph-source">Storage_id SMALLINT DEFAULT 15; <br />valid BOOLEAN DEFAULT FALSE; </p><p align="justify" class="paragraph-source">     Можно также использовать DEFAULT для инициализации параметров подпрограмм, параметров курсоров и полей в пользовательских записях. </p><p align="justify" class="paragraph-source">     Объявляемая переменная может иметь любой тип данных, присущий SQL, такой как NUMBER, CHAR и DATE, или присущий PL/SQL, такой как BOOLEAN или BINARY _ INTEGER . Например, предположим, что вы хотите объявить переменную с именем num _ var так, чтобы она могла хранить 4-значные числовые значения, и переменную с именем bool , которая может принимать будевские значения TRUE или FALSE. Вы объявляете эти переменные так: </p><p align="justify" class="paragraph-source">Goods_id NUMBER(4); <br />bool BOOLEAN; </p><p align="justify" class="paragraph-source">     Вы можете также объявлять записи и таблицы PL/SQL, используя составные типы данных PL/SQL: RECORD и TABLE. </p></div><span id="lnkd947b96ccf8848ccae159e59a1bfff79"> </span><h2 align="left" class="paragraph-headline-source">     Присваивания переменным значений</h2><span id="lnk80ab8396b11549928a8a3d5dafbb1e63"> </span><div class="section"><p align="justify" class="paragraph-source">     Вы можете присваивать переменным значения двумя способами. Первый способ использует оператор присваивания := (двоеточие, за которым следует знак равенства). Слева от оператора присваивания кодируется имя переменной, а справа - выражение. </p><p align="justify" class="paragraph-source">     Примеры правильных присваиваний : </p><p align="justify" class="paragraph-source">summa:= price * quantity; <br />new_price:= price * 0.10; <br />str1 := SUBSTR('adcbbnn', 2, 4); <br />val := FALSE; </p><p align="justify" class="paragraph-source">     Второй способ присвоить значение переменной - это извлечь в нее значение из базы данных посредством фразы INTO предложения SELECT или FETCH. Например, вы можете заставить ORACLE вычислить 10% повышение цены товара при извлечении его из таблицы: </p><p align="justify" class="paragraph-source">SELECT price* 0.10 INTO new_price FROM goods WHERE good_id=5; </p><p align="justify" class="paragraph-source">     После этого значение переменной new _ price можно использовать в других вычислениях, либо вставить его в таблицу базы данных.</p></div><span id="lnk98d779a1c3e5444c8325ee8c2aa01ef8"> </span><h2 align="left" class="paragraph-headline-source">     Объявления констант </h2><span id="lnkfe6f3d23cafa40988326dd553348a946"> </span><div class="section"><p align="justify" class="paragraph-source">     Объявление константы аналогично объявлению переменной, с той разницей, что вы должны добавить ключевое слово CONSTANT и немедленно присвоить константе значение. Впоследствии никакие присваивания константе не допускаются. В следующем примере вы объявляете константу с именем min_balance: </p><p align="left" class="paragraph-source">m in _ balance CONSTANT REAL := 10.00; </p></div><span id="lnk192b391eb5c342a2b7e9663ade87660f"> </span><h2 align="left" class="paragraph-headline-source">     Атрибуты</h2><span id="lnk3b1394e39f3a40c8b3073b8f57dfa84a"> </span><div class="section"><p align="justify" class="paragraph-source">     Переменные и константы PL/SQL имеют АТРИБУТЫ, т.е. свойства, позволяющие вам ссылаться на тип данных и структуру объекта, не повторяя его объявление. Аналогичные атрибуты имеются у таблиц и столбцов базы данных, что позволяет вам упростить объявления переменных и констант. </p></div><span id="lnkf3ca5e67377143aea2d0fab25ec9d07e"> </span><h2 align="left" class="paragraph-headline-source">     Атрибут %TYPE</h2><span id="lnk6e8bb244e85c46119b53e17de9445221"> </span><div class="section"><p align="justify" class="paragraph-source">     Атрибут %TYPE представляет тип данных переменной, константы или столбца базы данных. В следующем примере, %TYPE представляет тип данных переменной: </p><p align="justify" class="paragraph-source">credit REAL(7,2); <br />debit credit%TYPE; </p><p align="justify" class="paragraph-source">     Переменные и константы, объявленные с атрибутом %TYPE, трактуются так, как если бы они были объявлены с явным типом данных. Например, в примере выше PL/SQL рассматривает переменную debit как переменную типа REAL(7,2). </p><p align="justify" class="paragraph-source">     Следующий пример показывает, что объявление через %TYPE может включать фразу инициализации: </p><p align="justify" class="paragraph-source">balance NUMBER(7,2); <br />minimum_balance balance%TYPE := 10.00; </p><p align="justify" class="paragraph-source">     Атрибут %TYPE особенно полезен при объявлении переменных, которые ссылаются на столбцы базы данных. Вы можете ссылаться на таблицу и столбец, или указывать также и владельца таблицы, как показывает следующий пример: </p><p align="left" class="paragraph-source">Volume1 scott.goods.volume%TYPE; </p><p align="justify" class="paragraph-source">     Использование атрибута %TYPE при объявлении volume 1 имеет два преимущества. Во-первых, вы не обязаны знать точный тип столбца volume . Во-вторых, если определение столбца volume изменится, то тип данных переменной volume 1 изменится соответственно во время выполнения. </p><p align="justify" class="paragraph-source">     Например, таблица g oo d s содержит столбец с именем name . Чтобы дать переменной name _ new тот же тип данных, что у столбца name , не зная точного определения этого столбца в базе данных, объявите name _ new с использованием атрибута %TYPE: </p><p align="justify" class="paragraph-source">name_new goods.name%TYPE; </p></div><span id="lnk817d775331984edcb8ec138d88801609"> </span><h2 align="left" class="paragraph-headline-source">     Атрибут %ROWTYPE </h2><span id="lnkaf173a2feeda435290774804571fa2e0"> </span><div class="section"><p align="justify" class="paragraph-source">     Атрибут %ROWTYPE возвращает тип записи, представляющей строку в таблице (или обзоре). Такая запись может содержать целую строку данных, выбранных из таблицы или извлеченных курсором. В следующем примере вы объявляете запись, которая хранит строку, выбранную из таблицы goods . </p><p align="justify" class="paragraph-source">DECLARE goods_rec goods%ROWTYPE; </p><p align="justify" class="paragraph-source">     Столбцы в строке таблицы и соответствующие поля в записи имеют одинаковые имена и типы данных. В следующем примере вы выбираете значения столбцов в запись с именем goods _rec: </p><p align="justify" class="paragraph-source">DECLARE <br />goods_rec goods%ROWTYPE; ... <br />BEGIN <br />SELECT * INTO goods_rec FROM goods WHERE ... <br />... <br />END; </p><p align="justify" class="paragraph-source">     Значения столбцов, возвращаемые предложением SELECT, размещаются в индивидуальных полях записи. Вы обращаетесь к конкретному полю, используя квалифицированые ссылки. Например, вы могли бы обратиться к полю goods _ id следующим образом: </p><p align="justify" class="paragraph-source">IF goods_rec.goods_id = 20 THEN ... </p><p align="justify" class="paragraph-source">     Кроме того, вы можете присваивать значение выражения PL/SQL конкретному полю, как показывают следующие примеры: </p><p align="justify" class="paragraph-source">goods_rec.name := 'books'; <br />goods_rec.price:= goods_rec.price * 1.15; </p><p align="justify" class="paragraph-source">     Нельзя включать выражений инициализации в объявления тех переменных, которые используют %ROWTYPE. Тем не менее, есть способ присвоить значения сразу всем полям записи - вы можете присвоить записи список значений столбцов, используя предложения SELECT...INTO или FETCH...INTO (работа с курсорами будет рассмотрена далее) </p></div><span id="lnk90baa18b5d734d7faddf481506df2363"> </span><h2 align="left" class="paragraph-headline-source">     Соглашения об именах </h2><span id="lnk98484c17bb4e4c8babfcbb6f68e46794"> </span><div class="section"><p align="justify" class="paragraph-source">     Одни и те же соглашения об именах действительны для всех программных объектов и единиц PL/SQL, включая константы, переменные, курсоры, исключения, процедуры, функции и пакеты. Имена могут быть простыми, квалифицированными, удаленными или квалифицированными удаленными. </p><p align="justify" class="paragraph-source">     Например, вы можете обращаться к процедуре с именем insert _ goods любым из следующих способов: </p><p align="left" class="paragraph-source">insert _ goods (...); -- простое </p><p align="left" class="paragraph-source">pac _ goods . insert _ goods (...); -- квалифицированное </p><p align="justify" class="paragraph-source">insert _ goods @ newyork (...); -- удаленное </p><p align="justify" class="paragraph-source">pac _ goods . insert _ goods @ newyork (...); -- квалифиц. удаленное </p><p align="justify" class="paragraph-source">     В первом случае вы просто указываете имя процедуры. Во втором случае вы должны квалифицировать имя процедуры именем пакета, потому что процедура хранится в пакете с именем pac _ goods . В третьем случае вы обращаетесь к связи баз данных newyork, потому что (независимая) процедура находится на удаленной базе данных. В четвертом случае вы квалифицируете имя . </p></div><span id="lnkf34cb7e4d22e44bf9bf217a92308717d"> </span><h2 align="left" class="paragraph-headline-source">     Сфера и видимость </h2><span id="lnk7009bb6164fc4e65b911cd52f46f64dc"> </span><div class="section"><p align="justify" class="paragraph-source">     Ссылки на идентификатор разрешаются согласно его сфере и видимости. СФЕРА идентификатора - это та область программной единицы (блока, подпрограммы или пакета), из которой вы можете ссылаться на этот идентификатор. Идентификатор называется ВИДИМЫМ в тех областях, из которых вы можете ссылаться на него, используя неквалицифированное имя. </p><p align="justify" class="paragraph-source">     Например, идентификаторы, объявленные в блоке PL/SQL, считаются локальными в этом блоке и глобальными для всех его подблоков. Если глобальный идентификатор переобъявляется в подблоке, то оба идентификатора остаются в сфере. В подблоке, однако, будет видимым лишь локальный идентификатор, потому что для ссылок к глобальному идентификатору вам приходится использовать квалифицированное имя. </p><p align="justify" class="paragraph-source">     Хотя нельзя объявить идентификатор дважды в одном и том же блоке, можно объявить одинаковые идентификаторы в двух разных блоках. Объекты, представленные этими идентификаторами, различны, и любое изменение одного из этих объектов не затрагивает другой. </p></div><span id="lnkea2be805ff7747cfb26e4dcad1c6f8cb"> </span><h2 align="left" class="paragraph-headline-source">     Управляющие структуры </h2><span id="lnk99bff87f1de04dfcbd26219a8ef040fa"> </span><div class="section"><p align="justify" class="paragraph-source">     Управляющие структуры составляют наиболее важное расширение языка SQL в PL/SQL. Благодаря им вы не просто можете манипулировать данными ORACLE, но можете управлять потоком выполнения, используя предложения условного, итеративного и последовательного управления выполнением, такими как IF-THEN-ELSE, FOR-LOOP, WHILE-LOOP, EXIT-WHEN и GOTO. В совокупности, эти предложения могут обработать любую ситуацию (см. тему 7). </p></div><span id="lnke90eac414d2c42b887f4968009e6ef76"> </span><h2 align="left" class="paragraph-headline-source">     Кодовое множество </h2><span id="lnk8769702afbb848c19b06f254f4923921"> </span><div class="section"><p align="justify" class="paragraph-source">     Вы пишете программу PL/SQL как строки текста, используя специфический набор символов. В этот набор символов входят: </p><p align="left" class="paragraph-source">     - прописные и строчные буквы A .. Z, a .. z; </p><p align="left" class="paragraph-source">     - цифры 0 .. 9; </p><p align="left" class="paragraph-source">     - символы табуляция, пробел и возврат каретки ("пропуски"); </p><p align="left" class="paragraph-source">     - символы ()+-*/&lt;&gt;=!~;:.'@%,"#$^&amp;_|{}?[]. </p><p align="justify" class="paragraph-source">     PL/SQL не различает прописных и строчных букв, и рассматривает строчные буквы как эквиваленты соответствующих прописных букв, исключая строковые и символьные литералы. </p></div><span id="lnka3b9300c278e4cbda3c17d382773c77e"> </span><h2 align="left" class="paragraph-headline-source">     Лексические единицы </h2><span id="lnkb006230237c64c44b13bf5c1ce637765"> </span><div class="section"><p align="justify" class="paragraph-source">     Строка текста программы PL/SQL распадается на группы символов, называемые ЛЕКСИЧЕСКИМИ ЕДИНИЦАМИ, которые можно классифицировать следующим образом: </p><p align="left" class="paragraph-source">     - разделители (простые и составные символы); </p><p align="left" class="paragraph-source">     - идентификаторы, в том числе зарезервированные слова; </p><p align="left" class="paragraph-source">     - литералы; </p><p align="left" class="paragraph-source">     - комментарии. </p></div><span id="lnk78f1f8905f1544b395e066a24f7ae56f"> </span><div class="section"><p align="justify" class="paragraph-source">     РАЗДЕЛИТЕЛЬ - это простой или составной символ, имеющий в PL/SQL специальный смысл. Например, вы используете разделители для представления арифметических операций, таких как сложение и вычитание. </p></div><span id="lnk8e5c69a001f64416a97c6285085d62c2"> </span><div class="section"><p align="justify" class="paragraph-source">     Простые символы кодируются как одиночные символы: </p><p align="left" class="paragraph-source">+ оператор сложения </p><p align="left" class="paragraph-source">- оператор вычитания/отрицания </p><p align="left" class="paragraph-source">* оператор умножения </p><p align="left" class="paragraph-source">/ оператор деления </p><p align="left" class="paragraph-source">= оператор сравнения </p><p align="left" class="paragraph-source">&lt; оператор сравнения </p><p align="left" class="paragraph-source">&gt; оператор сравнения </p><p align="left" class="paragraph-source">( ограничитель выражения или списка </p><p align="left" class="paragraph-source">) ограничитель выражения или списка </p><p align="left" class="paragraph-source">; терминатор предложения </p><p align="left" class="paragraph-source">% индикатор атрибута </p><p align="left" class="paragraph-source">, разделитель элементов </p><p align="left" class="paragraph-source">. селектор компоненты </p><p align="left" class="paragraph-source">@ индикатор удаленного доступа </p><p align="left" class="paragraph-source">' ограничитель символьной строки </p><p align="left" class="paragraph-source">" ограничитель идентификатора </p><p align="left" class="paragraph-source">: индикатор хост-переменной </p></div><span id="lnkb026f959c9214c76b95ed286b0801703"> </span><div class="section"><p align="left" class="paragraph-source">     Составные символы кодируются как пары символов: </p><p align="left" class="paragraph-source">** оператор возведения в степень </p><p align="left" class="paragraph-source">&lt;&gt; оператор сравнения </p><p align="left" class="paragraph-source">!= оператор сравнения </p><p align="left" class="paragraph-source">~= оператор сравнения </p><p align="left" class="paragraph-source">^= оператор сравнения </p><p align="left" class="paragraph-source">&lt;= оператор сравнения </p><p align="left" class="paragraph-source">&gt;= оператор сравнения </p><p align="left" class="paragraph-source">:= оператор присваивания </p><p align="left" class="paragraph-source">=&gt; оператор ассоциации </p><p align="left" class="paragraph-source">.. оператор интервала </p><p align="left" class="paragraph-source">|| оператор конкатенации </p><p align="left" class="paragraph-source">&lt;&lt; ограничитель метки </p><p align="left" class="paragraph-source">&gt;&gt; ограничитель метки </p><p align="left" class="paragraph-source">-- индикатор однострочного комментария </p><p align="left" class="paragraph-source">/* (начальный) ограничитель многострочного комментария </p><p align="left" class="paragraph-source">*/ (конечный) ограничитель многострочного комментария. </p></div><span id="lnkd794840f40ff4e9ca63762f9da0f605f"> </span><h2 align="left" class="paragraph-headline-source">     Идентификаторы </h2><span id="lnk56d9ad2a1f7849f8954b986d6e92a92b"> </span><div class="section"><p align="justify" class="paragraph-source">     Вы используете идентификаторы для именования программных объектов и единиц PL/SQL, к которым относятся константы, переменные, исключения, курсоры, подпрограммы и пакеты. Некоторые примеры идентификаторов : X, t2, phone# , credit_limit, LastName,oracle$number. </p><p align="justify" class="paragraph-source">     Идентификатор состоит из буквы, за которой (необязательно) следуют одна или несколько букв, цифр, знаков доллара, подчеркиваний или знаков номера (#). Другие символы, такие как дефис, наклонная черта или пропуск, в идентификаторе незаконны, как показывают следующие примеры: </p><p align="justify" class="paragraph-source">     - mine&amp;yours -- незаконный амперсанд;</p><p align="justify" class="paragraph-source">     - debit-amount -- незаконный дефис ;</p><p align="justify" class="paragraph-source">     - on/off -- незаконная косая черта ;</p><p align="justify" class="paragraph-source">     - user id -- незаконный пробел.</p><p align="justify" class="paragraph-source">     Буквы в идентификаторах могут быть как прописными, так и строчными. PL/SQL не различает их, за исключением строковых и символьных литералов. Поэтому, если единственным различием между идентификаторами является регистр соответствующих букв, то PL/SQL трактует такие идентификаторы как одинаковые, как показывает следующий пример: </p><p align="justify" class="paragraph-source">lastname LastName -- то же, что lastname LASTNAME -- то же, что lastname и LastName </p><p align="justify" class="paragraph-source">     Длина идентификатора не может превышать 30 символов. Однако значащим считается каждый символ в идентификаторе, включая знаки доллара, подчеркивания и знаки номера. Например, следующие два идентификатора считаются в PL/SQL различными: </p><p align="left" class="paragraph-source">lastname <br />last_name </p></div><span id="lnkcc5b694994c34523aa0098abda97aa09"> </span><h2 align="left" class="paragraph-headline-source">     Зарезервированные слова </h2><span id="lnk7fcd277f55064f43b0e9164da47dff5d"> </span><div class="section"><p align="justify" class="paragraph-source">     Некоторые идентификаторы, называемые ЗАРЕЗЕРВИРОВАННЫМИ СЛОВАМИ, имеют специальный смысл в PL/SQL и не могут быть переопределены. Например, слова BEGIN и END, которые окружают исполнительную часть блока или подпрограммы, зарезервированы. </p><p align="justify" class="paragraph-source">     Однако заререзированные слова можно включать как составные части в идентификаторы, как показывает следующий пример: </p><p align="justify" class="paragraph-source">DECLARE end_of_game BOOLEAN; -- законно ... </p><p align="justify" class="paragraph-source">     Как правило, зарезервированные слова пишутся прописными буквами, чтобы облегчить читабельность. Однако это необязательно; как и любые другие идентификаторы PL/SQL, зарезервированные слова можно кодировать строчными или смешанными буквами. </p></div><span id="lnkf853569c9afe47d6b298324672c3522c"> </span><h2 align="left" class="paragraph-headline-source">     Идентификаторы в кавычках </h2><span id="lnk9746da48a6354387b621017866a87f72"> </span><div class="section"><p align="justify" class="paragraph-source">     Для большей гибкости, PL/SQL позволяет вам заключать идентификаторы в двойные кавычки. Идентификаторы в кавычках необходимы нечасто, но иногда они могут быть полезными. Такой идентификатор может содержать любую последовательность печатных символов, включая пробелы, но исключая двойные кавычки: "X+Y", "last name", "*** header info ***". </p><p align="justify" class="paragraph-source">     Максимальная длина идентификатора в кавычках составляет 30 символов, не считая кавычек. </p><p align="justify" class="paragraph-source">     Использование в качестве идентификаторов в кавычках зарезервированных слов PL/SQL допускается, но НЕ рекомендуется. Использование зарезервированных слов является плохой практикой программирования. </p></div><span id="lnk7ad043ce994d40c7980c7a521162d6a1"> </span><h2 align="left" class="paragraph-headline-source">     Литералы </h2><span id="lnk336a5ec5bb724279a4770ea3a891d1f9"> </span><div class="section"><p align="justify" class="paragraph-source">     Литерал - это явное число, символ, строка или булевское значение, не представленное идентификатором. Примерами могут служить числовой литерал 147 и булевский литерал FALSE. </p></div><span id="lnk03fb9e215c1a41d7991ee68a486e6bbe"> </span><h2 align="left" class="paragraph-headline-source">     Числовые литералы </h2><span id="lnk34c60d816a324a9490cc8dfa6aee0bd0"> </span><div class="section"><p align="justify" class="paragraph-source">     В арифметических выражениях могут использоваться два вида числовых литералов: целочисленные и вещественные. Целочисленный литерал - это целое число с необязательным знаком и без десятичной точки. Примеры целочисленных литералов: 6; -14; 0; +32767. </p><p align="justify" class="paragraph-source">     Вещественный литерал - это целое или дробное число с необязательным знаком и с десятичной точкой. Примеры вещественных литералов: 6.6667; -12.0; 3.14159. </p></div><span id="lnk196a617629784e2da49047a0dc0c3e2a"> </span><h2 align="left" class="paragraph-headline-source">     Символьные литералы</h2><span id="lnka02fb6c7be7344dc8aeb4baed0d351c0"> </span><div class="section"><p align="left" class="paragraph-source">     Символьный литерал - это одиночный символ, окруженный одиночными апострофами. Примеры: 'Z'; '%'; '7'; ' '; 'z'; '('. </p><p align="justify" class="paragraph-source">     Символьные литералы включают все печатные символы в наборе символов PL/SQL: буквы, цифры, пропуски и специальные символы. PL/SQL чувствителен к регистру букв в символьных литералах. Так, литералы 'Z' и 'z' считаются различными. </p></div><span id="lnk685bf3b9c9324930a991ef2a4974d64e"> </span><h2 align="left" class="paragraph-headline-source">     Строковые литералы </h2><span id="lnk4c1049971a6f46fd94eb2959bc73ad99"> </span><div class="section"><p align="justify" class="paragraph-source">     Символьное значение может быть представлено идентификатором или явно записано в виде строкового литерала, который должен быть последовательностью из нуля или более символов, заключенной в апострофы: 'Hello, world!'; 'XYZ Corporation'; '10-NOV-91'. </p><p align="justify" class="paragraph-source">     PL/SQL чувствителен к регистру букв в строковых литералах. Например, следующие литералы считаются различными: 'baker' и 'Baker'. </p></div><span id="lnk99a266317f124ff6b76bb2c185ba9eb9"> </span><h2 align="left" class="paragraph-headline-source">     Булевские литералы </h2><span id="lnk284a322929dc4c7c87c076de5c77a4d3"> </span><div class="section"><p align="justify" class="paragraph-source">     Булевские литералы - это предопределенные значения TRUE и FALSE, а также "не-значение" NULL, которое обозначает отсутствие, неизвестность или неприменимость значения. Не забывайте, что булевские литералы НЕ являются строками. </p></div><span id="lnk57f54f1e9e714ee6843cdb013ffc0f2a"> </span><h2 align="left" class="paragraph-headline-source">     Комментарии </h2><span id="lnk98b3fa2a07b5438f969f1d22b761ade3"> </span><div class="section"><p align="justify" class="paragraph-source">     Добавление комментариев в вашу программу способствует ее читабельности и облегчает ее понимание. Обычно комментарии используются для описания назначения и использования каждого сегмента кода. PL/SQL поддерживает два стиля комментариев: однострочные и многострочные. </p><p align="justify" class="paragraph-source">     Однострочный комментарий начинается с двойного дефиса (--) и заканчивается концом строки. Примеры: </p><p align="justify" class="paragraph-source">-- начало обработки <br />SELECT price INTO new_price FROM goods -- взять текущую цену <br />WHERE goods_id= 10; <br />chet:= new_price * 150; -- вычислить величину счета </p><p align="justify" class="paragraph-source">     Заметьте, что однострочный комментарий может начинаться на одной строке с предложением (или частью предложения). </p><p align="justify" class="paragraph-source">     Многострочный комментарий начинается с пары символов /* и заканчивается парой символов */. Пример: </p><p align="justify" class="paragraph-source">/* вычислить 15% премию для <br />сотрудников с высоким рейтингом */ <br />IF rating &gt; 90 THEN bonus := salary * 0.15; <br />END IF; </p><p align="justify" class="paragraph-source">     Этот стиль позволяет, например, легко "закомментировать" секцию блока, которую вы хотите временно исключить из выполняемого кода. </p><p align="justify" class="paragraph-source">     Нельзя вкладывать комментарии друг в друга. Кроме того, нельзя использовать однострочные комментарии в том блоке PL/SQL, который будет обрабатываться динамически программой прекомпилятора ORACLE, потому что в этом случае символы конца строки игнорируются, и, как следствие, однострочный комментарий растянется до конца блока, а не только до конца строки. Поэтому в таких случаях используйте многострочные комментарии. </p></div></div></td></tr></table></td></tr><tr><td id="bottomOuter"><table id="bottomInner"><tr><td class="cell1"><div> </div></td><td class="cell2"><div>© 2012 ХНУРЭ, ПИ, Широкопетлева М.С., <a href="mailto:mshirokopetleva@gmail.com">mshirokopetleva@gmail.com</a>;   ХНУРЭ, ПИ, Черепанова Ю.Ю.;   ХНУРЭ, ПИ, Мазурова О.А.<br /><a href="http://lersus.de/" title="Данный курс создан с помощью авторской системы LERSUS" target="_blank">Разработано с помощью LERSUS</a></div></td></tr></table></td></tr></table></body></html>