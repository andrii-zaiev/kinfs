<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="LERSUS 3.3.0.0" /><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Корпоративные информационные системы — Теория — Создание таблиц с распределением памяти </title><script language="javascript" type="text/javascript" src="../../00/styles/files/apiwrapper.js"> </script><script language="javascript" type="text/javascript" src="../../00/styles/files/sco.js"> </script><link href="../../00/styles/files/style.css" rel="stylesheet" type="text/css" /></head><body><table id="mainOuter"><tr><td id="topOuter"><table id="topInner"><tr class="row1"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4" id="shortcuts"><div><ul class="level0"><li><a href="../../00/content/authors1.html">Авторы</a></li><li>|</li><li><a href="../../00/content/contacts1.html">Контакты</a></li><li>|</li><li><a href="../../00/content/instructions1.html">Методические указания</a></li><li>|</li><li><a href="../../00/content/annotation1.html">Аннотация</a></li><li>|</li><li><a href="#" onclick="history.back(); return false;">Назад</a></li></ul></div></td></tr><tr class="row2"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4"><div id="courseTitle">Корпоративные информационные системы</div><div id="courseSubTitle">Физическая организация БД на примере СУБД Oracle : Создание таблиц с распределением памяти </div></td></tr></table></td></tr><tr><td id="contentOuter"><table id="contentInner"><tr><td class="menuOuter"><table class="menuInner"><tr><td><ul class="level0"><li><a href="../../00/styles/courses.html">Содержание курса</a></li><li><span>Теория</span></li><ul class="level1"><li><a href="../../02/content/content1.html">Основные концепции СУБД Oracle</a></li><li><a href="../../02/content/content2.html">Логическая структура</a></li><li><a href="../../02/content/content3.html">Экстенты и сегменты</a></li><li><a href="../../02/content/content4.html">Табличные пространства и файлы данных </a></li><li><a href="../../02/content/content5.html">Процессы инстанции Oracle </a></li><li><a href="../../02/content/content6.html">Структуры памяти ORACLE</a></li><li><a href="../../02/content/content7.html">Создание таблиц с распределением памяти </a></li><li><a href="../../02/content/content8.html">Объекты базы данных</a></li><li><a href="../../02/content/content9.html">Утилита SQL*Plus</a></li><li><a href="../../02/content/content10.html">Работа со словарем данных</a></li><li><a href="../../02/content/content11.html">Введение в аудитинг</a></li></ul><li><span>Практика</span></li><ul class="level1"><li><a href="../../02/content/example1.html">Практика 1. Настройка структур памяти при создании основных объектов БД</a></li><li><a href="../../02/content/example2.html">Лабораторная работа 1. Работа с основными объектами базы и служебной информацией</a></li></ul><li><span>Текущий контроль знаний</span></li><ul class="level1"><li><a href="../../02/content/multiply-choice-test1.html">Введение в сервер Oracle</a></li><li><a href="../../02/content/multiply-choice-test9.html">Объекты схемы базы данных Oracle</a></li></ul><li><a href="../../02/styles/glossary.html">Словарь терминов</a></li><li><a href="../../02/02.pdf" target="_blank">Версия для печати</a></li></ul></td></tr></table></td><td class="content"><div id="content"><div id="topBlankStripe"> </div><span id="lnk2e58eb13c35c46188fea476d74334bf4"> </span><h1 align="left" class="headline-source">     Создание таблиц с распределением памяти </h1><span id="lnka91ec77e68034485ba020268f1c31cb8"> </span><h2 align="left" class="paragraph-headline-source">     Объекты схемы. Таблицы</h2><span id="lnk4c5a4ecfd85547d5b0691d13ff8dd12c"> </span><div class="section"><p align="justify" class="paragraph-source">     <i><b>Объекты схемы</b></i> - это логические структуры памяти данных. </p><p align="justify" class="paragraph-source">     Каждому объекту схемы не соответствует физический файл на диске, в котором содержится информация этого объекта. Однако объект схемы логически хранится в табличном пространстве базы данных. Данные каждого объекта физически размещаются в одном или нескольких файлах данных табличного пространства. Для некоторых объектов, таких как таблицы, индексы и кластеры, вы можете указать количество дисковой памяти, которое должно быть распределено объекту в файлах данных табличного пространства. </p><p align="justify" class="paragraph-source">     На рисунке 9 показано отношение между объектами, табличными пространствами и файлами данных. </p><p align="justify" class="paragraph-source">     </p><p align="center" class="paragraph-source"><img src="../res/files/th1_8_0__0_.JPG" height="308px" width="536px" alt="" /><b> </b></p><p align="center" class="paragraph-source">Рисунок 9 - Объекты схемы, табличные пространства и файлы данных </p><p align="center" class="paragraph-source">     </p><p align="justify" class="paragraph-source">     Не существует отношения между схемами и табличными пространствами; табличные пространства могут содержать объекты из разных схем, а объекты одной схемы могут содержаться в разных табличных пространствах.</p></div><span id="lnk4d3a94fc985a416b8070d02d831c8633"> </span><h2 align="left" class="paragraph-headline-source">     Таблицы</h2><span id="lnk2397069d0d554d10a565c7956a8e7c7a"> </span><div class="section"><p align="justify" class="paragraph-source">     <i><b>Таблица </b></i>- это основная единица памяти данных в базе данных ORACLE. </p><p align="justify" class="paragraph-source">     Данные таблицы хранятся в строках и столбцах. Каждая таблица определяется именем и набором столбцов. Каждому столбцу дается имя столбца, тип данных (такой как VARCHAR2, DATE или NUMBER) и ширина (которая может быть предопределена типом данных, как в случае DATE) или точность и масштаб (только для столбцов типа NUMBER). Строка - это коллекция информации столбцов, соответствующая одной записи.</p><p align="justify" class="paragraph-source">     Можно специфицировать правила для каждого столбца таблицы. Эти правила называются ограничениями целостности. Примером может служить ограничение целостности NOT NULL, которое диктует, что столбец не может содержать пустых значений. </p><p align="justify" class="paragraph-source">     После создания таблицы, в нее можно вставлять строки данных, используя предложения SQL. Затем информацию таблицы можно опрашивать, удалять или обновлять с помощью SQL.</p></div><span id="lnk7b695b916f92494d9b45f13413261ca9"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Как хранятся данные таблицы</b></p></div><span id="lnk5237c0b646cc4997b52c526282d0ba77"> </span><div class="section"><p align="justify" class="paragraph-source">     При создании таблицы в табличном пространстве автоматически создается сегмент данных, в котором будут храниться будущие данные этой таблицы. Вы можете контролировать распределение и использование пространства для сегмента данных таблицы различными способами:</p><p align="justify" class="paragraph-source">     - Можно управлять размерами экстентов для сегмента данных, установив параметры пространства для этого сегмента.</p><p align="justify" class="paragraph-source">     - Можно контролировать использование свободной памяти в блоках данных, составляющих экстенты сегмента данных, установив параметры PCTFREE и PCTUSED для этого сегмента.</p><p align="justify" class="paragraph-source">     Табличное пространство, в котором содержится таблица - это либо умалчиваемое табличное пространство пользователя, либо табличное пространство, явно указанное в предложении CREATE TABLE. </p></div><span id="lnk88ef8a3db89b4045aa0d2618ece511c9"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Синтаксис создания таблицы</b></p></div><span id="lnkf7114eacf90140edbd6fb36070be1410"> </span><div class="section"><p align="left" class="paragraph-source">     Синтаксис создания таблицы показан на рисунке 10.</p></div><span id="lnka503a11f4507494da90b8e3852fe0b46"> </span><div class="section"><p align="center" class="paragraph-source"><img src="../res/files/jpg192_0__0_.jpeg" height="427px" width="504px" alt="" /> </p><p align="center" class="paragraph-source">Рисунок 10 - Синтаксис создания таблицы</p><p align="center" class="paragraph-source"></p><p align="left" class="paragraph-source">     Некоторые ключевые слова и параметры приведены в таблице 2, об остальных  подробно рассказано ниже</p></div><span id="lnk2674fb0b0e6841e18b3ee52169c0dc09"> </span><div align="center"><div class="inline-table-container"><p align="left" class="unit-title">Таблица 2 - Ключевые слова  команды CREATE TABLE</p><table class="inline-table"><col width="100" /><col width="465" /><tbody><tr><td style="background-color:#ffffff"><p align="center" class="inline-table">Ключевые слова </p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">Описание </p></td></tr><tr><td style="background-color:#ffffff"><p align="center" class="inline-table">1 </p></td><td style="background-color:#ffffff"><p align="center" class="inline-table">2 </p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">Схема </p></td><td style="background-color:#ffffff"><p align="justify" class="inline-table">Схема, в которой создается таблица. Если СХЕМА опущена, то ORACLE создает таблицу в вашей схеме </p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">Таблица </p></td><td style="background-color:#ffffff"><p align="justify" class="inline-table">Имя создаваемой таблицы. </p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">Столбец </p></td><td style="background-color:#ffffff"><p align="justify" class="inline-table">Специфицирует имя столбца таблицы. Количество столбцов в таблице может варьироваться от 1 до 254 </p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">Тип </p></td><td style="background-color:#ffffff"><p align="justify" class="inline-table">Тип данных столбца.  </p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">DEFAULT </p></td><td style="background-color:#ffffff"><p align="justify" class="inline-table">Специфицирует умалчиваемое значение, которое должно назначаться столбцу, если в предложении INSERT, вставляющем данные в таблицу, будет отсутствовать значение для этого столбца. Тип данных выражения "выр" должен совпадать с типом данных столбца Выражение DEFAULT не может содержать ссылок на другие столбцы, псевдостолбцов CURRVAL, NEXTVAL, LEVEL и ROWNUM, а также не полностью специфицированных констант дат. </p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">огр_столбца </p></td><td style="background-color:#ffffff"><p align="justify" class="inline-table">Определяет ограничение целостности как часть определения столбца </p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">огр_таблицы </p></td><td style="background-color:#ffffff"><p align="justify" class="inline-table">Определяет ограничение целостности как часть определения таблицы. </p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">Табличное пространство </p></td><td style="background-color:#ffffff"><p align="justify" class="inline-table">Специфицирует табличное пространство, в котором ORACLE создает таблицу. Если эта опция опущена, то ORACLE создает таблицу в умалчиваемом табличном пространстве владельца схемы, в которой создается таблица. </p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">STORAGE </p></td><td style="background-color:#ffffff"><p align="justify" class="inline-table">Специфицирует характеристики памяти для таблицы. Эта фраза имеет некоторые варианты производительности для больших таблиц. Следует распределять память так, чтобы минимизировать динамическое распределение дополнительной памяти. </p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">CLUSTER </p></td><td style="background-color:#ffffff"><p align="justify" class="inline-table">Указывает, что таблица должна быть частью кластера. Столбцы, перечисленные в этой фразе, называют те столбцы таблицы, которые соответствуют столбцам ключа кластера. Обычно эти столбцы составляют первичный ключ таблицы или часть ее первичного ключа. Столбцы таблицы и кластера сопоставляются по позициям, а не по именам. Поскольку кластеризованная таблица использует распределение памяти кластера, не рекомендуется использование с опцией CLUSTER параметров PCTFREE, PCTUSED, INITRANS и MAXTRANS, а также опции TABLESPACE. </p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">ENABLE </p></td><td style="background-color:#ffffff"><p align="left" class="inline-table">Включает ограничение целостности </p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">DISABLE </p></td><td style="background-color:#ffffff"><p align="justify" class="inline-table">Выключает ограничение целостности. </p></td></tr><tr><td style="background-color:#ffffff"><p align="left" class="inline-table">AS подзапрос </p></td><td style="background-color:#ffffff"><p align="justify" class="inline-table">Вставляет в таблицу при ее создании строки, возвращаемые подзапросом. При включении этой фразы, определения столбцов могут специфицировать только имена столбцов, их умалчиваемые значения и ограничения целостности, но не типы данных. ORACLE выводит типы данных и длины столбцов из подзапроса. ORACLE также автоматически определяет ограничения NOT NULL по столбцам новой таблицы, если эти ограничения существовали по соответствующим столбцам опрашиваемой таблицы, и если подзапрос не модифицирует значение столбца посредством функции SQL или оператора. Предложение CREATE TABLE не может содержать одновременно фразу AS и определение ограничения ссылочной целостности. Число столбцов в таблице должно совпадать с количеством выражений в подзапросе. Если все выражения в подзапросе представляют собой столбцы, то можно полностью опустить перечень столбцов в определении таблицы. В этом случае имена столбцов таблицы будут такими же, как имена столбцов в подзапросе. </p></td></tr></tbody></table></div></div><span id="lnk107179a4055d4b12918e5adac8bafe5f"> </span><div class="section"><p align="justify" class="paragraph-source">     Рассмотрим возможности управления распределением памяти при создании таблиц.</p></div><span id="lnk1687f22f54f84e44854f1ff836465939"> </span><div class="section"><p align="justify" class="paragraph-source">     Следующие секции объясняют, как использовать параметры PCTFREE и PCTUSED для выполнения следующих задач:</p><p align="justify" class="paragraph-source">     - повышения производительности записи и извлечения данных или индексов;</p><p align="justify" class="paragraph-source">     - уменьшения объема неиспользуемой памяти в блоках данных;</p><p align="justify" class="paragraph-source">     - уменьшения количества цепочек строк между блоками данных.</p></div><span id="lnk6ad36031748b419da492d06e2b7d0500"> </span><h2 align="left" class="paragraph-headline-source">     Специфицирование PCTFREE</h2><span id="lnka6aa77b4ce8143ff99f22014d333b8aa"> </span><div class="section"><p align="justify" class="paragraph-source">     Умолчание для PCTFREE равно 10 процентов; вы можете задавать любое целое значение от 0 до 99 включительно, пока сумма PCTFREE и PCTUSED не превышает 100. (Если вы установите PCTFREE как 99, то ORACLE будет помещать в каждый блок по меньшей мере одну строку, независимо от размера этой строки. Если строки очень малы, а блоки очень велики, может уместиться даже несколько строк.)</p><p align="justify" class="paragraph-source">     Низкое значение PCTFREE имеет следующие эффекты:</p><p align="justify" class="paragraph-source">     - резервирует меньше места для обновлений существующих строк таблицы;</p><p align="justify" class="paragraph-source">     - позволяет более полно заполнять блок вставками;     </p><p align="justify" class="paragraph-source">     - может экономить память, так как все данные таблицы или индекса хранятся в меньшем количестве блоков (больше строк на один блок);</p><p align="justify" class="paragraph-source">     - увеличивает стоимость обработки, так как ORACLE вынужден часто реорганизовывать блоки по мере заполнения их свободной памяти новыми или обновленными данными;</p><p align="justify" class="paragraph-source">     - потенциально увеличивает стоимость обработки и требуемую память, если обновления строк или записей индекса приводят к росту строк и расщеплению их между блоками (ибо предложения UPDATE, DELETE и SELECT должны считывать больше блоков для данной строки, следуя по цепочке, связывающей куски строки)</p></div><span id="lnkebc30ef36931447badac7992d3eadf72"> </span><div class="section"><p align="justify" class="paragraph-source">     Высокое значение PCTFREE имеет следующие эффекты:</p><p align="justify" class="paragraph-source">     - резервирует больше места для обновлений существующих строк таблицы;</p><p align="justify" class="paragraph-source">     - может потребовать больше памяти для того же количества вставляемых данных (вставляет меньше строк на один блок);</p><p align="justify" class="paragraph-source">     - уменьшает стоимость обработки, так как блоки редко требуют реорганизации своей свободной памяти;</p><p align="justify" class="paragraph-source">     - может улучшить производительность обновлений, потому что ORACLE не должен столь часто, как прежде, строить цепочки для кусков строк.</p></div><span id="lnk49722322b7f74c4890a9cb49019bcbc5"> </span><div id="see-more49722322b7f74c4890a9cb49019bcbc5" class="additional"><table border="0"><tr><td><img src="../../00/styles/files/seecollapsed.gif" alt="Смотрите также:" title="Смотрите также:" class="collapse-img" style="width:16px; height:16px;" /></td><td><a href="javascript:seeMore('49722322b7f74c4890a9cb49019bcbc5');" class="paragraph-source">Смотрите также:</a></td></tr></table><div style="display:none;"><p align="justify" class="note-source">     При установке PCTFREE необходимо понимать природу данных таблицы или индекса. Обновления могут приводить к росту строк. Новые значения могут иметь размер, отличный от размера заменяемых ими значений. Если имеют место много обновлений, при которых размер данных увеличивается, то PCTFREE следует увеличить; если обновления существенно не влияют на размеры строк, PCTFREE может быть низким.</p><p align="justify" class="note-source">     Ваша цель - найти удовлетворительный компромисс между плотной упаковкой данных (низкий PCTFREE, заполненные блоки) и хорошей производительностью обновлений (высокий PCTFREE, менее заполненные блоки).</p><p align="justify" class="note-source">     PCTFREE также влияет на производительность запросов данного пользователя по таблицам, имеющим неподтвержденные транзакции от других пользователей (т.е. по таблицам, одновременно обновляемым другими пользователями). Обеспечение согласованности по чтению может потребовать частой реорганизации свободной памяти в блоках, если свободные участки в этих блоках малы.</p></div></div><span id="lnk56a879b9773244468e3a9b6b3066cd82"> </span><div class="section"><p align="left" class="paragraph-source">     <b>PCTFREE </b><b>для таблиц</b></p></div><span id="lnkfcfc1991cff64807a2c74c7c13a9e29e"> </span><div class="section"><p align="justify" class="paragraph-source">     Если данные в строках таблицы имеют тенденцию к увеличению размера, зарезервируйте часть места для таких обновлений. В противном случае обновления строк будут приводить к расщеплению строк между блоками и ухудшению производительности операций ввода-вывода, связанных с этими строками.</p></div><span id="lnk63d7aeeba0894b20bea42c2aefcbbe3d"> </span><h2 align="left" class="paragraph-headline-source">     Специфицирование PCTUSED</h2><span id="lnk138d77f6479844e397603b2990a81b5d"> </span><div class="section"><p align="justify" class="paragraph-source">     Когда свободная память в блоке данных падает до PCTFREE, в этот блок не вставляются новые строки, пока процент занятой памяти не упадет ниже PCTUSED. ORACLE старается удержать блок данных заполненным по крайней мере на PCTUSED. Это - процент памяти в блоке, свободной для данных после вычета накладных расходов из общей памяти блока.</p><p align="justify" class="paragraph-source">     Умолчание для PCTUSED равно 40 процентов; вы можете задавать любое целое значение от 0 до 99 включительно, пока сумма PCTFREE и PCTUSED не превышает 100.</p></div><span id="lnkc2496589bd9149ce82a3b2adb68ca067"> </span><div class="section"><p align="justify" class="paragraph-source">     Низкое значение PCTUSED имеет следующие эффекты:</p><p align="justify" class="paragraph-source">     - в среднем, удерживает блоки менее заполненными, чем высокий процент PCTUSED;</p><p align="justify" class="paragraph-source">     - уменьшает стоимость обработки, требующейся при UPDATE и DELETE для перемещения блока в свободный список, когда его занятая память падает ниже PCTUSED;</p><p align="justify" class="paragraph-source">     - увеличивает неиспользуемую память в базе данных.</p></div><span id="lnk63967ef73116493db64cdac25af62371"> </span><div class="section"><p align="justify" class="paragraph-source">     Высокое значение PCTUSED имеет следующие эффекты:</p><p align="justify" class="paragraph-source">     - в среднем, удерживает блоки более заполненными, чем низкий процент PCTUSED;</p><p align="justify" class="paragraph-source">     - улучшает эффективность использования памяти;</p><p align="justify" class="paragraph-source">     - увеличивает стоимость обработки, требующейся при UPDATE и DELETE.</p></div><span id="lnkb824df9adbfd459d88e6b75939933b71"> </span><div class="section"><p align="justify" class="paragraph-source">     <b>Выбор связанных значений PCTUSED и PCTFREE</b></p></div><span id="lnk06598dd82b544601bb0fa6c03b70f638"> </span><div class="section"><p align="justify" class="paragraph-source">     Если вы решили явно задать значения PCTUSED и PCTFREE, примите во внимание следующие соображения:</p><p align="justify" class="paragraph-source">     - Сумма PCTFREE и PCTUSED не должна превышать 100.</p><p align="justify" class="paragraph-source">     - Если эта сумма меньше 100, то идеальным компромиссом между утилизацией памяти и производительностью ввода-вывода является случай, когда сумма PCTFREE и PCTUSED отличается от 100 на величину, равную проценту памяти в свободном блоке, занимаемому средней строкой. Например, предположим, что размер блока данных равен 2048 байт; за минусом 100 байт накладных расходов это дает 1948 байт, доступных для данных. Если средняя строка требует 195 байт, или 10% от 1948, то наилучший компромисс даст сумма PCTFREE и PCTUSED, равная 90%.</p><p align="justify" class="paragraph-source">     -Если эта сумма равна 100, то ORACLE пытается удерживать в блоке не больше чем PCTFREE свободной памяти, и стоимость обработки будет максимальной.</p><p align="justify" class="paragraph-source">     - Фиксированные накладные расходы блока не включаются в вычисления PCTUSED и PCTFREE.</p><p align="justify" class="paragraph-source">     - Чем меньше разница между 100 и суммой PCTUSED и PCTFREE (скажем, при PCTUSED=75 и PCTFREE=20), тем выше утилизация памяти, за счет некоторого повышения стоимости обработки.</p></div><span id="lnk92d1c833ed12493b9ee25aa9af59a01e"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Примеры выбора значений PCTFREE и PCTUSED</b></p></div><span id="lnkd8be0692662944858287ea4b982c65d5"> </span><div class="section"><p align="justify" class="paragraph-source">     Следующие примеры иллюстрируют подбор значений PCTFREE и PCTUSED при заданных сценариях.</p></div><span id="lnkaa8e51d9f97e49bcace201ee6d95073a"> </span><table class="note"><tr><td><p align="justify" class="note-source">     Сценарий 1: Типичная работа включает предложения UPDATE, которые увеличивают размеры строк.</p><p align="justify" class="note-source">     Установка:      </p><p align="justify" class="note-source">PCTFREE = 20 </p><p align="left" class="note-source">PCTUSED = 40</p></td><th><img src="../../00/styles/files/note_problem.png" title="Проблемма" alt="Проблемма" /></th></tr></table><span id="lnkac5a7fd303e54700b9e7fbfb23fadcba"> </span><div class="section"><p align="justify" class="paragraph-source">     Объяснение: PCTFREE установлен в 20, чтобы оставить достаточно места для строк, увеличивающихся в размере при обновлениях. PCTUSED установлен в 40, чтобы требовалось меньше обработки при высокой активности обновлений, т.е. для улучшения производительности.</p></div><span id="lnkdd678cd5c3654cc1a7e7e194f272c7a5"> </span><table class="note"><tr><td><p align="justify" class="note-source">     Сценарий 2: Типичная работа включает предложения INSERT и DELETE, а предложения UPDATE в среднем не увеличивают размеры строк.</p><p align="justify" class="note-source">      Установка: </p><p align="justify" class="note-source">PCTFREE = 5 </p><p align="left" class="note-source">PCTUSED = 60</p></td><th><img src="../../00/styles/files/note_problem.png" title="Проблемма" alt="Проблемма" /></th></tr></table><span id="lnkcdc6cbe523b34bf4ae37e9bb12ccf773"> </span><div class="section"><p align="justify" class="paragraph-source">     Объяснение: PCTFREE установлен в 5, так как большинство предложений UPDATE не увеличивают размеров строк. PCTUSED установлен в 60, так что память, освобождаемая предложениями DELETE, скоро начинает повторно использоваться, так что обработка минимизируется.</p></div><span id="lnk9ae41f27707346248327cd7f97c35f35"> </span><table class="note"><tr><td><p align="justify" class="note-source">     Сценарий 3: Таблица очень велика; поэтому основной заботой является память. Типичная работа включает только-читающие транзакции.</p><p align="justify" class="note-source">     Установка: </p><p align="justify" class="note-source">PCTFREE = 5 </p><p align="left" class="note-source">PCTUSED = 90</p></td><th><img src="../../00/styles/files/note_problem.png" title="Проблемма" alt="Проблемма" /></th></tr></table><span id="lnk9dc9f397b1a343e68c910ba9af992db9"> </span><div class="section"><p align="justify" class="paragraph-source">     Объяснение: PCTFREE установлен в 5, так предложения UPDATE используются редко. PCTUSED установлен в 90, так что для хранения данных используется большая часть блока. Это значение PCTUSED уменьшает число блоков, требуемое для размещения всех данных таблицы, сокращает среднее число блоков, просматриваемых во время запросов, и тем самым увеличивает производительность запросов.</p></div><span id="lnk60073596e73a426db70bf7120b8f445d"> </span><h2 align="left" class="paragraph-headline-source">     Установка параметров памяти</h2><span id="lnk8fefd6aafdc34303b918c50bc29fb715"> </span><div class="section"><p align="justify" class="paragraph-source">     Можно устанавливать параметры памяти для следующих типов структур логической памяти: </p><p align="justify" class="paragraph-source">     - табличных пространств (действуют на каждый сегмент в табличном пространстве); </p><p align="justify" class="paragraph-source">      -таблиц, кластеров, снимков и журналов снимков (сегментов данных); </p><p align="justify" class="paragraph-source">     - индексов (сегментов индексов); </p><p align="left" class="paragraph-source">     - сегментов отката.      </p><p align="justify" class="paragraph-source">     Каждая база данных имеет умалчиваемые значения для параметров памяти. Вы можете специфицировать умолчания для табличного пространства, которые перекроют системные умолчания и станут умолчаниями для объектов, создаваемых в этом конкретном табличном пространстве; кроме того, вы можете явно специфицировать характеристики памяти для каждого индивидуального объекта. Параметры памяти, которые вы можете устанавливать, перечислены ниже, вместе с их системными умолчаниями. </p></div><span id="lnk63332b8357a947678d14995194a65d71"> </span><div id="see-more63332b8357a947678d14995194a65d71" class="additional"><table border="0"><tr><td><img src="../../00/styles/files/seecollapsed.gif" alt="Смотрите также:" title="Смотрите также:" class="collapse-img" style="width:16px; height:16px;" /></td><td><a href="javascript:seeMore('63332b8357a947678d14995194a65d71');" class="paragraph-source">Смотрите также:</a></td></tr></table><div style="display:none;"><p align="justify" class="note-source">     <b>INITIAL </b>- размер, в байтах, первого экстента, который распределяется при создании сегмента. </p><p align="justify" class="note-source">     <i>Умолчание</i>: 5 блоков данных. </p><p align="justify" class="note-source">     <i>Минимум</i>: 2 блока данных. </p><p align="justify" class="note-source">     <i>Максимум</i>: зависит от операционной системы. </p><p align="justify" class="note-source">     Хотя системные умолчания приведены в блоках данных, при задании этого значения используйте байты. Можно применять сокращения К или М для обозначения кило- и мегабайтов. Заданное значение округляется ВВЕРХ до ближайшего кратного размеру блока данных, который определяется параметром DB _ BLOCK _ SIZE . </p><p align="justify" class="note-source">     Например, если размер блока данных базы данных равен 2048 байт, то системное умолчание для параметра памяти INITIAL равно 10240 байт. Если при создании табличного пространства вы специфицируете его параметр INITIAL как 20000 (байт), то ORACLE автоматически округляет это значение вверх до 20480 (10 блоков данных). </p><p align="justify" class="note-source">     <b>NEXT </b>- размер, в байтах, следующего (инкрементального) экстента, распределяемого для сегмента. Второй экстент сегмента будет равен заданному значению NEXT . После этого, каждое очередное значение NEXT будет вычисляться как предыдущее значение NEXT , умноженное на (1 + PCTINCREASE /100) . </p><p align="justify" class="note-source">     <i>Умолчание</i>: 5 блоков данных. </p><p align="justify" class="note-source">     <i>Минимум</i>: 1 блок данных. </p><p align="justify" class="note-source">     <i>Максимум</i>: зависит от операционной системы. </p><p align="justify" class="note-source">     Как и для INITIAL , хотя системные умолчания приведены в блоках данных, при задании этого значения используйте байты. Можно применять сокращения К или М для обозначения кило- и мегабайтов. Заданное значение округляется ВВЕРХ до ближайшего кратного размеру блока данных, который определяется параметром DB _ BLOCK _ SIZE . </p><p align="justify" class="note-source">     <b>MAXEXTENTS </b>- общее число экстентов, включая начальный, которое может быть распределено для сегмента. </p><p align="justify" class="note-source">     <i>Умолчание</i>: зависит от размера блока данных и от операционной системы </p><p align="justify" class="note-source">     <i>Минимум</i>: 1 (экстент). </p><p align="justify" class="note-source">     <i>Максимум</i>: зависит от операционной системы. </p><p align="justify" class="note-source"></p><p align="justify" class="note-source">     <b>MINEXTENTS </b>- общее число экстентов, которое должно быть распределено для сегмента при его создании. Это позволяет распределять большое количество памяти во время создания, даже если непрерывного пространства нет.      </p><p align="justify" class="note-source">     <i>Умолчание</i>: 1 (экстент). </p><p align="justify" class="note-source">     <i>Минимум</i>: 1 (экстент). </p><p align="justify" class="note-source">     <i>Максимум</i>: зависит от операционной системы. </p><p align="justify" class="note-source">     Если MINEXTENTS больше 1, то во время создания сегмента ему распределяется необходимое число инкрементальных экстентов, с использованием значений INITIAL , NEXT и PCTINCREASE . </p><p align="justify" class="note-source">     Умалчиваемое и минимальное значения MINEXTENTS для сегмента отката всегда равно 2. Вы можете захотеть увеличить значение MINEXTENTS , когда создаете сегмент отката, или если ваша база данных фрагментирована, а вы хотите гарантировать, что у вас хватит места для загрузки всех данных для одной таблицы. </p><p align="justify" class="note-source">     <b>PCTINCREASE </b>- процент, на который увеличивается каждый следующий инкрементальный экстент по отношению к предыдущему инкрементальному экстенту, распределенному для сегмента. Если PCTINCREASE равен 0, то все инкрементальные сегменты будут одного размера. Если PCTINCREASE больше 0, то каждое очередное значение NEXT увеличивается на PCTINCREASE процентов. Значение PCTINCREASE не может быть отрицательным. </p><p align="justify" class="note-source">     Очередное значение NEXT вычисляется как предыдущее значение NEXT , умноженное на (1 + PCTINCREASE /100) и округленное ВВЕРХ до ближайшего кратного размеру блока данных. </p><p align="justify" class="note-source">     <i>Умолчание</i>: 50 (%). </p><p align="justify" class="note-source">     <i>Минимум</i>: 0 (%). </p><p align="justify" class="note-source">     <i>Максимум</i>: зависит от операционной системы. </p><p align="justify" class="note-source">     Для сегментов отката PCTINCREASE всегда имеет нулевое значение. Нельзя задавать PCTINCREASE для сегментов отката. </p><p align="justify" class="note-source">     За счет корректного применения PCTINCREASE вы можете уменьшить фрагментацию сегмента, увеличивая размеры инкрементальных экстентов и сокращая общее число экстентов, распределяемых для сегмента. Сегмент будет содержать меньшее число экстентов большего размера, нежели большее число экстентов меньшего размера. </p><p align="justify" class="note-source">     Если вы измените значение PCTINCREASE для сегмента, то текущее значение NEXT для этого сегмента не измениться; ваше значение повлияет лишь на последующие значения NEXT . </p><p align="justify" class="note-source">     <b>INITRANS </b>- резервирует предопределенный объем памяти для начального числа записей транзакций, которые будут одновременно обращаться к строкам в блоке данных. Память резервируется в заголовках всех блоков данных в ассоциированном сегменте данных для индекса. <i>Умалчиваемое значение </i>равно 1 для таблиц (1*23 байта = 23 байта), и 2 для кластеров и индексов. </p><p align="justify" class="note-source">     <b>MAXTRANS </b>. Когда несколько транзакций одновременно обращаются к строкам одного и того же блока данных, для записи каждой транзакции в блоке распределяется память. После исчерпания памяти, зарезервированной параметром INITRANS , память для дополнительных записей транзакций распределяется из свободной памяти блока, если возможно. После распределения эта память фактически становиться постоянной частью заголовка блока. Параметр MAXTRANS служит для того, чтобы ограничить число записей транзакций, которые могут одновременно использовать данные в блоке данных. Этот параметр лимитирует количество свободной памяти, которая может быть распределена для записей транзакций в блоке данных. <i>Умалчиваемое значение </i>зависит от операционной системы и от размера блока, и не превышает 255. </p><p align="justify" class="note-source">     Если значение MAXTRANS слишком мало, транзакции, блокированные этим лимитом, должны ожидать, пока другие транзакции завершаться и освободят им место для записей транзакций. Например, если MAXTRANS равно 3, и блок данных уже используется тремя активными транзакциями, то четвертая транзакция, обратившаяся к этому же блоку, будет блокирована до завершения одной из первых трех транзакций. </p></div></div><span id="lnk64db4a177d04401da41aa4c97b3b28d6"> </span><h2 align="left" class="paragraph-headline-source">     Привилегии, требуемые для создания таблиц</h2><span id="lnkf8f4d2d0f2984f1898fd233298d0d716"> </span><div class="section"><p align="justify" class="paragraph-source">     Чтобы создать новую таблицу в собственной схеме, пользователь должен иметь системную привилегию CREATE TABLE. Чтобы создать таблицу в схеме другого пользователя, пользователь должен иметь системную привилегию CREATE ANY TABLE. Кроме того, владелец таблицы должен иметь квоту для табличного пространства, в котором содержится таблица, либо системную привилегию UNLIMITED TABLESPACE.</p></div><span id="lnk93a55e5c1a184c6181bbb03c2cbc77c8"> </span><h2 align="left" class="paragraph-headline-source">     Изменение таблиц</h2><span id="lnk33eb5940fe174a64a6117f35e8f43d66"> </span><div class="section"><p align="justify" class="paragraph-source">     Существуют следующие причины, которые могут потребовать изменения таблицы в базе данных ORACLE:</p><p align="justify" class="paragraph-source">     - чтобы добавить один или несколько новых столбцов;</p><p align="justify" class="paragraph-source">     - чтобы добавить одно или несколько ограничений целостности;</p><p align="justify" class="paragraph-source">     - чтобы модифицировать определение существующего столбца (тип данных, длину, умалчиваемое значение или ограничение целостности NOT NULL);</p><p align="justify" class="paragraph-source">     - чтобы модифицировать параметры использования памяти блока данных таблицы (PCTFREE, PCTUSED);</p><p align="justify" class="paragraph-source">     - чтобы модифицировать характеристики записей транзакций (INITRANS, MAXTRANS);</p><p align="justify" class="paragraph-source">     - чтобы модифицировать параметры памяти (NEXT, PCTINCREASE и т.п.);</p><p align="justify" class="paragraph-source">     - чтобы включить или выключить ограничения целостности или триггеры, ассоциированные с таблицей;</p><p align="justify" class="paragraph-source">     - чтобы удалить ограничения целостности, ассоциированные с таблицей.</p><p align="justify" class="paragraph-source">     При изменении определений столбцов в таблице, вы можете лишь увеличить длину существующего столбца; вы можете уменьшить ее лишь в том случае, если таблица пуста. </p><p align="justify" class="paragraph-source">     Более того, если вы увеличиваете длину столбца с типом данных CHAR, вы должны понимать, что эта операция может потребовать значительного времени и существенной дополнительной памяти, особенно если таблица содержит много строк. Причина в том, что значение CHAR в каждой строке должно быть дополнено пробелами до новой длины столбца.</p><p align="justify" class="paragraph-source">     Для изменения таблицы используется команда SQL ALTER TABLE. Например, следующее предложение изменяет таблицу EMP:</p><p align="justify" class="paragraph-source"></p><p align="justify" class="paragraph-source">ALTER TABLE emp PCTFREE 30 PCTUSED 60;</p></div><span id="lnk4e365f0413574b4a97b9f4e9319631c2"> </span><table class="note"><tr><td><p align="justify" class="note-source">     Последствия изменения таблицы:</p><p align="justify" class="note-source">     - Если к таблице добавляется новый столбец, то изначально он пуст. Вы можете добавить новый столбец с ограничением NOT NULL лишь в том случае, если в таблице нет ни одной строки.</p><p align="justify" class="note-source">     - Если обзор или программная единица PL/SQL зависят от базовой таблицы, то изменение этой базовой таблицы может повлиять на зависимый объект, и всегда делает этот зависимый объект недействительным.</p></td><th><img src="../../00/styles/files/note_important.png" title="Важно" alt="Важно" /></th></tr></table><span id="lnk7be0947a7e634aceb25e3c26b42c2a1f"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Привилегии, требуемые для изменения таблиц</b></p></div><span id="lnkc17b5371add346dd9a442091a0ba647d"> </span><div class="section"><p align="justify" class="paragraph-source">     Чтобы изменить таблицу, либо она должна содержаться в собственной схеме пользователя, либо пользователь должен иметь объектную привилегию ALTER для этой таблицы, или системную привилегию ALTER ANY TABLE.</p></div><span id="lnk8022e6108ec34e3f8f685ab9d03fb75c"> </span><h2 align="left" class="paragraph-headline-source">     Удаление таблиц</h2><span id="lnkf4f38165e3fe48aaa084cec0c28cbb50"> </span><div class="section"><p align="justify" class="paragraph-source">     Для удаления ненужной таблицы, используется команду SQL DROP TABLE. Например, следующее предложение удаляет таблицу EMP:</p><p align="justify" class="paragraph-source"></p><p align="justify" class="paragraph-source">DROP TABLE emp;</p><p align="justify" class="paragraph-source"></p><p align="justify" class="paragraph-source">     Если удаляемая таблица содержит первичный или уникальный ключ, на который ссылаются внешние ключи других таблиц, то вы можете одновременно с этой таблицей удалить ограничения FOREIGN KEY для порожденных таблиц, включив в команду DROP TABLE опцию CASCADE, например:</p><p align="justify" class="paragraph-source">     </p><p align="justify" class="paragraph-source">DROP TABLE emp CASCADE CONSTRAINTS;</p></div><span id="lnk771815fafbf24528a0a06033edf2dd16"> </span><table class="note"><tr><td><p align="justify" class="note-source">     Эффекты удаления таблицы:</p><p align="justify" class="note-source">     - Удаление таблицы приводит к удалению ее определения из словаря данных. Все строки таблицы необратимо теряются. </p><p align="justify" class="note-source">     - Все индексы и триггеры, ассоциированные с таблицей, также удаляются. </p><p align="justify" class="note-source">     - Все обзоры и программные единицы PL/SQL, зависимые от удаляемой таблицы, остаются, но становятся недействительными (непригодными для использования). </p><p align="justify" class="note-source">     - Все синонимы удаленной таблицы остаются, но возвращают ошибку при обращении к ним. </p><p align="justify" class="note-source">     - Все экстенты, распределенные удаляемой некластеризованной таблице, возвращаются в свободную память табличного пространства и могут использоваться любым другим объектом, требующим новых экстентов. </p></td><th><img src="../../00/styles/files/note_important.png" title="Важно" alt="Важно" /></th></tr></table><span id="lnk8a2706b82fa54e6a9feafa5fd5a7ffee"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Привилегии, требуемые для удаления таблиц</b></p></div><span id="lnkf148a12a43774755b598efe2b56214d9"> </span><div class="section"><p align="justify" class="paragraph-source">     Чтобы удалить таблицу, либо она должна содержаться в собственной схеме пользователя, либо пользователь должен иметь системную привилегию DROP ANY TABLE.</p></div><span id="lnk134e18b6db2b4559a0e21dadba2ff0d0"> </span><h2 align="left" class="paragraph-headline-source">     Формат и размер строки</h2><span id="lnkc83edc8962214ab78b74ade63e407633"> </span><div class="section"><p align="justify" class="paragraph-source">     Каждая строка таблицы базы данных хранится как один или несколько кусков строки. Если вся строка может быть вставлена в один блок данных, она первоначально вставляется как единственный кусок. Однако, если все данные в строке не могут быть вставлены в один блок данных, или если в результате обновления строки ее данные переполняют ее блок данных, то строка сохраняется как несколько кусков. Блок данных обычно содержит лишь один кусок для каждой строки данных; все данные строки, которые умещаются в блоке, хранятся в одном куске строки внутри блока. Когда требуется разбить строку на несколько кусков, образуется "цепочка" из кусков этой строки, размещенных в нескольких блоках данных. Куски строки логически сцепляются через идентификаторы строки (ROWID'ы). </p><p align="justify" class="paragraph-source">     Каждый кусок строки, в цепочке он или нет, содержит заголовок строки и данные для всех или некоторых столбцов строки. Индивидуальные значения столбцов также могут занимать несколько кусков строки и, следовательно, блоков данных. </p></div><span id="lnk17d9a1a66504413ba07c085fcf2f8783"> </span><div class="section"><p align="justify" class="paragraph-source">     Заголовок строки предшествует данным строки и содержит следующую информацию:</p><p align="justify" class="paragraph-source">     - информацию об этом куске строки;</p><p align="justify" class="paragraph-source">     - информацию о цепочке, если этот кусок в цепочке;</p><p align="justify" class="paragraph-source">     - информацию о столбцах в этом куске строки.</p></div><span id="lnk7aa0a8bbc9e240b49069e3f2e36ea3d3"> </span><div class="section"><p align="justify" class="paragraph-source">     Строка, полностью умещающаяся в одном блоке, имеет не менее чем трехбайтовый заголовок строки. Вслед за информацией заголовка строки каждая строка содержит информацию о столбцах и данные столбцов. На длину столбца требуется один байт, если эта длина не превышает 250 байт, или три байта для столбцов, содержащих более 250 байт; это поле длины столбца непосредственно предшествует данным столбца. Память, занимаемая данными столбца, зависит от типа данных столбца. Если столбец имеет переменную длину, то место, занимаемое значением столбца, может уменьшаться и увеличиваться при обновлениях.</p><p align="justify" class="paragraph-source">     Для экономии места, строка, содержащая только пустые значения, хранится только как нулевая длина столбца, без данных.</p></div><span id="lnkc26ed89076274f93befcd7d09673a87b"> </span><table class="note"><tr><td><p align="justify" class="note-source">      На каждую строку используется два байта в оглавлении строк в заголовке блока данных.</p></td><th><img src="../../00/styles/files/note_comment.png" title="" alt="" /></th></tr></table><span id="lnk0bb8e716b17045399dcd59e2e84038ff"> </span><h2 align="left" class="paragraph-headline-source">     Порядок столбцов</h2><span id="lnk425e1ffd5b25468fbde46c98ae89fdc6"> </span><div class="section"><p align="justify" class="paragraph-source">     Порядок столбцов один и тот же для всех строк в данной таблице. Столбцы обычно хранятся в том порядке, в котором они были перечислены в предложении CREATE TABLE, но это не гарантируется. Например, если вы создаете таблицу со столбцом типа LONG, то ORACLE всегда размещает этот столбец последним. Кроме того, если таблица изменяется так, что к ней добавляется новый столбец, то этот новый столбец становится последним хранящимся столбцом.</p><p align="justify" class="paragraph-source">     В общем случае, вы должны стараться последними размещать те столбцы, которые часто содержат пустые значения, с тем, чтобы строки занимали меньше места. Заметьте, однако, что, если ваша таблица содержит столбец типа LONG, то преимущества от перемещения таких пустых столбцов теряются.</p></div><span id="lnk64a5d887a11f48dfbb6e1c6fcbc8c66f"> </span><h2 align="left" class="paragraph-headline-source">     ROWID'ы кусков строк</h2><span id="lnk19b835a313bb4036ba6de98095f65a58"> </span><div class="section"><p align="justify" class="paragraph-source">     Каждый кусок строки идентифицируется ее адресом, который называется ROWID. Однажды назначенный ROWID сохраняется за всеми кусками данной строки до тех пор, пока строка не будет удалена, или экспортирована и импортирована с помощью утилит EXPORT и IMPORT. </p><p align="justify" class="paragraph-source">     Поскольку ROWID является постоянным на все время жизни (куска) строки, к нему можно обращаться в предложениях SQL, и он может оказаться полезным в предложениях SELECT, UPDATE и DELETE. </p></div><span id="lnk3f85e054b15d4ec78f3807127b1849c9"> </span><h2 align="left" class="paragraph-headline-source">     Пустые значения</h2><span id="lnk6d3c3dcd610743e6874dfb6c00624102"> </span><div class="section"><p align="justify" class="paragraph-source">     NULL, или пустое значение, обозначает отсутствие значения в столбце строки. Пустые значения указывают на то, что данные отсутствуют, неизвестны или неприменимы. Пустое значение не может подразумевать никакого значения, в том числе нулевого. Столбец может содержать пустые значения, если для него не было определено ограничение целостности NOT NULL; в этом случае в таблицу нельзя вставить строку, которая содержала бы пустое значение для данного столбца.</p><p align="justify" class="paragraph-source">     Пустые значения хранятся в базе данных, если они попадают между столбцами, имеющими значения. В таких случаях пустое значение занимает один байт. Хвостовые пустые значения не хранятся и не занимают памяти. В таблицах, содержащих много столбцов, те столбцы, которые чаще всего будут пустыми, следует определять в конце, чтобы сэкономить дисковую память.</p><p align="justify" class="paragraph-source">     Пустые значения распознаются в SQL через предикат IS NULL. Функция SQL с именем NVL может использоваться, чтобы преобразовывать пустые значения в непустые. Пустые значения не индексируются, исключая случай, когда столбец ключа кластера имеет пустое значение.</p></div><span id="lnk544b9d498b6b4819b2aead02ead09815"> </span><h2 align="left" class="paragraph-headline-source">     Умалчиваемые значения столбцов</h2><span id="lnk9bd56136b9934a71a58023d3a00277b9"> </span><div class="section"><p align="justify" class="paragraph-source">     Столбцу таблицы может быть назначено умалчиваемое значение, так что при вставке в таблицу новой строки, если значение этого столбца опущено, ему будет автоматически присваиваться значение по умолчанию. Умалчиваемые значения столбцов работают так, как если бы они были явно специфицированы в предложении INSERT.</p><p align="justify" class="paragraph-source">     Допустимыми умалчивамыми значениями могут быть литералы или выражения, не ссылающиеся на столбец. Умалчиваемые значения могут включать функции SYSDATE, USER, USERENV. Тип данных умалчиваемого литерала или выражения должен быть преобразуемым в тип данных столбца.</p><p align="justify" class="paragraph-source">     Если для столбца явно не определено умалчиваемое значение, то умолчанием для столбца неявно становится пустое значение (NULL).</p></div><span id="lnkeffa750932ec4bde903a38c8eb2cb355"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Умалчиваемые значения столбцов и ограничения целостности</b></p></div><span id="lnkea78c23dd5034262ab87ac1ac5d1de2e"> </span><div class="section"><p align="justify" class="paragraph-source">     Проверка ограничений целостности происходит после вставки строки с умалчиваемыми значениями для столбцов. </p></div><span id="lnke8243ee528874bbf939a72fe9b7bad1f"> </span><table class="note"><tr><td><p align="justify" class="note-source">     Рекомендации по созданию таблиц:</p><p align="justify" class="note-source">     - Используйте описательные имена для таблиц, индексов и кластеров.</p><p align="justify" class="note-source">     - Согласовывайте сокращения, а также единственную и множественную формы имен таблиц и столбцов.</p><p align="justify" class="note-source">     - Документируйте назначение каждой таблицы и ее столбцов с помощью команды COMMENT.</p><p align="justify" class="note-source">     - Нормализуйте каждую таблицу.</p><p align="justify" class="note-source">     - Выберите правильный тип данных для каждого столбца.</p><p align="justify" class="note-source">     - Определяйте столбцы, которые допускают пустые значения, последними, чтобы экономить дисковую память.</p><p align="justify" class="note-source">     - Кластеризуйте таблицы, когда это целесообразно, чтобы экономить дисковую память и оптимизировать производительность ваших предложений SQL.</p><p align="justify" class="note-source">     Прежде чем создавать таблицу, вы должны также определить, будете ли вы использовать ограничения целостности. Ограничения целостности могут быть определены по столбцам вашей таблицы для того, чтобы автоматически задействовать организационные правила вашей базы данных.</p></td><th><img src="../../00/styles/files/note_important.png" title="Важно" alt="Важно" /></th></tr></table><span id="lnk0a98e82c07ea4f10a141442fa1ff0dbd"> </span><div class="section"><p align="left" class="paragraph-source">     Примеры создания таблиц приведены в <a title="" target="_self" href="../../02/content/example1.html#lnk860ad04f433347f490cfaab67a79fa63">практическом задании</a>.</p></div></div></td></tr></table></td></tr><tr><td id="bottomOuter"><table id="bottomInner"><tr><td class="cell1"><div> </div></td><td class="cell2"><div>© 2012 ХНУРЭ, ПИ, Широкопетлева М.С., <a href="mailto:mshirokopetleva@gmail.com">mshirokopetleva@gmail.com</a>;   ХНУРЭ, ПИ, Черепанова Ю.Ю.;   ХНУРЭ, ПИ, Мазурова О.А.<br /><a href="http://lersus.de/" title="Данный курс создан с помощью авторской системы LERSUS" target="_blank">Разработано с помощью LERSUS</a></div></td></tr></table></td></tr></table></body></html>