<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="LERSUS 3.3.0.0" /><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Корпоративные информационные системы — Теория — Объекты базы данных</title><script language="javascript" type="text/javascript" src="../../00/styles/files/apiwrapper.js"> </script><script language="javascript" type="text/javascript" src="../../00/styles/files/sco.js"> </script><link href="../../00/styles/files/style.css" rel="stylesheet" type="text/css" /></head><body><table id="mainOuter"><tr><td id="topOuter"><table id="topInner"><tr class="row1"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4" id="shortcuts"><div><ul class="level0"><li><a href="../../00/content/authors1.html">Авторы</a></li><li>|</li><li><a href="../../00/content/contacts1.html">Контакты</a></li><li>|</li><li><a href="../../00/content/instructions1.html">Методические указания</a></li><li>|</li><li><a href="../../00/content/annotation1.html">Аннотация</a></li><li>|</li><li><a href="#" onclick="history.back(); return false;">Назад</a></li></ul></div></td></tr><tr class="row2"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4"><div id="courseTitle">Корпоративные информационные системы</div><div id="courseSubTitle">Физическая организация БД на примере СУБД Oracle : Объекты базы данных</div></td></tr></table></td></tr><tr><td id="contentOuter"><table id="contentInner"><tr><td class="menuOuter"><table class="menuInner"><tr><td><ul class="level0"><li><a href="../../00/styles/courses.html">Содержание курса</a></li><li><span>Теория</span></li><ul class="level1"><li><a href="../../02/content/content1.html">Основные концепции СУБД Oracle</a></li><li><a href="../../02/content/content2.html">Логическая структура</a></li><li><a href="../../02/content/content3.html">Экстенты и сегменты</a></li><li><a href="../../02/content/content4.html">Табличные пространства и файлы данных </a></li><li><a href="../../02/content/content5.html">Процессы инстанции Oracle </a></li><li><a href="../../02/content/content6.html">Структуры памяти ORACLE</a></li><li><a href="../../02/content/content7.html">Создание таблиц с распределением памяти </a></li><li><a href="../../02/content/content8.html">Объекты базы данных</a></li><li><a href="../../02/content/content9.html">Утилита SQL*Plus</a></li><li><a href="../../02/content/content10.html">Работа со словарем данных</a></li><li><a href="../../02/content/content11.html">Введение в аудитинг</a></li></ul><li><span>Практика</span></li><ul class="level1"><li><a href="../../02/content/example1.html">Практика 1. Настройка структур памяти при создании основных объектов БД</a></li><li><a href="../../02/content/example2.html">Лабораторная работа 1. Работа с основными объектами базы и служебной информацией</a></li></ul><li><span>Текущий контроль знаний</span></li><ul class="level1"><li><a href="../../02/content/multiply-choice-test1.html">Введение в сервер Oracle</a></li><li><a href="../../02/content/multiply-choice-test9.html">Объекты схемы базы данных Oracle</a></li></ul><li><a href="../../02/styles/glossary.html">Словарь терминов</a></li><li><a href="../../02/02.pdf" target="_blank">Версия для печати</a></li></ul></td></tr></table></td><td class="content"><div id="content"><div id="topBlankStripe"> </div><span id="lnk0e5663247d2e436ca597b3a0a2a5a680"> </span><h1 align="left" class="headline-source">     Объекты базы данных</h1><span id="lnkc3714c38de0c4c0a87d4f3f99b975377"> </span><h2 align="left" class="paragraph-headline-source">     Обзоры (представления)</h2><span id="lnk31756a34c82943f58727399eaa0e392f"> </span><div class="section"><p align="justify" class="paragraph-source">     Обзор, представления (VIEW) - это настроенное представление данных, содержащихся в одной или нескольких таблицах (или других обзорах). Обзор определяется с использованием запроса, и поэтому о нем можно думать как о "хранимом запросе" или о "виртуальной таблице". Обзоры можно использовать в большинстве мест, где могут использоваться таблицы.</p><p align="justify" class="paragraph-source">     Например, таблица имеет несколько столбцов и много строк информации. Если вы хотите, чтобы пользователи видели лишь несколько из этих столбцов, или лишь определенные строки, вы можете создать по этой таблице обзор, к которому будут обращаться пользователи. </p></div><span id="lnkba44a0b006174145960036ea6ddd2ad6"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Создание обзоров</b></p></div><span id="lnkad5db80f39a944ca9a9773565365ee80"> </span><div class="section"><p align="justify" class="paragraph-source">     Создавайте обзоры с помощью команды SQL CREATE VIEW. Вы можете определять обзоры посредством любого запроса, который обращается к таблицам, снимкам или другим обзорам; однако запрос, определяющий обзор, может содержать фразы ORDER BY или FOR UPDATE. </p><p align="justify" class="paragraph-source">     Например, вы можете создать представление, которое содержит информацию о товарах производителя «HONDA», цена которых выше средней цены по товарам в магазине:</p></div><span id="lnk005ff7e93dc84a3d8cdfe0d3cfc2c9d1"> </span><div class="section"><p align="justify" class="paragraph-source">CREATE VIEW HONDA_PRODUCT AS </p><p align="justify" class="paragraph-source">SELECT PRODUCT_NAME, PRICE FROM PRODUCTS WHERE MFR=HONDA AND PRICE &gt; (SELECT MAX(PRICE) FROM PRODUCTS);</p></div><span id="lnke92cb578d7dc4a9eba49f343b6b0d7ce"> </span><div class="section"><p align="justify" class="paragraph-source">     Пользователь сможет получать информацию из представления через достаточно простой запрос:</p></div><span id="lnk8bb14a1c7fb547d2a88ed7784ad8e907"> </span><div class="section"><p align="justify" class="paragraph-source">SELECT * FROM HONDA_PRODUCT;</p></div><span id="lnk4b724b96f9284c40870d3edf985986f1"> </span><div class="section"><p align="justify" class="paragraph-source">     Поскольку обзоры выводятся из таблиц, между обзорами и таблицами много общего. Например, как и таблицы, обзоры могут содержать до 254 столбцов. Обзоры можно опрашивать, а при некоторых ограничениях пользователи могут обновлять обзоры, вставлять в них и удалять из них строки. Все операции, выполняемые на обзоре, в действительности осуществляются над данными базовых таблиц этого обзора, и попадают под действие ограничений целостности и триггеров этих базовых таблиц.</p></div><span id="lnka3e0ad9c2c08479ca37edc5c061cec76"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Пространство для обзоров</b></p></div><span id="lnk9b40085dfbca4f829b46a8bae63226fe"> </span><div class="section"><p align="justify" class="paragraph-source">     В отличие от таблицы, обзору не распределяется пространство в базе данных, и обзор в действительности не содержит никаких данных; скорее, обзор определяется как запрос, соответствующий данным из таблиц, на которые он ссылается. Эти таблицы называются БАЗОВЫМИ ТАБЛИЦАМИ обзора. Базовые таблицы, в свою очередь, могут быть как действительными таблицами, так и другими обзорами (в том числе снимками). Поскольку обзор базируется на других объектах, он не требует иной памяти в словаре данных, помимо той, которая необходима для хранения определения обзора (хранимого запроса).</p></div><span id="lnkb39938b640434e7ba30c466e0a897774"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Как используются обзоры</b></p></div><span id="lnk5395949bc1a24054b56fbcb046b0294b"> </span><div class="section"><p align="justify" class="paragraph-source">     Обзоры дают средство представить данные в иной перспективе, чем они хранятся в базовых таблицах. Обзоры представляют собой очень мощное средство, ибо они позволяют вам настраивать различные представления данных для различных типов пользователей. Обзоры часто используются:</p><p align="justify" class="paragraph-source">     - для обеспечения дополнительного уровня защиты таблицы за счет предоставления доступа к предопределенному множеству строк и/или столбцов таблицы. </p><p align="justify" class="paragraph-source">     - для скрытия сложности данных. Например, обзор может быть определен как соединение, т.е. коллекция связанных столбцов или строк из нескольких таблиц. Однако обзор скрывает тот факт, что эта информация в действительности исходит из нескольких таблиц.</p><p align="justify" class="paragraph-source">     - для упрощения команд для пользователей. Например, обзоры позволяют пользователю выбирать информацию из нескольких таблиц, не зная, как осуществлять операцию соединения.</p><p align="justify" class="paragraph-source">     - для представления данных с иной точки зрения, чем в базовой таблице. Например, столбцы обзора можно переименовать, не затрагивая столбцов базовой таблицы.</p><p align="justify" class="paragraph-source">     - для изоляции приложений от изменений в определениях базовых таблиц. Например, если определяющий запрос обзора обращается к трем столбцам четырехстолбцовой таблицы, и в эту таблицу добавляется пятый столбец, то определение обзора не изменяется, и все приложения, использующие этот обзор, не затрагиваются.</p><p align="justify" class="paragraph-source">     - для формулирования запроса, который нельзя выразить иначе, чем через обзор. Например, можно определить обзор, который соединяет обзор GROUP BY с таблицей, или обзор, который соединяет обзор UNION с таблицей.</p><p align="justify" class="paragraph-source">     - для сохранения сложных запросов. Например, запрос может выполнять обширные вычисления с информацией таблиц. Благодаря сохранению такого запроса как обзора можно гарантировать, что эти вычисления будут выполняться при каждом обращении к обзору.</p></div><span id="lnk75e4e5caa56d4e4d86faf4cecfe4610f"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Механика обзоров</b></p></div><span id="lnk4ee4bf63f3174a76ab1422eb77a836bf"> </span><div class="section"><p align="justify" class="paragraph-source">     Определение обзора представлено хранящимся в словаре данных текстом соответствующего запроса. Когда предложение SQL обращается к обзору, ORACLE осуществляет слияние этого предложения с запросом, определяющим обзор, а затем выполняет синтаксический разбор результирующего предложения в разделяемой области SQL и выполняет его. Разбор предложения, обращающегося к обзору, в новой разделяемой области SQL выполняется лишь в том случае, если ни одна существующая разделяемая область SQL не содержит идентичного предложения. Таким образом, использование обзоров не мешает извлекать выгоду из использования разделяемых областей SQL.</p></div><span id="lnkca0376bdd4b243a39f1a994478fe682a"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Привилегии, требуемые для создания обзоров</b></p></div><span id="lnk7a063259cc21486f8eeec65a0cd4c899"> </span><div class="section"><p align="justify" class="paragraph-source">     Чтобы создать обзор, вы должны удовлетворять следующим требованиям:</p><p align="justify" class="paragraph-source">     - Чтобы создать обзор в вашей схеме, вы должны иметь привилегию CREATE VIEW; чтобы создать обзор в схеме другого пользователя, вы должны иметь системную привилегию CREATE ANY VIEW. Обе эти привилегии могут быть получены вами явно или через роль.</p><p align="justify" class="paragraph-source">     - ВЛАДЕЛЕЦ обзора (т.е. владелец схемы, в которой создается обзор) должен обладать ЯВНО назначенными привилегиями для доступа к объектам, на которые ссылается определение обзора; эти привилегии НЕ МОГУТ быть получены через роль. Кроме того, работоспособность обзора зависит от привилегий владельца этого обзора. Например, если владелец обзора имеет лишь привилегию INSERT для таблицы SCOTT.EMP, то обзор можно использовать лишь для вставки новых строк в таблицу EMP, но не для запросов по этой таблице и не для обновления или удаления строк в ней.</p><p align="justify" class="paragraph-source">     - Если владелец обзора намеревается предоставить доступ к этому обзору другим пользователям, он должен обладать объектными привилегиями для базовых объектов обзора с опцией GRANT OPTION, или системными привилегиями с опцией ADMIN OPTION. </p><p align="justify" class="paragraph-source">     В противном случае владелец не может дать доступ к обзору другим пользователям.</p></div><span id="lnkb5d8670378114ea8b2ddadefc5daab01"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Замена обзоров</b></p></div><span id="lnka4effba2c7914520b5e0f87170871546"> </span><div class="section"><p align="justify" class="paragraph-source">     Если вы хотите изменить определение обзора, то обзор должен быть заменен; нельзя изменить определение обзора командой ALTER. Вы можете заменять обзоры следующими способами:</p><p align="justify" class="paragraph-source">     - Вы можете удалить и заново создать обзор. Когда обзор удаляется, все гранты на соответствующие объектные привилегии отзываются от ролей и от пользователей. После пересоздания обзора все привилегии должны быть назначены заново.</p><p align="justify" class="paragraph-source">     - Вы можете переопределить обзор с помощью предложения CREATE VIEW с опцией OR REPLACE. Эта опция заменяет текущее определение обзора и не затрагивает текущих полномочий. </p><p align="justify" class="paragraph-source">     Прежде чем заменять обзор, примите во внимание следующие эффекты:</p><p align="justify" class="paragraph-source">     - Замена обзора лишь заменяет его определение в словаре данных. Никакие объекты, на которые ссылается обзор, не затрагиваются.</p><p align="justify" class="paragraph-source">     - Если ограничение в опции CHECK OPTION ранее было определено, но не включается в новое определение обзора, то это ограничение удаляется.     </p><p align="justify" class="paragraph-source">     - Все обзоры и программные единицы PL/SQL, зависимые от заменяемого обзора, становятся недействительными (непригодными для использования).</p></div><span id="lnke7a8a4fac19d46d184ebff02b6689b1f"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Привилегии, требуемые для замены обзора</b></p></div><span id="lnk00c7e973d7eb47179f5e799e86bca6f8"> </span><div class="section"><p align="justify" class="paragraph-source">     Чтобы заменить обзор, вы должны иметь все привилегии, необходимые для удаления и создания обзора.</p></div><span id="lnk9c539610b59d44b3a04849c74b499350"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Удаление обзоров</b></p></div><span id="lnkc2af19a02a874f68b4875faf87587f9c"> </span><div class="section"><p align="justify" class="paragraph-source">     Удаляйте обзор с помощью команды SQL DROP VIEW. Например, следующее предложение удаляет обзор с именем SALES_STAFF:</p><p align="justify" class="paragraph-source">DROP VIEW sales_staff;</p></div><span id="lnk4e5a8b33113f46b4990c826823d333d4"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Привилегии, требуемые для удаления обзора</b></p></div><span id="lnk44d8b5dfe4e444e0b695af3486efeef9"> </span><div class="section"><p align="justify" class="paragraph-source">     Вы можете удалять любой обзор, содержащийся в вашей схеме. Чтобы удалить обзор в схеме другого пользователя, вы должны иметь системную привилегию DROP ANY VIEW.</p></div><span id="lnk8b0367462ea14c1d81cfbf20fa5da2d9"> </span><h2 align="left" class="paragraph-headline-source">     Синонимы</h2><span id="lnk1a4890dac4bd4d59bde392723e244edf"> </span><div class="section"><p align="justify" class="paragraph-source">     <i><b>Синоним </b></i>- это алиас (псевдоним) таблицы, обзора, снимка, последовательности, процедуры, функции или пакета. Поскольку синоним - это лишь алиас, он не требует памяти, помимо своего определения в словаре данных.</p><p align="justify" class="paragraph-source">     Создавайте синоним с помощью команды SQL CREATE SYNONYM.</p></div><span id="lnk170fa716308648e481bd3b005bb7fd41"> </span><div class="section"><p align="justify" class="paragraph-source">     Синонимы часто используются для безопасности и для удобства. Например, они могут делать следующее:</p><p align="justify" class="paragraph-source">     - маскировать имя владельца объекта;</p><p align="justify" class="paragraph-source">CREATE SYNONYM tab1 ON DIANA.MANUFACTURERS;</p><p align="justify" class="paragraph-source">     - обеспечивать прозрачность местоположения для удаленных объектов в распределенной базе данных;</p><p align="justify" class="paragraph-source">CREATE SYNONYM tab2 ON CLARC.PRODUCTS@NEWYORK;</p><p align="justify" class="paragraph-source">     - упрощать предложения SQL для пользователей базы данных.</p><p align="justify" class="paragraph-source">SELECT * FROM tab1;</p></div><span id="lnk8ea80e9fd5874741bbfbe0ec282f6fa0"> </span><div class="section"><p align="justify" class="paragraph-source">     Синонимы могут быть общими и личными. </p><p align="justify" class="paragraph-source">     <i><b>Общий </b></i>синоним принадлежит специальной группе пользователей с именем PUBLIC и доступен любому пользователю в базе данных. </p><p align="justify" class="paragraph-source">     <i><b>Личный</b></i> синоним содержится в схеме конкретного пользователя, и доступен только этому пользователю и тем, кому он дал это право.</p><p align="justify" class="paragraph-source">     Синонимы очень полезны как в распределенных, так и в нераспределенных окружениях баз данных, потому что они скрывают идентичность объекта, включая его местоположение в распределенной системе. Это выгодно, потому что в случае необходимости переименования или перемещения объекта достаточно переопределить лишь его синоним, а приложения, опирающиеся на этот синоним, продолжают функционировать без модификации.</p><p align="justify" class="paragraph-source">     Синонимы также упрощают предложения SQL для пользователей в распределенной системе баз данных. Следующий пример показывает, как и почему общие синонимы часто создаются администратором базы данных, чтобы скрыть идентичность базовой таблицы и упростить предложения SQL. </p></div><span id="lnk2ecddb4a209e436a872d7d1416ae2752"> </span><div class="section"><p align="justify" class="paragraph-source">     Предположим следующее:</p><p align="justify" class="paragraph-source">     - Существует таблица с именем SALES_DATA, содержащаяся в схеме пользователя с именем JWARD.</p><p align="justify" class="paragraph-source">     - Привилегия SELECT для таблицы SALES_DATA предоставлена всем пользователям (PUBLIC).</p><p align="justify" class="paragraph-source"></p><p align="justify" class="paragraph-source">     Допустим, пользователь базы данных должен опросить таблицу SALES_DATA с помощью предложения SQL, аналогичного следующему:</p><p align="justify" class="paragraph-source"></p><p align="justify" class="paragraph-source">SELECT * FROM jward.sales_data;</p><p align="justify" class="paragraph-source">     Заметьте, что для выполнения запроса необходимо указать как схему, содержащую таблицу, так и имя таблицы.</p></div><span id="lnka749f10f52944c03a39b682b9cb47542"> </span><div class="section"><p align="justify" class="paragraph-source">     Предположим, что АБД создает общий синоним с помощью следующего предложения SQL:</p><p align="justify" class="paragraph-source"></p><p align="justify" class="paragraph-source">CREATE PUBLIC SYNONYM sales FOR jward.sales_data;</p><p align="justify" class="paragraph-source"></p><p align="justify" class="paragraph-source">     После того как создан общий синоним, пользователь может опрашивать таблицу SALES_DATA простым предложением SQL:</p><p align="justify" class="paragraph-source"></p><p align="justify" class="paragraph-source">SELECT * FROM sales;</p><p align="justify" class="paragraph-source"></p><p align="justify" class="paragraph-source">     Заметьте, что общий синоним SALES скрывает как имя таблицы SALES_DATA, так и имя схемы, в которой содержится эта таблица.</p></div><span id="lnk00f07729eb1643a383bff9149d2f378f"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Удаление синонимов</b></p></div><span id="lnke85ffbbde3f242c4b18c5f1b49c0325c"> </span><div class="section"><p align="justify" class="paragraph-source">     Чтобы удалить ненужный синоним, используйте команду SQL DROP SYNONYM. При удалении личного синонима опустите ключевое слово PUBLIC; при удалении общего синонима укажите ключевое слово PUBLIC. Например, следующее предложение удаляет личный синоним с именем EMP:</p><p align="justify" class="paragraph-source"></p><p align="justify" class="paragraph-source">DROP SYNONYM emp;</p><p align="justify" class="paragraph-source"></p><p align="justify" class="paragraph-source">     Следующее предложение удаляет общий синоним с именем PUBLIC_EMP:</p><p align="justify" class="paragraph-source"></p><p align="justify" class="paragraph-source">DROP PUBLIC SYNONYM public_emp;</p><p align="justify" class="paragraph-source">     </p><p align="justify" class="paragraph-source">     Когда вы удаляете синоним, его определение удаляется из словаря данных. Все объекты, ссылающиеся на удаленный синоним, остаются, но становятся недействительными.</p></div><span id="lnk8894c2ece33c41e98ec9775aa1ffcddd"> </span><h2 align="left" class="paragraph-headline-source">     Последовательности</h2><span id="lnkc1388b0b8a1b4c8ebe9ec5f06c68d5de"> </span><div class="section"><p align="justify" class="paragraph-source">     <i><b>Последовательность (sequence)</b></i> - это объект базы данных, который генерирует порядковые номера. </p><p align="justify" class="paragraph-source">     При создании последовательности вы можете специфицировать ее начальное значение и приращение. </p></div><span id="lnk59f9a6306b5146aaa904f33ad7ca02fc"> </span><div class="section"><p align="justify" class="paragraph-source">     CURRVAL возвращает текущее значение указанной последовательности. Прежде чем обратиться к CURRVAL в данной сессии, вы должны хотя бы раз обратиться к NEXTVAL, чтобы сгенерировать номер. </p><p align="justify" class="paragraph-source">     Обращение к NEXTVAL записывает текущий порядковый номер в CURRVAL. NEXTVAL выполняет приращение и возвращает очередное значение. Чтобы получить текущее или очередное значение последовательности, вы должны использовать квалифицированную ссылку: </p><p align="justify" class="paragraph-source">имя_последовательности.CURRVAL;</p><p align="justify" class="paragraph-source">имя_последовательности.NEXTVAL .</p></div><span id="lnk1660986e73fe45f89e129b9d55ff4232"> </span><div class="section"><p align="justify" class="paragraph-source">     После создания последовательности вы можете использовать ее для генерации уникальных порядковых номеров для обработки ваших транзакций. В следующем примере последовательность используется для того, чтобы вставить один и тот же номер товара в две таблицы: </p><p align="left" class="paragraph-source">INSERT INTO goods VALUES (goods_seq.NEXTVAL, name1, ...); <br />INSERT INTO storages VALUES (storage_id1, ware_id1, goods_seq.CURRVAL, ...); </p></div><span id="lnk2d440157562649c7bd300c43f4fc0c5b"> </span><div class="section"><p align="justify" class="paragraph-source">     Чтобы обратиться к текущему или следующему значению последовательности, принадлежащей схеме другого пользователя, вы должны иметь любо объектную привилегию SELECT по этой последовательности, либо системную привилегию SELECT ANY SEQUENCE, и должны дополнительно квалифицировать эту последовательность именем содержащей ее схемы: </p><p align="left" class="paragraph-source">     - schema.sequence.CURRVAL ;</p><p align="left" class="paragraph-source">     - schema . sequence . NEXTVAL .</p><p align="left" class="paragraph-source">     </p></div><span id="lnk0937e3f37f72438dbe5cb3a83a6a832b"> </span><div class="section"><p align="justify" class="paragraph-source">     Чтобы обратиться к значению последовательности, расположенной в удаленной базе данных, вы должны квалифицировать эту последовательность полным или частичным именем связи баз данных: </p><p align="left" class="paragraph-source">     - schema . sequence . CURRVAL @ dblink ;</p><p align="left" class="paragraph-source">     - schema . sequence . NEXTVAL @ dblink ;</p></div><span id="lnk21ca5d7206c94de9b94388d439220fbe"> </span><div class="section"><p align="justify" class="paragraph-source">     Вы можете использовать значения CURRVAL и NEXTVAL в следующих местах: </p><p align="left" class="paragraph-source">     - в списке SELECT предложения SELECT; </p><p align="left" class="paragraph-source">     - в фразе VALUES предложения INSERT; </p><p align="left" class="paragraph-source">     - в фразе SET предложения UPDATE. </p></div><span id="lnka7a7ed7a3f674e81b8049d74749ced8f"> </span><div class="section"><p align="justify" class="paragraph-source">     Вы не можете использовать значения CURRVAL и NEXTVAL в следующих местах: </p><p align="justify" class="paragraph-source">     - в подзапросе; </p><p align="justify" class="paragraph-source">     - в запросе обзора или снимка; </p><p align="justify" class="paragraph-source">     - в предложении SELECT с оператором DISTINCT; </p><p align="justify" class="paragraph-source">     - в предложении SELECT с фразой GROUP BY или ORDER BY; </p><p align="justify" class="paragraph-source">     - в предложении SELECT, объединенном с другим предложением SELECT оператором множеств UNION, INTERSECT или MINUS; </p><p align="justify" class="paragraph-source">     - в фразе WHERE предложения SELECT; </p><p align="justify" class="paragraph-source">     - в умалчиваемом (DEFAULT) значении столбца в предложении CREATE TABLE или ALTER TABLE; </p><p align="justify" class="paragraph-source">     - в условии ограничения CHECK . </p></div><span id="lnk25ccd36464514f94823b33674a1114cd"> </span><div class="section"><p align="justify" class="paragraph-source">     При создании последовательности вы можете определить ее начальное значение и приращение между ее значениями. Первое обращение к NEXTVAL возвращает начальное значение последовательности. Последующие обращения к NEXTVAL изменяют значение последовательности на приращение, которое было определено, и возвращают новое значение. Любое обращение к CURRVAL всегда возвращает текущее значение последовательности, а именно, то значение, которое было возвращено последним обращением к NEXTVAL. Заметьте, что, прежде чем обращаться к CURRVAL в вашей сессии, вы должны хотя бы один раз выполнить обращение к NEXTVAL. В одном предложении SQL приращение последовательности может быть выполнено только один раз. Если предложение содержит несколько обращений к NEXTVAL для одной и той же последовательности, то ORACLE наращивает последовательность один раз, и возвращает одно и то же значение для всех вхождений NEXTVAL. Если предложение содержит обращения как к CURRVAL, так и к NEXTVAL, то ORACLE наращивает последовательность и возвращает одно и то же значение как для CURRVAL, так и для NEXTVAL, независимо от того, в каком порядке они встречаются в предложении. К одной и той же последовательности могут обращаться одновременно несколько пользователей, без какого-либо ожидания или блокировки. </p></div><span id="lnkfaa1299a8a604c6aa8aceb5f4cc5866f"> </span><div class="section"><p align="justify" class="paragraph-source">     Следующий пример выбирает текущее значение последовательности (такую команду можно выполнить, например, в утилите SQL * Plus ): </p><p align="left" class="paragraph-source">SELECT goods_seq.currval FROM DUAL </p><p align="justify" class="paragraph-source">     Следующий пример наращивает значение последовательности и использует его для нового товара, вставляемого в таблицу товаров: </p><p align="left" class="paragraph-source">INSERT INTO goods VALUES (goods_seq.nextval, 'dresses', 0.5, dryness', 154) </p><p align="justify" class="paragraph-source">     Следующий пример добавляет новый товар с очередным номером в главную таблицу товаров, а затем добавляет информацию о хранении товара с этим же номером в таблицу с местоположениями товаров: </p><p align="left" class="paragraph-source">INSERT INTO goods VALUES (goods_seq.nextval, 'dresses', 0.5, dryness', 154) <br />INSERT INTO storages VALUES (stor_seq.nextval, ware_id1, goods_seq.nextval, quantity1, SYSDATE, '12.09.04'); </p></div><span id="lnk01e9a99426c241f8ae10c5a44c28ee31"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Команда CREATE SEQUENCE</b></p></div><span id="lnk420b386fa5744992bb203d8b222c4ef1"> </span><div class="section"><p align="justify" class="paragraph-source">      Команда CREATE SEQUENCE создает последовательность. Чтобы создать последовательность в вашей собственной схеме, вы должны иметь привилегию CREATE SEQUENCE. Чтобы создать последовательность в схеме другого пользователя, вы должны иметь привилегию CREATE ANY SEQUENCE. </p><p align="left" class="paragraph-source">     Синтаксис </p><p align="left" class="paragraph-source">CREATE SEQUENCE команда ::= <br />CREATE SEQUENCE последовательность [ схема ] <br />[INCREMENT BY целое ] <br />[START WITH целое ] <br />[MAXVALUE целое | NOMAXVALUE] <br />[MINVALUE целое | NOMINVALUE] <br />[CYCLE | NOCYCLE] <br />[CACHE целое | NOCACHE] <br />[ ORDER | NOORDER]; </p></div><span id="lnk33b9f147240e4cd383d5d3db742588df"> </span><h2 align="left" class="paragraph-headline-source">     Ключевые слова и параметры </h2><span id="lnke540eb33774340b0a56686c4c395d702"> </span><div class="section"><p align="justify" class="paragraph-source">     <b>Схема </b>- схема, в которой создается последовательность. Если СХЕМА опущена, ORACLE создает последовательность в вашей схеме. </p><p align="justify" class="paragraph-source">     <b>Последовательность </b>- имя создаваемой последовательности. </p><p align="justify" class="paragraph-source">     <b>INCREMENT BY</b> специфицирует интервал между значениями (номерами) последовательности. Это значение может быть любым положительным или отрицательным целым числом ORACLE, но не может быть нулевым. Если это значение отрицательно, то последовательность убывает. Если это значение положительно, то последовательность возрастает. Если эта фраза опущена, по умолчанию принимается интервал 1. </p><p align="justify" class="paragraph-source">     <b>MINVALUE </b>задает минимальное значение последовательности. NOMINVALUE указывает, что минимальное значение равно 1, если последовательность возрастает, или -10----26, если последовательность убывает. </p><p align="justify" class="paragraph-source">     <b>MAXVALUE </b>задает максимальное значение, которое может быть сгенерировано последовательностью. NOMAXVALUE указывает, что максимальное значение равно 10----27, если последовательность возрастает, или -1, если последовательность убывает. По умолчанию принимается NOMAXVALUE. </p><p align="justify" class="paragraph-source">     <b>START WITH</b> специфицирует первый генерируемый номер последовательности. Вы можете использовать эту опцию, чтобы начать возрастающую последовательность с значения, превышающего ее минимум, или начать убывающую последовательность с значения, которое меньше ее максимума. По умолчанию возрастающая последовательность начинается со своего минимума, а убывающая - со своего максимума. </p><p align="justify" class="paragraph-source">     <b>CYCLE </b>указывает, что последовательность будет продолжать генерировать значения после достижения своего максимума или минимума. Возрастающая последовательность после достижения своего максимума генерирует свой минимум. Убывающая последовательность после достижения своего минимума генерирует свой максимум. NOCYCLE указывает, что последовательность не может продолжать генерировать значения после достижения своего максимума или минимума. По умолчанию принимается NOCYCLE. </p><p align="justify" class="paragraph-source">     <b>CACHE </b>указывает, сколько значений последовательности ORACLE распределяет заранее и поддерживает в памяти для быстрого доступа. Минимальное значение этого параметра равно 2. Для циклических последовательностей это значение должно быть меньше, чем количество значений в цикле. NOCACHE указывает, что значения последовательности не распределяются в памяти. Если опущены как параметр CACHE, так и опция NOCACHE, то ORACLE по умолчанию кэширует 20 номеров последовательности. Однако, если вы используете ORACLE с опцией параллельного сервера в параллельном режиме, и специфицировали опцию ORDER, то значения последовательности никогда не кэшируются, независимо от того, специфицировали ли вы параметр CACHE. </p><p align="justify" class="paragraph-source">     Например, для реализаций на уровне приложений типичным приемом является блокировка таблицы номеров последовательности, приращение номера и освобождение этой таблицы. При такой реализации лишь один номер может быть сгенерирован в каждый момент времени. Напротив, последовательности ORACLE позволяют одновременно генерировать множественные номера последовательностей, в то же время гарантируя уникальность каждого номера. Когда генерируется значение последовательности, выполняется ее приращение, независимо от подтверждения или отката транзакций. Если два пользователя одновременно осуществляют приращение одной и той же последовательности, то номера, которые видит каждый пользователь, могут иметь пропуски, потому что номера генерируются и для другого пользователя. Пользователь никогда не увидит номер последовательности, сгенерированный для другого пользователя. После того, как значение последовательности сгенерировано пользователем, этот пользователь может обращаться к этому значению независимо от того, осуществляет ли приращение последовательности другой пользователь. </p><p align="justify" class="paragraph-source">     Поскольку номера последовательностей генерируются независимо от таблиц, одну и ту же последовательность можно использовать для одной или для многих таблиц. Может оказаться, что отдельные номера последовательности будут пропущены, потому что эти номера были сгенерированы и использованы в транзакции, которая в конечном счете была подвергнута откату. Кроме того, каждый отдельный пользователь может не отдавать себе отчет в том, что другие пользователи черпают значения из той же самой последовательности. </p><p align="justify" class="paragraph-source">     Умолчания последовательности спроектированы таким образом, что, если вы не специфицируете ни одну из фраз в предложении CREATE SEQUENCE, то создадите возрастающую последовательность без верхнего предела, которая начинается с 1 и возрастает с шагом 1. Если вы специфицируете только INCREMENT BY -1, то создадите убывающую последовательность без нижнего предела, которая начинается с -1 и убывает с шагом 1. </p><p align="left" class="paragraph-source">     При создании последовательности вы выбираете один из возможных способов ее приращения: </p><p align="justify" class="paragraph-source">     - Значения последовательности наращиваются безгранично. </p><p align="justify" class="paragraph-source">     - Значения последовательности наращиваются до предопределенной границы, после чего последовательность останавливается. </p><p align="justify" class="paragraph-source">     - Значения последовательности наращиваются до предопределенной границы, после чего последовательность рестартует. </p><p align="justify" class="paragraph-source">     Чтобы создать последовательность, наращиваемую безгранично, опустите параметр MAXVALUE или специфицируйте опцию NOMAXVALUE (для возрастающей последовательности), либо опустите параметр MINVALUE или специфицируйте опцию NOMINVALUE (для убывающей последовательности). </p><p align="justify" class="paragraph-source">     Чтобы создать последовательность, которая останавливается на предопределенной границе, задайте значение для параметра MAXVALUE (для возрастающей последовательности) или MINVALUE (для убывающей последовательности). Кроме того, укажите опцию NOCYCLE. Любая попытка сгенерировать значение последовательности после того, как она достигла своего предела, приведет к ошибке. Чтобы создать последовательность, которая рестартует после предопределенной границы, задайте значение для параметра MAXVALUE или MINVALUE. Кроме того, укажите опцию CYCLE. </p><p align="justify" class="paragraph-source">     Значение параметра START WITH задает начальное значение, которое генерируется после создания последовательности. Заметьте, что это значение не обязательно совпадает с тем, с которого циклическая последовательность будет рестартовать после достижения своего максимума или минимума. </p></div><span id="lnk79182ad20cbd4abcbc23cc49c67ec85c"> </span><h2 align="left" class="paragraph-headline-source">     Индексы</h2><span id="lnk5578c411a44342499b0ac254966158dc"> </span><div class="section"><p align="justify" class="paragraph-source">     <i><b>Индексы </b></i>- это необязательные структуры, ассоциированные с таблицами. Вы можете создавать индексы явно, чтобы ускорять выполнение предложений SQL по таблице. Как индекс в справочнике помогает быстрее найти нужную информацию, так и индекс ORACLE предоставляет более быстрый путь к данным таблицы. При правильном использовании индексы являются главным средством сокращения дискового ввода-вывода.</p><p align="justify" class="paragraph-source">     Наличие или отсутствие индекса не требует никаких изменений в написании предложений SQL. Индекс - это просто более быстрый путь к данным; он влияет лишь на скорость исполнения. При заданном значении данных, индексированных по этим значениям, индекс указывает непосредственно на адреса строк, содержащих это значение.</p><p align="justify" class="paragraph-source">     Индексы логически и физически независимы от данных в ассоциированной таблице. Индексы можно создавать и удалять в любой момент, не затрагивая ни базовых таблиц, ни других индексов. После удаления индекса все приложения по-прежнему будут работать; однако доступ к ранее индексированным данным может замедлиться. Индексы, как независимые структуры, требуют пространства для своего размещения.</p><p align="justify" class="paragraph-source">     Однажды созданный, индекс автоматически поддерживается и используется ORACLE. Изменения в данных, такие как добавление новых строк, обновление строк или удаление строк, автоматически отражаются во всех соответствующих индексах без каких-либо дополнительных действий пользователей.</p><p align="justify" class="paragraph-source">     Производительность извлечения индексированных данных остается почти постоянной, даже по мере вставки новых строк. Однако наличие многих индексов по таблице уменьшает производительность обновлений, удалений и вставок, поскольку индексы, ассоциированные с таблицей, также должны обновляться.</p></div><span id="lnk37d6114a1d4243aea20446d7590826b4"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Уникальные и неуникальные индексы</b></p></div><span id="lnkdbdddf1e450b49ebb2cabc2e43c335e5"> </span><div class="section"><p align="justify" class="paragraph-source">     Индексы могут быть <i><b>уникальными </b></i>или <i><b>неуникальными</b></i>. Уникальные индексы гарантируют, что никакие две строки в таблице не содержат повторяющихся значений в столбце, по которому определен индекс. Неуникальные индексы не налагают такого ограничения на значения столбца.</p><p align="justify" class="paragraph-source">     Хотя это возможно, рекомендуется явно не определять уникальных индексов по таблицам базы данных ORACLE; уникальность - это строго логическое понятие, и она должна ассоциироваться с определением самой таблицы. Вместо этого следует определять ограничение целостности UNIQUE для соответствующих столбцов. ORACLE вводит в действие ограничения целостности UNIQUE путем автоматического определения уникального индекса по уникальному ключу.</p></div><span id="lnk74fa0ebca30c43f88ea6b0cc686324db"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Составные индексы</b></p></div><span id="lnk70e1342da44d4f6f97ce26792ca5d675"> </span><div class="section"><p align="justify" class="paragraph-source">     <i><b>Составной индекс </b></i>(называемый также сцепленным индексом) - это индекс, созданный по нескольким столбцам в таблице. Столбцы в составном индексе могут появляться в любом порядке и не обязаны быть соседними в таблице. Составные индексы могут ускорить извлечение данных предложениями SELECT, в которых фраза WHERE обращается ко всем или к ведущим столбцам в составном индексе. Поэтому выбор порядка столбцов в определении составного индекса требует некоторой мысли; обычно чаще используемые или наиболее селективные столбцы должны идти первыми. </p></div><span id="lnk11ef53c98df344b2ba8acb9570e2934b"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Индексы и ключи</b></p></div><span id="lnk9731e03b725a44eb83aa87d135e1eace"> </span><div class="section"><p align="justify" class="paragraph-source">     Хотя эти термины часто используются вместо друг друга, следует делать различие между "индексами" и "ключами". </p><p align="justify" class="paragraph-source">     <i><b>Индексы</b></i> - это структуры, действительно хранящиеся в базе данных, которые пользователи создают, изменяют и удаляют с помощью предложений SQL. Вы создаете индекс, чтобы обеспечить быстрый путь доступа к данным таблицы. </p><p align="justify" class="paragraph-source">     <i><b>Ключи</b></i> - это строго логическое понятие. Ключи соответствуют другому средству ORACLE, называемому ограничениями целостности. Ограничения целостности вводят в действие организационные правила базы данных. Так как некоторые ограничения целостности реализуются индексами, термины "ключ" и "индекс" часто смешиваются; однако не следует путать их друг с другом.</p></div><span id="lnk33f5e2b29ceb49b0b8a4191500d5d8cb"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Как хранятся индексы</b></p></div><span id="lnkf61c5e5365e141c289b7b5c1a3857956"> </span><div class="section"><p align="justify" class="paragraph-source">     Когда создается индекс, в табличном пространстве автоматически создается сегмент индекса для хранения данных этого индекса. Распределение пространства для сегмента индекса и использование этого зарезервированного пространства может контролироваться следующими способами:</p><p align="justify" class="paragraph-source">     - Распределением экстентов сегмента индекса можно управлять установкой параметров пространства для сегмента индекса.</p><p align="justify" class="paragraph-source">     - Свободную память в блоках данных, составляющих экстенты сегмента индекса, можно контролировать установкой параметра PCTFREE для сегмента индекса.</p><p align="justify" class="paragraph-source">     Табличное пространство для сегмента индекса - это либо умалчиваемое табличное пространство владельца, либо табличное пространство, явно специфицированное в предложении CREATE INDEX. Индекс не обязан располагаться в том же табличном пространстве, что и ассоциированная таблица. Более того, производительность запросов, использующих индекс, может быть улучшена за счет размещения индекса и таблицы в различных табличных пространствах, расположенных на разных дисковых устройствах, потому что данные индекса и данные таблицы могут извлекаться параллельно. </p></div><span id="lnk871a2f149f70493f8efa532b39850c13"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Формат блоков индекса</b></p></div><span id="lnk0d25479ba1bb4da49fd8b24732f95f7c"> </span><div class="section"><p align="justify" class="paragraph-source">     Память, доступная для данных индекса, определяется размером блока ORACLE за минусом накладных расходов блока, накладных расходов записи, ROWID и одного байта длины на каждое индексируемое значение. Число байт, требуемое для накладных расходов на блок индекса, зависит от операционной системы.</p><p align="justify" class="paragraph-source">     Когда создается индекс, индексируемые столбцы извлекаются и сортируются, и с каждым значением индекса для каждой строки записывается ROWID этой строки. Затем индекс загружается снизу вверх. </p><p align="justify" class="paragraph-source"></p><p align="justify" class="paragraph-source">     Например, рассмотрим предложение:</p><p align="justify" class="paragraph-source"></p><p align="justify" class="paragraph-source">CREATE INDEX ware_addr ON warehouses(address);</p><p align="justify" class="paragraph-source"></p><p align="justify" class="paragraph-source">     ORACLE сортирует все строки warehouses по столбцу address и загружает индекс значениями address ROWID для каждой строки таблицы warehouses. Хотя ORACLE распознает ключевые слова ASC, DESC, COMPRESS и NOCOMPRESS в команде CREATE INDEX, они не оказывают влияния на данные индекса, которые хранятся с использованием сжатия сзади в узлах ветвей, но не в узлах листьев.</p></div><span id="lnk5b24980b9fb444c0bb40dedafbbf3886"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Внутренняя структура индексов</b></p></div><span id="lnk87fe3e0fcfd0479ea1837cc05a02e1ad"> </span><div class="section"><p align="justify" class="paragraph-source">     ORACLE использует для индексов B*-деревья, сбалансированные, чтобы выравнять время доступа к любой строке. Верхние блоки (БЛОКИ ВЕТВЕЙ) B*-дерева индекса содержат данные индекса, указывающие на блоки индекса более низкого уровня. Блоки индекса низшего уровня (БЛОКИ ЛИСТЬЕВ) содержат каждое индексированное значение данных и соответствующий ROWID, служащий для нахождения действительной строки; блоки листьев связаны в двусвязный список. Индексы по столбцам, содержащим символьные данные, базируются на двоичных значениях символов в наборе символов базы данных.</p><p align="justify" class="paragraph-source">     Для уникального индекса на каждое значение данных существует один ROWID. Для неуникального индекса ROWID включен в ключ в отсортированном порядке, так что неуникальные индексы отсортированы по ключу и по ROWID. Значения ключей, состоящие только из пустых значений, не индексируются, если это не индексы кластера. Две строки могут состоять из одних пустых значений, и это не нарушает уникальности индекса.</p></div><span id="lnk32ac2445993249c79a2f53ea1316bb9a"> </span><div class="section"><p align="justify" class="paragraph-source">     Структура B*-дерева имеет следующие преимущества: </p><p align="justify" class="paragraph-source">     - Все блоки листьев в дереве имеют одинаковую глубину, так что извлечение любой записи из любого места индекса требует приблизительно одинакового времени. </p><p align="justify" class="paragraph-source">     - B*-деревья индексов автоматически балансируются. </p><p align="justify" class="paragraph-source">     - Все блоки в B*-дереве в среднем заполнены на 3/4. </p><p align="justify" class="paragraph-source">     - B*-деревья обеспечивают блестящую производительность извлечений для широкого спектра запросов, включая поиск по точному совпадению и по диапазону.</p><p align="justify" class="paragraph-source">     - Вставки, обновления и удаления эффективны и поддерживают порядок ключей для быстрого извлечения.</p><p align="justify" class="paragraph-source">     - Производительность B*-деревьев хороша как для маленьких, так и для больших таблиц, и не падает с ростом таблиц.</p></div><span id="lnk797b9b7ffd77486c820dc2a569c9023f"> </span><h2 align="left" class="paragraph-headline-source">     Привилегии</h2><span id="lnkaca1468ccd1f4a2980ba7cda22a5bbdf"> </span><div class="section"><p align="justify" class="paragraph-source">     Каждый пользователь в базе данных имеет набор привилегий. Это - то что пользователю разрешается делать. Эти привилегии могут изменяться со временем - новые добавляться, старые удаляться. </p><p align="justify" class="paragraph-source">     <i><b>Объектные привилегии</b></i> - позволяют пользователям выполнять конкретные действия на конкретном объекте (удалять строки в конкретной таблице, обращаться к таблице с запросом и т.п.).</p><p align="justify" class="paragraph-source">     Привилегии объекта связаны одновременно и с пользователями и с таблицами. То есть, привилегия дается определенному пользователю в указанной таблице, или базовой таблице или представлении. Привилегии, которые можно назначить пользователю:</p><p align="justify" class="paragraph-source">     - SELECT - Пользователь с этой привилегией может выполнять запросы в таблице.</p><p align="justify" class="paragraph-source">     - INSERT - Пользователь с этой привилегией может выполнять команду INSERT в таблице.</p><p align="justify" class="paragraph-source">     - UPDATE - Пользователь с этой привилегией может выполнять команду UPDATE на таблице. Вы можете ограничить эту привилегию для определенных столбцов таблицы.</p><p align="justify" class="paragraph-source">     - DELETE - Пользователь с этой привилегией может выполнять команду DELETE в таблице.</p><p align="justify" class="paragraph-source">     - REFERENCES - Пользователь с этой привилегией может определить внешний ключ, который использует один или более столбцов этой таблицы, как родительский ключ. </p><p align="justify" class="paragraph-source"></p><p align="justify" class="paragraph-source">     Механизм SQL назначает пользователям эти привилегии с помощью команды GRANT.</p><p align="justify" class="paragraph-source"></p><p align="justify" class="paragraph-source">GRANT    список объектных привелегий    ON      имя таблицы   TO имена пользователей;</p></div><span id="lnk093678f4ac404280a5b7ab3d64ab1951"> </span><table class="note"><tr><td><p align="justify" class="note-source">     Пример. Пусть пользователь Diane имеет таблицу Т1 и хочет позволить пользователю Adrian выполнить запрос к ней. Diane должна в этом случае ввести следующую команду:</p><p align="justify" class="note-source">GRANT SELECT ON Т1 TO Adrian;</p><p align="justify" class="note-source">     Теперь Adrian может выполнить запросы к таблице T1. Без других привилегий, он может только выбрать значения; но не может выполнить любое действие, которые бы воздействовало на значения в таблице Т1 ( включая использование таблицы Т1 в качестве родительской таблицы внешнего ключа). </p></td><th><img src="../../00/styles/files/note_problem.png" title="Проблемма" alt="Проблемма" /></th></tr></table><span id="lnk484767764d0b44b9816dcd55148e2648"> </span><div class="section"><p align="justify" class="paragraph-source">     SQL поддерживает два аргумента для команды GRANT, которые имеют специальное значение: <b>ALL PRIVILEGES </b>(все привилегии) или просто <b>ALL </b>и PUBLIC (общие). </p><p align="justify" class="paragraph-source">     <b>ALL </b>используется вместо имен привилегий в команде GRANT, чтобы отдать все привилегии в таблице. Например, Diane может дать Stephen весь набор привилегий в таблице Т1 с помощью такой команды:</p><p align="justify" class="paragraph-source"></p><p align="justify" class="paragraph-source">GRANT ALL ON Т1 TO Stephen;</p><p align="justify" class="paragraph-source"></p><p align="justify" class="paragraph-source">     <b>PUBLIC</b>: когда вы предоставляете привилегии для публикации, все пользователи автоматически их получают. Наиболее часто, это применяется для привилегии SELECT в определенных базовых таблицах или представлениях, которые вы хотите сделать доступными для любого пользователя. Чтобы позволить любому пользователю видеть таблицу Т2, вы, например, можете ввести следующее:</p><p align="justify" class="paragraph-source"></p><p align="justify" class="paragraph-source">GRANT SELECT ON Т2 TO PUBLIC;</p></div><span id="lnkc1203550dd0047bda8c16585b4fe8729"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Отмена привилегий</b></p></div><span id="lnkbfd4e4ecce8247119a1e7dc4ce8ca7e5"> </span><div class="section"><p align="justify" class="paragraph-source">     Потребность удалять привилегии сводится к команде <b>REVOKE</b>, фактически стандартному средству с достаточно понятной формой записи. Синтаксис команды REVOKE - похож на GRANT, но имеет обратный смысл. </p><p align="justify" class="paragraph-source">     </p><p align="justify" class="paragraph-source">     REVOKE перечень объектных привелегий ON имена объектов FROM имена пользователей; </p><p align="justify" class="paragraph-source"></p><p align="justify" class="paragraph-source">     Чтобы удалить привилегию INSERT для Adrian в таблице Т2, вы можете ввести</p><p align="left" class="paragraph-source">     REVOKE INSERT ON Т2 FROM Adrian;</p></div><span id="lnkdfd2d3c4ed9f43a191b2a4e5a8680017"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Системные привилегии</b></p></div><span id="lnkd6715beed4394a869cbf7af94b4d6116"> </span><div class="section"><p align="justify" class="paragraph-source">     Привилегии, которые не определяются в терминах специальных объектов данных, называются  привилегиями системы, или правами базы данных. </p><p align="justify" class="paragraph-source">     Системные привелегии - позволяют пользователям выполнять конкретное действие на уровне системы или конкретное действие над конкретным типом объектов (создавать пользователя, таблицу, представление и т.д.).</p><p align="justify" class="paragraph-source">     При общем подходе имеется три базовых привилегии системы:</p><p align="justify" class="paragraph-source">     -   CONNECT  (Подключить); </p><p align="justify" class="paragraph-source">     -   RESOURCE (Ресурс);</p><p align="justify" class="paragraph-source">     -   DBA (Аминистратор Базы Данных).</p><p align="justify" class="paragraph-source">     Команда GRANT, в измененной форме, является пригодной для использования с привилегиями объекта, как и с системными привилегиями. </p><p align="left" class="paragraph-source">GRANT     список системных привелегий   TO      имена пользователей;</p></div><span id="lnka231214404d94beb86130d7bd9a859bd"> </span><div class="section"><p align="justify" class="paragraph-source">     Для начала передача прав может быть сделана с помощью DBA. Например, DBA может передать привилегию для создания таблицы пользователю Rodriguez следующим образом:</p><p align="justify" class="paragraph-source">     </p><p align="justify" class="paragraph-source">GRANT RESOURCE TO Rodriguez;</p><p align="justify" class="paragraph-source"></p><p align="justify" class="paragraph-source">     В следующей команде системный администратор может передать привилегию создавать таблицы CREATE TABLE пользователю Thelonius:</p><p align="justify" class="paragraph-source">GRANT CREATE TABLE TO Thelonius;</p><p align="justify" class="paragraph-source">а потом отменить ее:</p><p align="left" class="paragraph-source">REVOKE CREATE TABLE FROM Thelonius;          </p></div></div></td></tr></table></td></tr><tr><td id="bottomOuter"><table id="bottomInner"><tr><td class="cell1"><div> </div></td><td class="cell2"><div>© 2012 ХНУРЭ, ПИ, Широкопетлева М.С., <a href="mailto:mshirokopetleva@gmail.com">mshirokopetleva@gmail.com</a>;   ХНУРЭ, ПИ, Черепанова Ю.Ю.;   ХНУРЭ, ПИ, Мазурова О.А.<br /><a href="http://lersus.de/" title="Данный курс создан с помощью авторской системы LERSUS" target="_blank">Разработано с помощью LERSUS</a></div></td></tr></table></td></tr></table></body></html>