<html xmlns="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="LERSUS 3.3.0.0" /><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Корпоративные информационные системы — Теория — Процессы инстанции Oracle </title><script language="javascript" type="text/javascript" src="../../00/styles/files/apiwrapper.js"> </script><script language="javascript" type="text/javascript" src="../../00/styles/files/sco.js"> </script><link href="../../00/styles/files/style.css" rel="stylesheet" type="text/css" /></head><body><table id="mainOuter"><tr><td id="topOuter"><table id="topInner"><tr class="row1"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4" id="shortcuts"><div><ul class="level0"><li><a href="../../00/content/authors1.html">Авторы</a></li><li>|</li><li><a href="../../00/content/contacts1.html">Контакты</a></li><li>|</li><li><a href="../../00/content/instructions1.html">Методические указания</a></li><li>|</li><li><a href="../../00/content/annotation1.html">Аннотация</a></li><li>|</li><li><a href="#" onclick="history.back(); return false;">Назад</a></li></ul></div></td></tr><tr class="row2"><td class="cell1"><div> </div></td><td class="cell2"><div> </div></td><td class="cell3"><div> </div></td><td class="cell4"><div id="courseTitle">Корпоративные информационные системы</div><div id="courseSubTitle">Физическая организация БД на примере СУБД Oracle : Процессы инстанции Oracle </div></td></tr></table></td></tr><tr><td id="contentOuter"><table id="contentInner"><tr><td class="menuOuter"><table class="menuInner"><tr><td><ul class="level0"><li><a href="../../00/styles/courses.html">Содержание курса</a></li><li><span>Теория</span></li><ul class="level1"><li><a href="../../02/content/content1.html">Основные концепции СУБД Oracle</a></li><li><a href="../../02/content/content2.html">Логическая структура</a></li><li><a href="../../02/content/content3.html">Экстенты и сегменты</a></li><li><a href="../../02/content/content4.html">Табличные пространства и файлы данных </a></li><li><a href="../../02/content/content5.html">Процессы инстанции Oracle </a></li><li><a href="../../02/content/content6.html">Структуры памяти ORACLE</a></li><li><a href="../../02/content/content7.html">Создание таблиц с распределением памяти </a></li><li><a href="../../02/content/content8.html">Объекты базы данных</a></li><li><a href="../../02/content/content9.html">Утилита SQL*Plus</a></li><li><a href="../../02/content/content10.html">Работа со словарем данных</a></li><li><a href="../../02/content/content11.html">Введение в аудитинг</a></li></ul><li><span>Практика</span></li><ul class="level1"><li><a href="../../02/content/example1.html">Практика 1. Настройка структур памяти при создании основных объектов БД</a></li><li><a href="../../02/content/example2.html">Лабораторная работа 1. Работа с основными объектами базы и служебной информацией</a></li></ul><li><span>Текущий контроль знаний</span></li><ul class="level1"><li><a href="../../02/content/multiply-choice-test1.html">Введение в сервер Oracle</a></li><li><a href="../../02/content/multiply-choice-test9.html">Объекты схемы базы данных Oracle</a></li></ul><li><a href="../../02/styles/glossary.html">Словарь терминов</a></li><li><a href="../../02/02.pdf" target="_blank">Версия для печати</a></li></ul></td></tr></table></td><td class="content"><div id="content"><div id="topBlankStripe"> </div><span id="lnkd7491e11fe0048e4aa1f57e4d48f6b26"> </span><h1 align="left" class="headline-source">     Процессы инстанции Oracle </h1><span id="lnkfb381e61eaea44d4a53cca479c1acfa2"> </span><h2 align="left" class="paragraph-headline-source">     Инстанция ORACLE</h2><span id="lnkb3a00d1d64584c87a247d13d077555ce"> </span><div class="section"><p align="justify" class="paragraph-source">     Независимо от типа компьютера, на котором выполняется ORACLE, и от конкретных используемых опций памяти и процессов, с каждой работающей базой данных ORACLE ассоциируется инстанция ORACLE. </p><p align="justify" class="paragraph-source">     Каждый раз, когда на сервере запускается база данных, происходит распределение области памяти, называемой <i><b>глобальной областью системы (SGA)</b></i>, и запускаются один или более процессов ORACLE. </p><p align="justify" class="paragraph-source">     Совокупность SGA и процессов ORACLE называется <i><b>инстанцией базы данных ORACLE</b></i> (см. рис. 7). Структуры памяти и процессы инстанции предназначены для эффективного управления базой данных и обслуживания одного или нескольких пользователей ассоциированной базы данных.</p><p align="justify" class="paragraph-source">     </p><p align="justify" class="paragraph-source"> </p><p align="center" class="paragraph-source"><img src="../res/files/th1_13_0__1_.JPG" height="273px" width="610px" alt="" /> </p><p align="center" class="paragraph-source">Рисунок 7 - Инстанция ORACLE </p><p align="center" class="paragraph-source">     </p><p align="justify" class="paragraph-source">     Сначала инстанция запускается, затем она монтирует базу данных. На одних и тех же машинах могут быть запущены несколько инстанций, каждая из которых имеет доступ к своей собственной физической базе данных. В слабосвязанных системах используется параллельный сервер ORACLE, в котором одна и та же база данных монтируется несколькими инстанциями; все эти инстанции разделяют единую физическую базу данных. </p><p align="justify" class="paragraph-source">     <i><b>Процесс </b></i>- это "канал управления", или механизм в операционной системе, способный выполнять последовательность шагов. Некоторые операционные системы используют термины "задание" или "задача". </p><p align="justify" class="paragraph-source">     Процесс обычно имеет свою собственную личную область памяти, в которой он выполняется. Структура процесса такой системы, как ORACLE, существенна, потому что она определяет, как осуществляется параллельная деятельность и как она управляется.</p><p align="justify" class="paragraph-source">     Например, двумя целями структуры процесса могут быть: </p><p align="justify" class="paragraph-source">     - симуляция личных окружений для нескольких одновременно работающих процессов, так, как будто каждый процесс имеет свое собственное личное окружение; </p><p align="justify" class="paragraph-source">     - обеспечение разделения между процессами ресурсов компьютера, необходимых каждому процессу, но не на долгое время. </p><p align="justify" class="paragraph-source">     Архитектура процессов ORACLE спроектирована для максимизации производительности. </p></div><span id="lnk8db7e7c14b374e50843fcf22f625fd71"> </span><h2 align="left" class="paragraph-headline-source">     Однопроцессная инстанция ORACLE </h2><span id="lnk53e0143b1d0c45699e9403e17744f691"> </span><div class="section"><p align="justify" class="paragraph-source">     Однопроцессная (также называемая однопользовательской) система ORACLE - это система базы данных, в которой весь код ORACLE исполняется одним процессом. Не используются разные процессы, чтобы разграничить выполнение компонент ORACLE и прикладной программы клиента. Вместо этого весь код ORACLE и единственное приложение базы данных выполняются как единственный процесс. </p><p align="justify" class="paragraph-source">     Единственный процесс исполняет весь код, ассоциированный как с приложением базы данных, так и с ORACLE. </p><p align="justify" class="paragraph-source">     К инстанции ORACLE в однопроцессном окружении может иметь доступ лишь один пользователь; несколько пользователей не могут обращаться к базе данных одновременно. </p><p align="justify" class="paragraph-source">     Например, к ORACLE, выполняющемуся под операционной системой MS-DOS на PC, может иметь доступ лишь один пользователь, потому что MS-DOS не способна выполнять несколько процессов. </p></div><span id="lnk0a2579feff5a4fa5abc52969b45710bd"> </span><h2 align="left" class="paragraph-headline-source">     Многопроцессная инстанция ORACLE</h2><span id="lnkb4229001b4d249eb9538ab7b1dc23e5b"> </span><div class="section"><p align="justify" class="paragraph-source">     <i><b>Многопроцессный ORACLE </b></i>(называемый также <i><b>многопользовательским</b></i>) использует несколько процессов для исполнения различных частей ORACLE, а также отдельный процесс для каждого присоединенного пользователя. Каждый процесс в многопроцессном ORACLE выполняет специфическую задачу. Благодаря разделению работы ORACLE и приложений базы данных на несколько процессов, несколько пользователей и приложений могут одновременно присоединяться к единственной инстанции базы данных, в то время как система поддерживает отличную производительность. </p><p align="justify" class="paragraph-source">     Большинство систем баз данных - многопользовательские, ибо одним из основных преимуществ СУБД является управление данными, с которыми много пользователей работают одновременно. </p><p align="justify" class="paragraph-source">     Каждый присоединенный пользователь имеет отдельный пользовательский процесс, а для выполнения ORACLE используются несколько фоновых процессов. В многопроцессной системе все процессы можно разделить на две группы: пользовательские процессы и процессы ORACLE. </p></div><span id="lnkbb76ec9db59c4ff9a8350c6ccd354c10"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Пользовательские процессы</b></p></div><span id="lnk2a45e7289df54d8d8a0dc7d2a7b6f7bf"> </span><div class="section"><p align="justify" class="paragraph-source">     Когда пользователь запускает прикладную программу, такую как программу Pro*C, или инструмент ORACLE, такой как SQL*DBA, для выполнения приложения пользователя создается пользовательский процесс. </p></div><span id="lnk31dbf8709e6a4772b8709e3718c25796"> </span><div class="section"><p align="justify" class="paragraph-source">     В многопроцессных системах, ORACLE функционирует через два типа процессов ORACLE: процессы сервера и фоновые процессы. </p><p align="justify" class="paragraph-source">     Процессы сервера создаются для обработки запросов от пользовательских процессов, присоединяемых к инстанции. Часто, когда приложение и ORACLE работают не через сеть, а на одной и той же машине, пользовательский процесс и соответствующий ему процесс сервера комбинируются в единый процесс, чтобы уменьшить накладные расходы системы. Однако, если приложение и ORACLE работают на разных машинах, пользовательский процесс взаимодействует с ORACLE через отдельный процесс сервера. </p><p align="justify" class="paragraph-source">     Процессы сервера (или серверная порция в комбинированном процессе пользователь/сервер), создаваемые от имени приложения каждого пользователя, могут выполнять одну или несколько из следующих задач: </p><p align="justify" class="paragraph-source">     - разбор и исполнение предложений SQL, выдаваемых приложением; </p><p align="justify" class="paragraph-source">     - считывание необходимых блоков данных с диска (из файлов данных) в разделяемые буфера базы данных в SGA, если этих блоков еще нет в SGA; </p><p align="justify" class="paragraph-source">     - возврат результатов таким способом, чтобы приложение могло обрабатывать эту информацию. </p><p align="justify" class="paragraph-source">     Для максимизации производительности и координации работы многих пользователей многопроцессная система ORACLE использует несколько дополнительных процессов, называемых ФОНОВЫМИ ПРОЦЕССАМИ. На многих операционных системах фоновые процессы создаются автоматически при запуске инстанции. На других операционных системах процессы сервера создаются как часть инсталляции ORACLE. </p><p align="justify" class="paragraph-source">     Инстанция ORACLE может иметь большое число фоновых процессов; не все из них присутствуют всегда. Эти процессы имеют следующие имена в инстанции ORACLE: </p><p align="justify" class="paragraph-source">     - процесс записи в базу данных (DBWR); </p><p align="justify" class="paragraph-source">     - процесс записи в журнал (LGWR); </p><p align="justify" class="paragraph-source">     - контрольная точка (CKPT); </p><p align="justify" class="paragraph-source">     - монитор системы (SMON); </p><p align="justify" class="paragraph-source">     - монитор процессов (PMON); </p><p align="justify" class="paragraph-source">     - архиватор (ARCH); </p><p align="justify" class="paragraph-source">     - восстановитель (RECO); </p><p align="justify" class="paragraph-source">     - блокировка (LCKn); </p><p align="justify" class="paragraph-source">     - диспетчер (Dnnn); </p><p align="justify" class="paragraph-source">     - сервер (Snnn). </p></div><span id="lnk8d49eb0b5d7344b981d9a5ff11966cec"> </span><h2 align="left" class="paragraph-headline-source">     Процессы инстанции Oracle</h2><span id="lnkee57cc6152f54265b27859c0ee55aa48"> </span><div class="section"><p align="left" class="paragraph-source">     Взаимодействие фоновых процессов с различными частями базы данных ORACLE проиллюстрировано на рисунке 8. </p><p align="left" class="paragraph-source">     </p><p align="left" class="paragraph-source"></p><p align="center" class="paragraph-source"><img src="../res/files/th1_14_0__1_.JPG" height="567px" width="539px" alt="" /> </p><p align="center" class="paragraph-source">Рисунок 8 - Фоновые процессы много процессной инстанции ORACLE </p></div><span id="lnkc1547cc2cad9485e86333fe3207f44b2"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Процесс записи в базу данных (DBWR) </b></p></div><span id="lnkf7bdc4553af444e8a701ba5a357f81d5"> </span><div class="section"><p align="justify" class="paragraph-source">     Вся запись буферов в файлы данных выполняется процессом DBWR, фоновым процессом ORACLE, ответственным за управление буферным кэшем. Когда буфер в буферном КЭШе модифицируется, он помечается как "грязный"; основная <i><b>задача процесса DBWR</b></i> - поддержание "чистоты" буфера путем записи грязных буферов на диск. По мере того, как буфера в КЭШе заполняются из базы данных и загрязняются пользовательскими процессами, число свободных буферов убывает. Когда число свободных буферов становится слишком маленьким, пользовательские процессы, которые должны считывать в кэш блоки данных с диска, не могут найти свободные буфера. DBWR управляет буферным КЭШем так, чтобы пользовательские процессы всегда могли найти свободные буфера. </p><p align="justify" class="paragraph-source">     Алгоритм LRU поддерживает в памяти блоки данных, которые использовались наиболее недавно, и тем самым минимизирует ввод-вывод. Часто используемые блоки, например, блоки, входящие в часто используемые небольшие таблицы или индексы, постоянно поддерживаются в кэше, так что их не приходится все время считывать с диска. Блоки, используемые не столь часто, например, части больших таблиц или блоки листьев из очень больших индексов, удаляются из SGA, если они не были модифицированы после их считывания, или записываются на диск после их модификации, чтобы освободить в буферном кэше место для других блоков. Схема LRU заставляет наиболее часто используемые блоки оставаться в буферном кэше, так что, когда блок записывается на диск, маловероятно, что он вскоре потребуется снова. Однако, если процесс DBWR становится слишком активным, он может записывать на диск и те блоки, которые могут потребоваться снова. </p><p align="justify" class="paragraph-source">     Процесс DBWR получает сигнал о том, что надо записывать грязные блоки, при следующих условиях: </p><p align="justify" class="paragraph-source">     - Когда процесс сервера перемещает буфер в "грязный список" и обнаруживает, что этот список достиг пороговой величины, он сигнализирует процессу DBWR. Пороговая величина определяется как половина значения параметра DB_BLOCK_WRITE_BATCH. </p><p align="justify" class="paragraph-source">     - Когда процесс сервера просмотрел в списке LRU число буферов, равное DB_BLOCK_MAX_SCAN_CNT, и не нашел свободного буфера, он прекращает поиск и сигнализирует процессу DBWR (ибо не хватает свободных буферов, и DBWR должен освободить часть буферов). </p><p align="justify" class="paragraph-source">     - Когда истекает таймаут (каждые три секунды), DBWR сигнализирует самому себе. </p><p align="justify" class="paragraph-source">     - Когда возникает контрольная точка, процесс записи журнала (LGWR) сигнализирует процессу DBWR. </p><p align="justify" class="paragraph-source">     В первых двух случаях DBWR записывает блоки из грязного списка на диск посредством одной МНОГОБЛОЧНОЙ ОПЕРАЦИИ ЗАПИСИ. Число блоков, записываемых в одной операции, специфицируется параметром инициализации DB_BLOCK_WRITE_BATCH. Если в грязном списке еще нет DB_BLOCK_WRITE_BATCH буферов, когда DBWR принял сигнал, то DBWR просматривает список LRU в поисках дополнительных грязных буферов. ТАЙМАУТ возникает, если DBWR неактивен в течение трех секунд. В этом случае DBWR отыскивает указанное число буферов в списке LRU и записывает все найденные грязные буфера на диск. При каждом таймауте DBWR ищет новую группу буферов. Число буферов, которое DBWR просматривает при таймауте, равно удвоенному значению параметра инициализации DB_BLOCK_WRITE_BATCH. Если база данных простаивает, DBWR в конечном счете переписывает на диск весь буферный кэш. </p><p align="justify" class="paragraph-source">     Когда возникает <i><b>контрольная точка</b></i>, процесс записи журнала (LGWR) специфицирует список модифицированных буферов, которые должны быть записаны на диск. DBWR переписывает указанные буфера на диск. </p></div><span id="lnkf246b064d172420987172d438f99bf40"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Процесс записи в журнал (LGWR) </b></p></div><span id="lnk4e68a2f9d47341139386e85f8940941c"> </span><div class="section"><p align="justify" class="paragraph-source">     Буфер журнала повторения записывается в файл журнала повторения на диск процессом записи в журнал (LGWR), фоновым процессом ORACLE, ответственным за управление буфером журнала повторения. </p><p align="justify" class="paragraph-source">     <i><b>Процесс LGWR </b></i>записывает все записи повторения, которые были скопированы в буфер после последней операции его записи. LGWR записывает на диск один непрерывный участок буфера. </p><p align="justify" class="paragraph-source">     Процесс LGWR записывает: </p><p align="justify" class="paragraph-source">     - запись подтверждения, когда пользовательский процесс подтверждает транзакцию; </p><p align="justify" class="paragraph-source">     - буфера повторения каждые три секунды; </p><p align="justify" class="paragraph-source">     - буфера повторения, когда буфер журнала повторения заполняется на одну треть; </p><p align="left" class="paragraph-source">     - буфера повторения, когда процесс DBWR записывает на диск модифицированные буфера. </p></div><span id="lnk04046b737be949f1894b243edd5d2f59"> </span><table class="note"><tr><td><p align="justify" class="note-source">     LGWR осуществляет синхронную запись в активную зеркальную группу файлов журнала повторения. Если один из файлов в этой группе запорчен или недоступен, LGWR может продолжать запись в остальные файлы (ошибка также регистрируется в файле трассировки LGWR и системном файле ALERT). Если запорчены все файлы в группе, или группа недоступна, потому что она не была архивирована, то LGWR не может продолжать функционировать. </p></td><th><img src="../../00/styles/files/note_comment.png" title="" alt="" /></th></tr></table><span id="lnkc33cddae9a1348fdbecdbb71bb1c8688"> </span><table class="note"><tr><td><p align="justify" class="note-source">     Иногда, если требуется больше места в буфере, LGWR записывает записи журнала повторения до того, как транзакция подтверждена. Эти записи становятся постоянными лишь в случае подтверждения транзакции. </p></td><th><img src="../../00/styles/files/note_comment.png" title="" alt="" /></th></tr></table><span id="lnk6510d21d644e4fb4ade0e65f192fd463"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Контрольная точка (CKPT)</b></p></div><span id="lnk4f1d5f74dc0247ccb6127859b8046725"> </span><div class="section"><p align="justify" class="paragraph-source">     Когда возникает контрольная точка, заголовки всех файлов данных должны быть обновлены, чтобы отразить эту контрольную точку. В обычных обстоятельствах эту работу выполняет LGWR. Однако, если контрольные точки значительно понижают производительность системы (обычно при наличии многих файлов данных), то вы можете задействовать процесс CKPT, чтобы отделить выполнение контрольных точек от другой работы, выполняемой процессом LGWR. Для большинства приложений процесс CKPT не является необходимым. Если ваша база данных имеет много файлов данных, и производительность процесса LGWR существенно снижается во время контрольных точек, вы можете включить процесс CKPT. </p><p align="justify" class="paragraph-source">     <i>Процесс CKPT </i>не записывает блоки на диск; эту работу всегда выполняет DBWR. Статистика DBWR CHECKPOINTS, которую выдает монитор статистики SQL*DBA, показывает число завершенных сообщений контрольной точки, независимо от того, задействован ли процесс CKPT. Процесс CKPT включается или отключается параметром инициализации CHECKPOINT_PROCESS; его умалчиваемое значение FALSE. </p></div><span id="lnk3742c689c0c64fa89e65ce495259c289"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Монитор системы (SMON)</b></p></div><span id="lnke27a696757cc403fac76455f4d289918"> </span><div class="section"><p align="justify" class="paragraph-source">     <i><b>Процесс монитора системы (SMON) </b></i>выполняет восстановление инстанции при запуске инстанции. SMON также отвечает за очистку временных сегментов, когда они больше не используются; он также сжимает непрерывные свободные экстенты, чтобы сделать доступным большее количество блоков свободной памяти. В среде Параллельного сервера SMON осуществляет восстановление инстанции для сбившегося процессора или инстанции. </p><p align="justify" class="paragraph-source">     SMON регулярно "просыпается", чтобы проверить необходимость своей работы; он может также быть вызван, если другой процесс обнаружит необходимость в нем.</p></div><span id="lnkb514447997944b70aeb8220615acfb0a"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Монитор процессов (PMON)</b></p></div><span id="lnk18726764fad343daa74afd5d76bd57ca"> </span><div class="section"><p align="justify" class="paragraph-source">     <i><b>Монитор процессов (PMON)</b></i> выполняет восстановление процесса, когда пользовательский процесс сбивается. PMON отвечает за очистку кэша и освобождение ресурсов, использовавшихся процессом. Например, он сбрасывает состояние таблицы активных транзакций, освобождает блокировки и удаляет ID процесса из списка активных процессов.</p><p align="justify" class="paragraph-source">     PMON также периодически проверяет состояние серверных и диспетчерских процессов и перезапускает погибшие процессы (но не те, которые ORACLE уничтожил преднамеренно). Как и SMON, PMON регулярно "просыпается", чтобы проверить необходимость своей работы; он может также быть вызван, если другой процесс обнаружит необходимость в нем.</p></div><span id="lnk43888964eeaa480a9b504e40c58a62eb"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Восстановитель (RECO)</b></p></div><span id="lnk230b256f6c2c48b990ce51c624b4b41b"> </span><div class="section"><p align="justify" class="paragraph-source">     <i><b>Восстановитель (RECO) </b></i>- это процесс, используемый с распределенной опцией ORACLE, которая автоматически исправляет сбои, в которых участвуют распределенные транзакции. Фоновый процесс RECO на узле автоматически соединяется с базами данных, участвовавшими в сомнительной распределенной транзакции. Когда соединение между соответствующими серверами баз данных восстановлено, процессы RECO автоматически разрешают все сомнительные транзакции. Строки, соответствующие каждой разрешаемой сомнительной транзакции, автоматически удаляются из таблицы ожидающих транзакций каждой базы данных. Если фоновый процесс RECO сервера базы данных пытается установить соединение с удаленным сервером, а этот удаленный сервер оказывается недоступным в сети, или соединение не восстанавливается, то RECO автоматически повторяет попытку соединения через интервал времени. Интервалы между последовательными попытками соединения экспоненциально увеличиваются.</p></div><span id="lnk63abcafe87d846f2bfb9a173bfb15573"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Архиватор (ARCH)</b></p></div><span id="lnk40debe2443df48f49ac79ea8fda8cc81"> </span><div class="section"><p align="justify" class="paragraph-source">     <i><b>Архиватор (ARCH)</b></i> копирует онлайновые файлы журнала повторения на указанное устройство памяти, когда они заполняются. ARCH присутствует лишь в том случае, когда журнал повторения используется в режиме ARCHIVELOG и включено автоматическое архивирование. </p></div><span id="lnk9bc507604b5a4aa89e2c790d9140be6c"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Блокировка (LCKn)</b></p></div><span id="lnk7ecc4609babe434cb913bda4dc705dee"> </span><div class="section"><p align="justify" class="paragraph-source">     В среде Параллельного сервера до десяти процессов <i><b>блокировки </b></i>(LCK0, ..., LCK9) могут использоваться для блокировок между инстанциями; однако для большинства систем параллельного сервера достаточно одного процесса блокировки (LCK0). </p></div><span id="lnk2de1033087bd4bc4b562a6094fe98a2a"> </span><div class="section"><p align="left" class="paragraph-source">     <b>Диспетчерские процессы (Dnnn)</b></p></div><span id="lnk35c469ababbf4716860f46c81ce65d79"> </span><div class="section"><p align="justify" class="paragraph-source">     Диспетчерские процессы позволяют пользовательским процессам разделять ограниченное число серверных процессов. Без диспетчера, каждому пользовательскому процессу требуется свой выделенный процесс сервера; однако в конфигурации многоканального сервера несколько разделяемых серверных процессов могут обслуживать такое же число пользователей. Поэтому в системе с большим количеством пользователей многоканальный сервер может поддерживать большее число пользователей, особенно в окружениях клиент-сервер, когда приложение-клиент и сервер работают на разных машинах. Для одной инстанции базы данных может быть создано несколько диспетчерских процессов; по меньшей мере один диспетчер должен быть создан для каждого сетевого протокола, через который пользователи соединяются с ORACLE. Администратор базы данных должен запустить оптимальное число диспетчерских процессов, в зависимости от ограничения операционной системы для числа соединений ни один процесс, и может добавлять и удалять диспетчерские процессы во время работы инстанции.</p></div><span id="lnk43c23877e41f42649b82bdb6eac94dc2"> </span><table class="note"><tr><td><p align="justify" class="note-source">     Многоканальный сервер требует наличия SQL*Net версии 2 или более поздней. Каждый пользовательский процесс, соединяющийся с диспетчером, должен делать это через SQL*Net, даже если оба процесса выполняются на одной и той же машине. В конфигурации многоканального сервера, процесс слушателя сети ожидает запросов на соединение от приложений-клиентов, и направляет каждый такой запрос диспетчерскому процессу. Если слушатель не может соединить запрос со свободным диспетчером, он запускает выделенный серверный процесс и соединяет клиента с  этим процессом. Процесс слушателя не является частью инстанции ORACLE; скорее это часть сетевых процессов, работающих с ORACLE.</p></td><th><img src="../../00/styles/files/note_comment.png" title="" alt="" /></th></tr></table><span id="lnk17177355843a4993becc9c88f29860f4"> </span><div class="section"><p align="justify" class="paragraph-source">     Когда запускается инстанция, слушатель открывает и устанавливает коммуникационный путь, через который клиенты соединяются с ORACLE. Затем каждый диспетчер сообщает слушателю адрес, по которому этот диспетчер слушает запросы на соединение. Когда пользовательский процесс выдает запрос на соединение, слушатель исследует этот запрос и определяет, может ли данный пользователь использовать диспетчера. Если да, то процесс слушателя возвращает адрес диспетчерского процесса с наименьшей загрузкой, и пользовательский процесс непосредственно соединяется с этим диспетчером.</p><p align="justify" class="paragraph-source">     Некоторые пользовательские процессы не могут общаться с диспетчером (например, пользователи, соединяющиеся через SQL*Net более старой версии, чем 2.0), и процесс сетевого слушателя не может соединять таких пользователей с диспетчером. В этом случае слушатель создает выделенный серверный процесс и устанавливает требуемое соединение.</p></div></div></td></tr></table></td></tr><tr><td id="bottomOuter"><table id="bottomInner"><tr><td class="cell1"><div> </div></td><td class="cell2"><div>© 2012 ХНУРЭ, ПИ, Широкопетлева М.С., <a href="mailto:mshirokopetleva@gmail.com">mshirokopetleva@gmail.com</a>;   ХНУРЭ, ПИ, Черепанова Ю.Ю.;   ХНУРЭ, ПИ, Мазурова О.А.<br /><a href="http://lersus.de/" title="Данный курс создан с помощью авторской системы LERSUS" target="_blank">Разработано с помощью LERSUS</a></div></td></tr></table></td></tr></table></body></html>